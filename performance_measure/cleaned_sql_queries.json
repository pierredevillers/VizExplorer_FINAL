[
    {
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "reference_sql_query": {
            "raw": "SELECT\"Free Meal Count (K-12)\"/\"Enrollment (K-12)\"FROM frpm WHERE \"County Name\"= 'Alameda' ORDER BY (CAST(\"Free Meal Count (K-12)\"AS REAL) /\"Enrollment (K-12)\") DESC LIMIT 1",
            "normalized": "SELECT\"Free Meal Count (K-12)\"/\"Enrollment (K-12)\"\nFROM frpm\nWHERE \"County Name\"= 'Alameda'\nORDER BY (CAST(\"Free Meal Count (K-12)\"AS REAL) /\"Enrollment (K-12)\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(\"Percent (%) Eligible Free (K-12)\") AS highest_eligible_free_rate\nFROM public.frpm\nWHERE \"County Name\" = 'Alameda'",
            "normalized": "SELECT MAX(\"Percent (%) Eligible Free (K-12)\") AS highest_eligible_free_rate\nFROM public.frpm\nWHERE \"County Name\" = 'Alameda'"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "reference_sql_query": {
            "raw": "SELECT\"Free Meal Count (Ages 5-17)\"/\"Enrollment (Ages 5-17)\"FROM frpm WHERE\"Educational Option Type\"= 'Continuation \"School\"' AND\"Free Meal Count (Ages 5-17)\"/\"Enrollment (Ages 5-17)\"IS NOT NULL ORDER BY\"Free Meal Count (Ages 5-17)\"/\"Enrollment (Ages 5-17)\"ASC LIMIT 3",
            "normalized": "SELECT\"Free Meal Count (Ages 5-17)\"/\"Enrollment (Ages 5-17)\"\nFROM frpm\nWHERE\"Educational Option Type\"= 'Continuation \"School\"'\n  AND\"Free Meal Count (Ages 5-17)\"/\"Enrollment (Ages 5-17)\"IS NOT NULL\nORDER BY\"Free Meal Count (Ages 5-17)\"/\"Enrollment (Ages 5-17)\"ASC\nLIMIT 3"
        },
        "generated_sql_query": {
            "raw": "SELECT \"School Name\", \"Percent (%) Eligible Free (Ages 5-17)\"\nFROM public.frpm\nWHERE \"School Type\" = 'Continuation'\nORDER BY \"Percent (%) Eligible Free (Ages 5-17)\" ASC\nLIMIT 3;",
            "normalized": "SELECT \"School Name\",\n       \"Percent (%) Eligible Free (Ages 5-17)\"\nFROM public.frpm\nWHERE \"School Type\" = 'Continuation'\nORDER BY \"Percent (%) Eligible Free (Ages 5-17)\" ASC\nLIMIT 3;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"MailStreet\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" ORDER BY T1.\"FRPM Count (K-12)\"DESC LIMIT 1",
            "normalized": "SELECT T2.\"MailStreet\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nORDER BY T1.\"FRPM Count (K-12)\"DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "WITH MaxFRPM AS (\n    SELECT \"CDSCode\", MAX(\"FRPM Count (K-12)\") AS MaxFRPMCount\n    FROM public.frpm\n    GROUP BY \"CDSCode\"\n)\nSELECT s.\"MailStreet\"\nFROM public.schools s\nJOIN MaxFRPM f ON s.\"CDSCode\" = f.\"CDSCode\"\nORDER BY f.MaxFRPMCount DESC\nLIMIT 1;",
            "normalized": "WITH MaxFRPM AS\n  (SELECT \"CDSCode\",\n          MAX(\"FRPM Count (K-12)\") AS MaxFRPMCount\n   FROM public.frpm\n   GROUP BY \"CDSCode\")\nSELECT s.\"MailStreet\"\nFROM public.schools s\nJOIN MaxFRPM f ON s.\"CDSCode\" = f.\"CDSCode\"\nORDER BY f.MaxFRPMCount DESC\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T2.\"School\") FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T2.\"Virtual\" = 'F' AND T1.\"AvgScrMath\" > 400",
            "normalized": "SELECT COUNT(DISTINCT T2.\"School\")\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE T2.\"Virtual\" = 'F'\n  AND T1.\"AvgScrMath\" > 400"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM public.satscores s\nJOIN public.schools sc ON s.cds = sc.\"CDSCode\"\nWHERE s.\"AvgScrMath\" > 400 AND sc.\"Virtual\" = 'Yes';",
            "normalized": "SELECT COUNT(*)\nFROM public.satscores s\nJOIN public.schools sc ON s.cds = sc.\"CDSCode\"\nWHERE s.\"AvgScrMath\" > 400\n  AND sc.\"Virtual\" = 'Yes';"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
        "reference_sql_query": {
            "raw": "SELECT \"NumTstTakr\" FROM satscores WHERE \"cds\" = ( SELECT \"CDSCode\" FROM frpm ORDER BY\"FRPM Count (K-12)\"DESC LIMIT 1 )",
            "normalized": "SELECT \"NumTstTakr\"\nFROM satscores\nWHERE \"cds\" =\n    (SELECT \"CDSCode\"\n     FROM frpm\n     ORDER BY\"FRPM Count (K-12)\"DESC\n     LIMIT 1)"
        },
        "generated_sql_query": {
            "raw": "SELECT s.sname, s.NumTstTakr\nFROM public.satscores s\nJOIN public.frpm f ON s.cds = f.\"CDSCode\"\nWHERE f.\"FRPM Count (K-12)\" = (\n    SELECT MAX(\"FRPM Count (K-12)\")\n    FROM public.frpm\n)",
            "normalized": "SELECT s.sname,\n       s.NumTstTakr\nFROM public.satscores s\nJOIN public.frpm f ON s.cds = f.\"CDSCode\"\nWHERE f.\"FRPM Count (K-12)\" =\n    (SELECT MAX(\"FRPM Count (K-12)\")\n     FROM public.frpm)"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Among the schools with the average score in Math over 560 in the SAT test, how many schools are directly charter-funded?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.\"School Code\") FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T1.\"AvgScrMath\" > 560 AND T2.\"Charter Funding Type\"= 'Directly funded'",
            "normalized": "SELECT COUNT(T2.\"School Code\")\nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE T1.\"AvgScrMath\" > 560\n  AND T2.\"Charter Funding Type\"= 'Directly funded'"
        },
        "generated_sql_query": {
            "raw": "",
            "normalized": ""
        },
        "db_id": "california_schools"
    },
    {
        "question": "For the school with the highest average score in Reading in the SAT test, what is its FRPM count for students aged 5-17?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"FRPM Count (Ages 5-17)\"FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\" ORDER BY T1.\"AvgScrRead\" DESC LIMIT 1",
            "normalized": "SELECT T2.\"FRPM Count (Ages 5-17)\"\nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nORDER BY T1.\"AvgScrRead\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "WITH highest_avg_read_school AS (\n    SELECT cds, MAX(AvgScrRead) as MaxAvgScrRead\n    FROM public.satscores\n    GROUP BY cds\n    ORDER BY MaxAvgScrRead DESC\n    LIMIT 1\n)\nSELECT f.\"FRPM Count (Ages 5-17)\"\nFROM public.frpm f\nJOIN highest_avg_read_school h ON f.\"CDSCode\" = h.cds;",
            "normalized": "WITH highest_avg_read_school AS\n  (SELECT cds,\n          MAX(AvgScrRead) AS MaxAvgScrRead\n   FROM public.satscores\n   GROUP BY cds\n   ORDER BY MaxAvgScrRead DESC\n   LIMIT 1)\nSELECT f.\"FRPM Count (Ages 5-17)\"\nFROM public.frpm f\nJOIN highest_avg_read_school h ON f.\"CDSCode\" = h.cds;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"CDSCode\" FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T2.\"Enrollment (K-12)\"+ T2.\"Enrollment (Ages 5-17)\"> 500",
            "normalized": "SELECT T2.\"CDSCode\"\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T2.\"Enrollment (K-12)\"+ T2.\"Enrollment (Ages 5-17)\"> 500"
        },
        "generated_sql_query": {
            "raw": "SELECT \"CDSCode\" \nFROM public.frpm \nWHERE \"Enrollment (K-12)\" > 500;",
            "normalized": "SELECT \"CDSCode\"\nFROM public.frpm\nWHERE \"Enrollment (K-12)\" > 500;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "reference_sql_query": {
            "raw": "SELECT MAX(CAST(T1.\"Free Meal Count (Ages 5-17)\"AS REAL) / T1.\"Enrollment (Ages 5-17)\") FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\" WHERE CAST(T2.\"NumGE1500\" AS DOUBLE PRECISION) / T2.\"NumTstTakr\" > 0.3",
            "normalized": "SELECT MAX(CAST(T1.\"Free Meal Count (Ages 5-17)\"AS REAL) / T1.\"Enrollment (Ages 5-17)\")\nFROM frpm AS T1\nINNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\"\nWHERE CAST(T2.\"NumGE1500\" AS DOUBLE PRECISION) / T2.\"NumTstTakr\" > 0.3"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(f.\"Percent (%) Eligible Free (Ages 5-17)\") AS highest_eligible_free_rate\nFROM public.satscores s\nJOIN public.frpm f ON s.cds = f.\"CDSCode\"\nWHERE (s.\"NumGE1500\"::FLOAT / s.\"NumTstTakr\") > 0.3;",
            "normalized": "SELECT MAX(f.\"Percent (%) Eligible Free (Ages 5-17)\") AS highest_eligible_free_rate\nFROM public.satscores s\nJOIN public.frpm f ON s.cds = f.\"CDSCode\"\nWHERE (s.\"NumGE1500\"::FLOAT / s.\"NumTstTakr\") > 0.3;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"NCESSchool\" FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" ORDER BY T2.\"Enrollment (Ages 5-17)\"DESC LIMIT 5",
            "normalized": "SELECT T1.\"NCESSchool\"\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nORDER BY T2.\"Enrollment (Ages 5-17)\"DESC\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "SELECT \"NCESSchool\", \"Enrollment (Ages 5-17)\"\nFROM public.frpm\nORDER BY \"Enrollment (Ages 5-17)\" DESC\nLIMIT 5;",
            "normalized": "SELECT \"NCESSchool\",\n       \"Enrollment (Ages 5-17)\"\nFROM public.frpm\nORDER BY \"Enrollment (Ages 5-17)\" DESC\nLIMIT 5;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Which active district has the highest average score in Reading?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"District\" FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\" WHERE T1.\"StatusType\" = 'Active' ORDER BY T2.\"AvgScrRead\" DESC LIMIT 1",
            "normalized": "SELECT T1.\"District\"\nFROM schools AS T1\nINNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\"\nWHERE T1.\"StatusType\" = 'Active'\nORDER BY T2.\"AvgScrRead\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about which districts are considered \"active.\" Additionally, there is no direct link between district activity status and the SAT scores in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about which districts ARE considered \"active.\" Additionally,\n                                                                                                                                              there IS NO direct LINK BETWEEN district activity status AND the SAT scores IN the given tables."
        },
        "db_id": "california_schools"
    },
    {
        "question": "How many schools in merged Alameda have number of test takers less than 100?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"CDSCode\") FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\" WHERE T1.\"StatusType\" = 'Merged' AND T2.\"NumTstTakr\" < 100 AND T1.\"County\"= 'Lake'",
            "normalized": "SELECT COUNT(T1.\"CDSCode\")\nFROM schools AS T1\nINNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\"\nWHERE T1.\"StatusType\" = 'Merged'\n  AND T2.\"NumTstTakr\" < 100\n  AND T1.\"County\"= 'Lake'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM public.satscores\nWHERE \"dname\" = 'Alameda' AND \"NumTstTakr\" < 100;",
            "normalized": "SELECT COUNT(*)\nFROM public.satscores\nWHERE \"dname\" = 'Alameda'\n  AND \"NumTstTakr\" < 100;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.",
        "reference_sql_query": {
            "raw": "SELECT \"CharterNum\", \"AvgScrWrite\", RANK() OVER (ORDER BY \"AvgScrWrite\" DESC) AS WritingScoreRank FROM schools AS T1  INNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\" WHERE T2.\"AvgScrWrite\" > 499 AND \"CharterNum\" is not null",
            "normalized": "SELECT \"CharterNum\",\n       \"AvgScrWrite\",\n       RANK() OVER (\n                    ORDER BY \"AvgScrWrite\" DESC) AS WritingScoreRank\nFROM schools AS T1\nINNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\"\nWHERE T2.\"AvgScrWrite\" > 499\n  AND \"CharterNum\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT s.\"School\", s.\"CharterNum\", sat.\"AvgScrWrite\"\nFROM public.schools s\nJOIN public.satscores sat ON s.\"CDSCode\" = sat.\"cds\"\nWHERE sat.\"AvgScrWrite\" > 499\nORDER BY sat.\"AvgScrWrite\" DESC;",
            "normalized": "SELECT s.\"School\",\n       s.\"CharterNum\",\n       sat.\"AvgScrWrite\"\nFROM public.schools s\nJOIN public.satscores sat ON s.\"CDSCode\" = sat.\"cds\"\nWHERE sat.\"AvgScrWrite\" > 499\nORDER BY sat.\"AvgScrWrite\" DESC;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"CDSCode\") FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\" WHERE T1.\"Charter Funding Type\"= 'Directly funded' AND T1.\"County Name\"= 'Fresno' AND T2.\"NumTstTakr\" <= 250",
            "normalized": "SELECT COUNT(T1.\"CDSCode\")\nFROM frpm AS T1\nINNER JOIN satscores AS T2 ON T1.\"CDSCode\" = T2.\"cds\"\nWHERE T1.\"Charter Funding Type\"= 'Directly funded'\n  AND T1.\"County Name\"= 'Fresno'\n  AND T2.\"NumTstTakr\" <= 250"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM public.satscores AS s\nJOIN public.schools AS sch ON s.cds = sch.\"CDSCode\"\nWHERE sch.County = 'Fresno' AND sch.FundingType = 'Directly Funded' AND s.\"NumTstTakr\" <= 250;",
            "normalized": "SELECT COUNT(*)\nFROM public.satscores AS s\nJOIN public.schools AS sch ON s.cds = sch.\"CDSCode\"\nWHERE sch.County = 'Fresno'\n  AND sch.FundingType = 'Directly Funded'\n  AND s.\"NumTstTakr\" <= 250;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"School Name\") FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T2.\"County\"= 'Amador' AND T1.\"Low Grade\"= '9' AND T1.\"High Grade\"= '12'",
            "normalized": "SELECT COUNT(T1.\"School Name\")\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T2.\"County\"= 'Amador'\n  AND T1.\"Low Grade\"= '9'\n  AND T1.\"High Grade\"= '12'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.frpm \nWHERE \"County Name\" = 'Amador' \nAND \"Low Grade\" = '9' \nAND \"High Grade\" = '12';",
            "normalized": "SELECT COUNT(*)\nFROM public.frpm\nWHERE \"County Name\" = 'Amador'\n  AND \"Low Grade\" = '9'\n  AND \"High Grade\" = '12';"
        },
        "db_id": "california_schools"
    },
    {
        "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"CDSCode\") FROM frpm WHERE\"County Name\"= 'Los Angeles' AND\"Free Meal Count (K-12)\"> 500 AND\"FRPM Count (K-12)\"< 700",
            "normalized": "SELECT COUNT(\"CDSCode\")\nFROM frpm\nWHERE\"County Name\"= 'Los Angeles'\n  AND\"Free Meal Count (K-12)\"> 500\n  AND\"FRPM Count (K-12)\"< 700"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM public.frpm\nWHERE \"County Name\" = 'Los Angeles'\n  AND \"Free Meal Count (K-12)\" > 500\n  AND \"FRPM Count (K-12)\" < 700;",
            "normalized": "SELECT COUNT(*)\nFROM public.frpm\nWHERE \"County Name\" = 'Los Angeles'\n  AND \"Free Meal Count (K-12)\" > 500\n  AND \"FRPM Count (K-12)\" < 700;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "reference_sql_query": {
            "raw": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY \"NumTstTakr\" DESC LIMIT 1",
            "normalized": "SELECT sname\nFROM satscores\nWHERE cname = 'Contra Costa'\n  AND sname IS NOT NULL\nORDER BY \"NumTstTakr\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.School, ss.NumTstTakr\nFROM public.schools s\nJOIN public.satscores ss ON s.CDSCode = ss.cds\nWHERE s.County = 'Contra Costa'\nORDER BY ss.NumTstTakr DESC\nLIMIT 1;",
            "normalized": "SELECT s.School,\n       ss.NumTstTakr\nFROM public.schools s\nJOIN public.satscores ss ON s.CDSCode = ss.cds\nWHERE s.County = 'Contra Costa'\nORDER BY ss.NumTstTakr DESC\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"School\", T1.\"Street\" FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T2.\"Enrollment (K-12)\"- T2.\"Enrollment (Ages 5-17)\"> 30",
            "normalized": "SELECT T1.\"School\",\n       T1.\"Street\"\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T2.\"Enrollment (K-12)\"- T2.\"Enrollment (Ages 5-17)\"> 30"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    s.\"School\" AS school_name,\n    s.\"Street\" AS street_address,\n    s.\"City\" AS city,\n    s.\"Zip\" AS zip\nFROM \n    public.schools s\nJOIN \n    public.frpm f ON s.\"CDSCode\" = f.\"CDSCode\"\nWHERE \n    ABS(f.\"Enrollment (K-12)\" - f.\"Enrollment (Ages 5-17)\") > 30;",
            "normalized": "SELECT s.\"School\" AS school_name,\n       s.\"Street\" AS street_address,\n       s.\"City\" AS city,\n       s.\"Zip\" AS zip\nFROM public.schools s\nJOIN public.frpm f ON s.\"CDSCode\" = f.\"CDSCode\"\nWHERE ABS(f.\"Enrollment (K-12)\" - f.\"Enrollment (Ages 5-17)\") > 30;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"School Name\"FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE CAST(T2.\"Free Meal Count (K-12)\"AS REAL) / T2.\"Enrollment (K-12)\"> 0.1 AND T1.\"NumGE1500\" > 0",
            "normalized": "SELECT T2.\"School Name\"\nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE CAST(T2.\"Free Meal Count (K-12)\"AS REAL) / T2.\"Enrollment (K-12)\"> 0.1\n  AND T1.\"NumGE1500\" > 0"
        },
        "generated_sql_query": {
            "raw": "SELECT s.School\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.\"CDSCode\"\nJOIN satscores ss ON s.CDSCode = ss.cds\nWHERE f.\"Percent (%) Eligible Free (K-12)\" > 0.1\nAND ss.\"NumGE1500\" > 0;",
            "normalized": "SELECT s.School\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.\"CDSCode\"\nJOIN satscores ss ON s.CDSCode = ss.cds\nWHERE f.\"Percent (%) Eligible Free (K-12)\" > 0.1\n  AND ss.\"NumGE1500\" > 0;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "reference_sql_query": {
            "raw": "SELECT T1.sname, T2.\"Charter Funding Type\"FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T2.\"District Name\"LIKE 'Riverside%' GROUP BY T1.sname, T2.\"Charter Funding Type\"HAVING CAST(SUM(T1.\"AvgScrMath\") AS DOUBLE PRECISION) / COUNT(T1.\"cds\") > 400",
            "normalized": "SELECT T1.sname,\n       T2.\"Charter Funding Type\"\nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE T2.\"District Name\"LIKE 'Riverside%'\nGROUP BY T1.sname,\n         T2.\"Charter Funding Type\"\nHAVING CAST(SUM(T1.\"AvgScrMath\") AS DOUBLE PRECISION) / COUNT(T1.\"cds\") > 400"
        },
        "generated_sql_query": {
            "raw": "SELECT s.School, s.FundingType\nFROM public.schools s\nJOIN public.satscores sat ON s.CDSCode = sat.cds\nWHERE s.County = 'Riverside' \nGROUP BY s.School, s.FundingType\nHAVING AVG(sat.\"AvgScrMath\") > 400;",
            "normalized": "SELECT s.School,\n       s.FundingType\nFROM public.schools s\nJOIN public.satscores sat ON s.CDSCode = sat.cds\nWHERE s.County = 'Riverside'\nGROUP BY s.School,\n         s.FundingType\nHAVING AVG(sat.\"AvgScrMath\") > 400;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"School Name\", T2.\"Street\", T2.\"City\", T2.\"State\", T2.\"Zip\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T2.\"County\"= 'Monterey' AND T1.\"Free Meal Count (Ages 5-17)\"> 800 AND T1.\"School Type\"= 'High Schools (Public)'",
            "normalized": "SELECT T1.\"School Name\",\n       T2.\"Street\",\n       T2.\"City\",\n       T2.\"State\",\n       T2.\"Zip\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T2.\"County\"= 'Monterey'\n  AND T1.\"Free Meal Count (Ages 5-17)\"> 800\n  AND T1.\"School Type\"= 'High Schools (Public)'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because it does not include details on how to identify high schools within the given tables, nor does it directly relate schools to their communication addresses. Additionally, it does not specify how to filter by ages 15-17 in relation to free or reduced price meals. The necessary tables and relationships to derive the required information are not fully provided.",
            "normalized": "The provided context IS insufficient because it does NOT INCLUDE details ON how TO identify high schools within the given TABLES,\n                                                                                                                          nor does it directly relate schools TO their communication addresses. Additionally,\n                                                                                                                                                                                     it does NOT specify how TO filter BY ages 15-17 IN relation TO FREE\nOR reduced price meals. The necessary TABLES\nAND relationships TO derive the required information ARE NOT fully provided."
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"School\", T1.\"AvgScrWrite\", T2.\"Phone\" FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.\"CDSCode\" = T1.\"cds\" WHERE EXTRACT(YEAR FROM T2.\"OpenDate\") > '1991' OR EXTRACT(YEAR FROM T2.\"ClosedDate\") < '2000'",
            "normalized": "SELECT T2.\"School\",\n       T1.\"AvgScrWrite\",\n       T2.\"Phone\"\nFROM schools AS T2\nLEFT JOIN satscores AS T1 ON T2.\"CDSCode\" = T1.\"cds\"\nWHERE EXTRACT(YEAR\n              FROM T2.\"OpenDate\") > '1991'\n  OR EXTRACT(YEAR\n             FROM T2.\"ClosedDate\") < '2000'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    sch.School AS school_name, \n    sat.AvgScrWrite AS average_score_writing, \n    sch.Phone AS communication_number\nFROM \n    public.schools sch\nJOIN \n    public.satscores sat ON sch.CDSCode = sat.cds\nWHERE \n    (sch.OpenDate > '1991-12-31' OR sch.ClosedDate < '2000-01-01')",
            "normalized": "SELECT sch.School AS school_name,\n       sat.AvgScrWrite AS average_score_writing,\n       sch.Phone AS communication_number\nFROM public.schools sch\nJOIN public.satscores sat ON sch.CDSCode = sat.cds\nWHERE (sch.OpenDate > '1991-12-31'\n       OR sch.ClosedDate < '2000-01-01')"
        },
        "db_id": "california_schools"
    },
    {
        "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"OpenDate\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" ORDER BY T1.\"Enrollment (K-12)\"DESC LIMIT 1",
            "normalized": "SELECT T2.\"OpenDate\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nORDER BY T1.\"Enrollment (K-12)\"DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.\"OpenDate\"\nFROM public.schools s\nJOIN public.frpm f ON s.\"CDSCode\" = f.\"CDSCode\"\nWHERE f.\"Low Grade\" = '1' AND f.\"High Grade\" = '12'\nORDER BY f.\"Enrollment (K-12)\" DESC\nLIMIT 1;",
            "normalized": "SELECT s.\"OpenDate\"\nFROM public.schools s\nJOIN public.frpm f ON s.\"CDSCode\" = f.\"CDSCode\"\nWHERE f.\"Low Grade\" = '1'\n  AND f.\"High Grade\" = '12'\nORDER BY f.\"Enrollment (K-12)\" DESC\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"City\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" GROUP BY T2.\"City\" ORDER BY SUM(T1.\"Enrollment (K-12)\") ASC LIMIT 5",
            "normalized": "SELECT T2.\"City\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nGROUP BY T2.\"City\"\nORDER BY SUM(T1.\"Enrollment (K-12)\") ASC\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about enrollment numbers for students in grades 1 through 12 at the city level in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about enrollment numbers\nFOR students IN grades 1 through 12 AT the city LEVEL IN the given tables."
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "reference_sql_query": {
            "raw": "SELECT CAST(\"Free Meal Count (K-12)\"AS REAL) /\"Enrollment (K-12)\"FROM frpm ORDER BY\"Enrollment (K-12)\"DESC LIMIT 2 OFFSET 9",
            "normalized": "SELECT CAST(\"Free Meal Count (K-12)\"AS REAL) /\"Enrollment (K-12)\"\nFROM frpm\nORDER BY\"Enrollment (K-12)\"DESC\nLIMIT 2\nOFFSET 9"
        },
        "generated_sql_query": {
            "raw": "SELECT \"School Name\", \"Enrollment (K-12)\", \"Percent (%) Eligible Free (K-12)\"\nFROM public.frpm\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 2 OFFSET 9",
            "normalized": "SELECT \"School Name\",\n       \"Enrollment (K-12)\",\n       \"Percent (%) Eligible Free (K-12)\"\nFROM public.frpm\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 2\nOFFSET 9"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "reference_sql_query": {
            "raw": "SELECT CAST(T1.\"FRPM Count (K-12)\"AS REAL) / T1.\"Enrollment (K-12)\"FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T2.\"SOC\" = '66' ORDER BY T1.\"FRPM Count (K-12)\"DESC LIMIT 5",
            "normalized": "SELECT CAST(T1.\"FRPM Count (K-12)\"AS REAL) / T1.\"Enrollment (K-12)\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T2.\"SOC\" = '66'\nORDER BY T1.\"FRPM Count (K-12)\"DESC\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no information about an \"ownership code\" in the available tables. Therefore, the query cannot be generated.",
            "normalized": "The provided context IS insufficient because there IS NO information about an \"ownership code\" IN the available tables. Therefore,\n                                                                                                                the query cannot be generated."
        },
        "db_id": "california_schools"
    },
    {
        "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Website\", T1.\"School Name\"FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T1.\"Free Meal Count (Ages 5-17)\"BETWEEN 1900 AND 2000 AND T2.\"Website\" IS NOT NULL",
            "normalized": "SELECT T2.\"Website\",\n       T1.\"School Name\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T1.\"Free Meal Count (Ages 5-17)\"BETWEEN 1900 AND 2000\n  AND T2.\"Website\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT s.School, s.Website\nFROM public.frpm f\nJOIN public.schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000;",
            "normalized": "SELECT s.School,\n       s.Website\nFROM public.frpm f\nJOIN public.schools s ON f.CDSCode = s.CDSCode\nWHERE f.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "reference_sql_query": {
            "raw": "SELECT CAST(T2.\"Free Meal Count (Ages 5-17)\"AS REAL) / T2.\"Enrollment (Ages 5-17)\"FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T1.\"AdmFName1\" = 'Kacey' AND T1.\"AdmLName1\" = 'Gibson'",
            "normalized": "SELECT CAST(T2.\"Free Meal Count (Ages 5-17)\"AS REAL) / T2.\"Enrollment (Ages 5-17)\"\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T1.\"AdmFName1\" = 'Kacey'\n  AND T1.\"AdmLName1\" = 'Gibson'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about a school run by Kacey Gibson or any direct link between school administrators and the free rate for students. Therefore, it is not possible to generate the SQL query needed to answer the question based on the given context.",
            "normalized": "The provided context does NOT contain information about a school run BY Kacey Gibson\nOR ANY direct LINK BETWEEN school administrators AND the FREE rate\nFOR students. Therefore,\n    it IS NOT possible TO generate the SQL query needed TO answer the question based ON the given context."
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"AdmEmail1\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T1.\"Charter School (Y/N)\"= 1 ORDER BY T1.\"Enrollment (K-12)\"ASC LIMIT 1",
            "normalized": "SELECT T2.\"AdmEmail1\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T1.\"Charter School (Y/N)\"= 1\nORDER BY T1.\"Enrollment (K-12)\"ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.\"AdmEmail1\"\nFROM public.schools s\nJOIN public.frpm f ON s.\"CDSCode\" = f.\"CDSCode\"\nWHERE s.\"Charter\" = 1\nORDER BY f.\"Enrollment (K-12)\" ASC\nLIMIT 1;",
            "normalized": "SELECT s.\"AdmEmail1\"\nFROM public.schools s\nJOIN public.frpm f ON s.\"CDSCode\" = f.\"CDSCode\"\nWHERE s.\"Charter\" = 1\nORDER BY f.\"Enrollment (K-12)\" ASC\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"AdmFName1\", T2.\"AdmLName1\", T2.\"AdmFName2\", T2.\"AdmLName2\", T2.\"AdmFName3\", T2.\"AdmLName3\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" ORDER BY T1.\"NumGE1500\" DESC LIMIT 1",
            "normalized": "SELECT T2.\"AdmFName1\",\n       T2.\"AdmLName1\",\n       T2.\"AdmFName2\",\n       T2.\"AdmLName2\",\n       T2.\"AdmFName3\",\n       T2.\"AdmLName3\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nORDER BY T1.\"NumGE1500\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.\"AdmFName1\", s.\"AdmLName1\"\nFROM public.satscores ss\nJOIN public.schools s ON ss.cds = s.\"CDSCode\"\nWHERE ss.\"NumGE1500\" = (\n    SELECT MAX(\"NumGE1500\") FROM public.satscores\n)",
            "normalized": "SELECT s.\"AdmFName1\",\n       s.\"AdmLName1\"\nFROM public.satscores ss\nJOIN public.schools s ON ss.cds = s.\"CDSCode\"\nWHERE ss.\"NumGE1500\" =\n    (SELECT MAX(\"NumGE1500\")\n     FROM public.satscores)"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Street\", T2.\"City\", T2.\"State\", T2.\"Zip\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" ORDER BY CAST(T1.\"NumGE1500\" AS DOUBLE PRECISION) / T1.\"NumTstTakr\" ASC LIMIT 1",
            "normalized": "SELECT T2.\"Street\",\n       T2.\"City\",\n       T2.\"State\",\n       T2.\"Zip\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nORDER BY CAST(T1.\"NumGE1500\" AS DOUBLE PRECISION) / T1.\"NumTstTakr\" ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no column explicitly named \"excellence rate\" or similar in the available tables. Therefore, I cannot generate the required SQL query to find the school with the lowest excellence rate and its complete address.",
            "normalized": "The provided context IS insufficient because there IS NO COLUMN explicitly named \"excellence rate\"\nOR SIMILAR IN the available tables. Therefore,\n                            I cannot generate the required SQL query TO find the school WITH the lowest excellence rate\nAND its complete address."
        },
        "db_id": "california_schools"
    },
    {
        "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Website\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T1.\"NumTstTakr\" BETWEEN 2000 AND 3000 AND T2.\"County\"= 'Los Angeles'",
            "normalized": "SELECT T2.\"Website\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE T1.\"NumTstTakr\" BETWEEN 2000 AND 3000\n  AND T2.\"County\"= 'Los Angeles'"
        },
        "generated_sql_query": {
            "raw": "SELECT s.Website\nFROM public.satscores ss\nJOIN public.schools s ON ss.cds = s.CDSCode\nWHERE ss.dname = 'Los Angeles'\nAND ss.\"NumTstTakr\" BETWEEN 2000 AND 3000;",
            "normalized": "SELECT s.Website\nFROM public.satscores ss\nJOIN public.schools s ON ss.cds = s.CDSCode\nWHERE ss.dname = 'Los Angeles'\n  AND ss.\"NumTstTakr\" BETWEEN 2000 AND 3000;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T1.\"NumTstTakr\") FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE EXTRACT(YEAR FROM T2.\"OpenDate\") = '1980' AND T2.\"County\"= 'Fresno'",
            "normalized": "SELECT AVG(T1.\"NumTstTakr\")\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE EXTRACT(YEAR\n              FROM T2.\"OpenDate\") = '1980'\n  AND T2.\"County\"= 'Fresno'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM public.satscores s\nJOIN public.schools sch ON s.cds = sch.CDSCode\nWHERE sch.County = 'Fresno'\nAND sch.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';",
            "normalized": "SELECT AVG(s.NumTstTakr) AS average_test_takers\nFROM public.satscores s\nJOIN public.schools sch ON s.cds = sch.CDSCode\nWHERE sch.County = 'Fresno'\n  AND sch.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';"
        },
        "db_id": "california_schools"
    },
    {
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "reference_sql_query": {
            "raw": "SELECT \"School\" FROM (SELECT T2.\"School\",T1.\"AvgScrRead\", RANK() OVER (PARTITION BY T2.\"County\" ORDER BY T1.\"AvgScrRead\" DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T2.\"Virtual\" = 'F' ) ranked_schools WHERE rnk <= 5",
            "normalized": "SELECT \"School\"\nFROM\n  (SELECT T2.\"School\",\n          T1.\"AvgScrRead\",\n          RANK() OVER (PARTITION BY T2.\"County\"\n                       ORDER BY T1.\"AvgScrRead\" DESC) AS rnk\n   FROM satscores AS T1\n   INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\n   WHERE T2.\"Virtual\" = 'F') ranked_schools\nWHERE rnk <= 5"
        },
        "generated_sql_query": {
            "raw": "SELECT s.School\nFROM public.satscores sa\nJOIN public.schools s ON sa.cds = s.CDSCode\nWHERE s.Virtual = 'Yes'\nAND sa.rtype = 'School'\nORDER BY sa.AvgScrRead DESC\nLIMIT 5;",
            "normalized": "SELECT s.School\nFROM public.satscores sa\nJOIN public.schools s ON sa.cds = s.CDSCode\nWHERE s.Virtual = 'Yes'\n  AND sa.rtype = 'School'\nORDER BY sa.AvgScrRead DESC\nLIMIT 5;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the type of education offered in the school who scored the highest average in Math?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"EdOpsName\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" ORDER BY T1.\"AvgScrMath\" DESC LIMIT 1",
            "normalized": "SELECT T2.\"EdOpsName\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nORDER BY T1.\"AvgScrMath\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.\"Educational Option Type\"\nFROM public.satscores sat\nJOIN public.frpm f ON sat.cds = f.\"CDSCode\"\nORDER BY sat.\"AvgScrMath\" DESC\nLIMIT 1;",
            "normalized": "SELECT s.\"Educational Option Type\"\nFROM public.satscores sat\nJOIN public.frpm f ON sat.cds = f.\"CDSCode\"\nORDER BY sat.\"AvgScrMath\" DESC\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"AvgScrMath\", T2.\"County\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T1.\"AvgScrMath\" IS NOT NULL ORDER BY T1.\"AvgScrMath\" + T1.\"AvgScrRead\" + T1.\"AvgScrWrite\" ASC LIMIT 1",
            "normalized": "SELECT T1.\"AvgScrMath\",\n       T2.\"County\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE T1.\"AvgScrMath\" IS NOT NULL\nORDER BY T1.\"AvgScrMath\" + T1.\"AvgScrRead\" + T1.\"AvgScrWrite\" ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.cname AS county, s.sname AS school_name, s.\"AvgScrMath\" AS average_math_score\nFROM public.satscores s\nWHERE (s.\"AvgScrRead\" + s.\"AvgScrMath\" + s.\"AvgScrWrite\") = (\n    SELECT MIN(\"AvgScrRead\" + \"AvgScrMath\" + \"AvgScrWrite\")\n    FROM public.satscores\n)\nLIMIT 1;",
            "normalized": "SELECT s.cname AS county,\n       s.sname AS school_name,\n       s.\"AvgScrMath\" AS average_math_score\nFROM public.satscores s\nWHERE (s.\"AvgScrRead\" + s.\"AvgScrMath\" + s.\"AvgScrWrite\") =\n    (SELECT MIN(\"AvgScrRead\" + \"AvgScrMath\" + \"AvgScrWrite\")\n     FROM public.satscores)\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the average writing score of the school who has the highest number of test takers whose total SAT sscores are greater or equal to 1500? Indicate the city to where the school is situated.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"AvgScrWrite\", T2.\"City\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" ORDER BY T1.\"NumGE1500\" DESC LIMIT 1",
            "normalized": "SELECT T1.\"AvgScrWrite\",\n       T2.\"City\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nORDER BY T1.\"NumGE1500\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.City, AVG(sat.AvgScrWrite) AS AverageWritingScore\nFROM public.satscores sat\nJOIN public.schools s ON sat.cds = s.CDSCode\nWHERE sat.NumTstTakr = (\n    SELECT MAX(NumTstTakr)\n    FROM public.satscores\n    WHERE NumGE1500 >= 1500\n)\nGROUP BY s.City;",
            "normalized": "SELECT s.City,\n       AVG(sat.AvgScrWrite) AS AverageWritingScore\nFROM public.satscores sat\nJOIN public.schools s ON sat.cds = s.CDSCode\nWHERE sat.NumTstTakr =\n    (SELECT MAX(NumTstTakr)\n     FROM public.satscores\n     WHERE NumGE1500 >= 1500)\nGROUP BY s.City;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"School\", T1.\"AvgScrWrite\" FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\" WHERE T2.\"AdmFName1\" = 'Ricci' AND T2.\"AdmLName1\" = 'Ulrich'",
            "normalized": "SELECT T2.\"School\",\n       T1.\"AvgScrWrite\"\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.\"cds\" = T2.\"CDSCode\"\nWHERE T2.\"AdmFName1\" = 'Ricci'\n  AND T2.\"AdmLName1\" = 'Ulrich'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about the management of schools, specifically by someone named Ricci Ulrich. Therefore, it is not possible to generate the SQL query to answer the question based on the given data.",
            "normalized": "The provided context does NOT contain information about the management OF schools,\n                                                                          specifically BY someone named Ricci Ulrich. Therefore,\n                                                                                                        it IS NOT possible TO generate the SQL query TO answer the question based ON the given data."
        },
        "db_id": "california_schools"
    },
    {
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"School\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\" WHERE T2.\"DOC\" = '31' ORDER BY T1.\"Enrollment (K-12)\"DESC LIMIT 1",
            "normalized": "SELECT T2.\"School\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.\"CDSCode\" = T2.\"CDSCode\"\nWHERE T2.\"DOC\" = '31'\nORDER BY T1.\"Enrollment (K-12)\"DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT School, \"Enrollment (K-12)\"\nFROM public.frpm\nWHERE \"School Type\" = 'State Special Schools'\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 1;",
            "normalized": "SELECT School,\n       \"Enrollment (K-12)\"\nFROM public.frpm\nWHERE \"School Type\" = 'State Special Schools'\nORDER BY \"Enrollment (K-12)\" DESC\nLIMIT 1;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(\"School\") AS DOUBLE PRECISION) / 12 FROM schools WHERE \"DOC\" = '52' AND \"County\"= 'Alameda' AND EXTRACT(YEAR FROM \"OpenDate\") = '1980'",
            "normalized": "SELECT CAST(COUNT(\"School\") AS DOUBLE PRECISION) / 12\nFROM schools\nWHERE \"DOC\" = '52'\n  AND \"County\"= 'Alameda'\n  AND EXTRACT(YEAR\n              FROM \"OpenDate\") = '1980'"
        },
        "generated_sql_query": {
            "raw": "SELECT EXTRACT(MONTH FROM \"OpenDate\") AS month, \n       COUNT(*) / 12.0 AS average_number_of_schools\nFROM public.schools\nWHERE \"County\" = 'Alameda'\n  AND \"District\" = 'Elementary School District'\n  AND EXTRACT(YEAR FROM \"OpenDate\") = 1980\nGROUP BY EXTRACT(MONTH FROM \"OpenDate\");",
            "normalized": "SELECT EXTRACT(MONTH\n               FROM \"OpenDate\") AS MONTH,\n       COUNT(*) / 12.0 AS average_number_of_schools\nFROM public.schools\nWHERE \"County\" = 'Alameda'\n  AND \"District\" = 'Elementary School District'\n  AND EXTRACT(YEAR\n              FROM \"OpenDate\") = 1980\nGROUP BY EXTRACT(MONTH\n                 FROM \"OpenDate\");"
        },
        "db_id": "california_schools"
    },
    {
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"DOC\" = '54' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) / SUM(CASE WHEN \"DOC\" = '52' THEN 1 ELSE 0 END) FROM schools WHERE \"StatusType\" = 'Merged' AND \"County\"= 'Orange'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"DOC\" = '54' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) / SUM(CASE\n                                                    WHEN \"DOC\" = '52' THEN 1\n                                                    ELSE 0\n                                                END)\nFROM schools\nWHERE \"StatusType\" = 'Merged'\n  AND \"County\"= 'Orange'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SUM(CASE WHEN \"District Type\" = 'Unified School District' AND \"County Name\" = 'Orange' THEN 1 ELSE 0 END) * 1.0 /\n    NULLIF(SUM(CASE WHEN \"District Type\" = 'Elementary School District' AND \"County Name\" = 'Orange' THEN 1 ELSE 0 END), 0)) AS unified_to_elementary_ratio\nFROM public.frpm;",
            "normalized": "SELECT (SUM(CASE\n                WHEN \"District Type\" = 'Unified School District'\n                     AND \"County Name\" = 'Orange' THEN 1\n                ELSE 0\n            END) * 1.0 / NULLIF(SUM(CASE\n                                        WHEN \"District Type\" = 'Elementary School District'\n                                             AND \"County Name\" = 'Orange' THEN 1\n                                        ELSE 0\n                                    END), 0)) AS unified_to_elementary_ratio\nFROM public.frpm;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT \"County\", \"School\", \"ClosedDate\" FROM schools WHERE \"County\"= ( SELECT \"County\" FROM schools WHERE \"StatusType\" = 'Closed' GROUP BY \"County\" ORDER BY COUNT(\"School\") DESC LIMIT 1 ) AND \"StatusType\" = 'Closed' AND \"School\" IS NOT NULL",
            "normalized": "SELECT DISTINCT \"County\",\n                \"School\",\n                \"ClosedDate\"\nFROM schools\nWHERE \"County\"=\n    (SELECT \"County\"\n     FROM schools\n     WHERE \"StatusType\" = 'Closed'\n     GROUP BY \"County\"\n     ORDER BY COUNT(\"School\") DESC\n     LIMIT 1)\n  AND \"StatusType\" = 'Closed'\n  AND \"School\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT County, School, ClosedDate\nFROM public.schools\nWHERE ClosedDate IS NOT NULL\nORDER BY County, ClosedDate;",
            "normalized": "SELECT County,\n       School,\n       ClosedDate\nFROM public.schools\nWHERE ClosedDate IS NOT NULL\nORDER BY County,\n         ClosedDate;"
        },
        "db_id": "california_schools"
    },
    {
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.\"A3\" = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
            "normalized": "SELECT COUNT(T2.account_id)\nFROM district AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.district_id = T2.district_id\nWHERE T1.\"A3\" = 'east Bohemia'\n  AND T2.frequency = 'POPLATEK PO OBRATU'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT a.account_id)\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE a.frequency = 'issuance after transaction' AND d.A2 = 'East Bohemia'",
            "normalized": "SELECT COUNT(DISTINCT a.account_id)\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE a.frequency = 'issuance after transaction'\n  AND d.A2 = 'East Bohemia'"
        },
        "db_id": "financial"
    },
    {
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.\"A3\" = 'Prague'",
            "normalized": "SELECT COUNT(T1.account_id)\nFROM ACCOUNT AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nWHERE T3.\"A3\" = 'Prague'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated. The provided context does not include information on regions or their relation to Prague. The tables given do not have a column that specifies the region or location of the accounts.",
            "normalized": "It can't be generated. The provided context does NOT INCLUDE information ON regions\nOR their relation TO Prague. The TABLES given DO NOT have a COLUMN that specifies the region\nOR LOCATION OF the accounts."
        },
        "db_id": "financial"
    },
    {
        "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT CASE WHEN AVG(\"A13\") > AVG(\"A12\") THEN '1996' ELSE '1995' END FROM district",
            "normalized": "SELECT DISTINCT CASE\n                    WHEN AVG(\"A13\") > AVG(\"A12\") THEN '1996'\n                    ELSE '1995'\n                END\nFROM district"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate a SQL query for the question because there is no table containing unemployment data or related information for the years 1995 and 1996.",
            "normalized": "The provided context IS insufficient TO generate a SQL query\nFOR the question because there IS NO TABLE containing unemployment DATA\nOR related information\nFOR the years 1995\nAND 1996."
        },
        "db_id": "financial"
    },
    {
        "question": "List out the no. of districts that have female average salary is more than 6000 but less than 10000?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T2.district_id)  FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.\"A11\" BETWEEN 6000 AND 10000",
            "normalized": "SELECT COUNT(DISTINCT T2.district_id)\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\n  AND T2.\"A11\" BETWEEN 6000 AND 10000"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because the provided context does not include any table or column related to salaries or any specific information about gender-based salaries in districts.",
            "normalized": "It can't be GENERATED because the provided context does NOT INCLUDE ANY TABLE\nOR COLUMN related TO salaries\nOR ANY SPECIFIC information about gender-based salaries IN districts."
        },
        "db_id": "financial"
    },
    {
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.\"A3\" = 'north Bohemia' AND T2.\"A11\" > 8000",
            "normalized": "SELECT COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M'\n  AND T2.\"A3\" = 'north Bohemia'\n  AND T2.\"A11\" > 8000"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because the provided context does not include any information about the region \"North Bohemia\" or salary information for customers. The tables available do not have relevant columns to determine customer location specifically in North Bohemia or their salary details.",
            "normalized": "It can't be GENERATED because the provided context does NOT INCLUDE ANY information about the region \"North Bohemia\"\nOR salary information\nFOR customers. The TABLES available DO NOT have relevant columns TO determine customer LOCATION specifically IN North Bohemia\nOR their salary details."
        },
        "db_id": "financial"
    },
    {
        "question": "List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id , ( SELECT MAX(\"A11\") - MIN(\"A11\") FROM district ) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T2.district_id = ( SELECT district_id FROM client WHERE gender = 'F' ORDER BY birth_date ASC LIMIT 1 ) ORDER BY T2.\"A11\" DESC LIMIT 1",
            "normalized": "SELECT T1.account_id ,\n  (SELECT MAX(\"A11\") - MIN(\"A11\")\n   FROM district)\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T1.account_id = T3.account_id\nINNER JOIN client AS T4 ON T3.client_id = T4.client_id\nWHERE T2.district_id =\n    (SELECT district_id\n     FROM client\n     WHERE gender = 'F'\n     ORDER BY birth_date ASC\n     LIMIT 1)\nORDER BY T2.\"A11\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query. The available tables do not contain information about salaries or how to calculate an average salary. Additionally, the tables do not have a direct link between account numbers and client genders.",
            "normalized": "The provided context IS insufficient TO generate the SQL query. The available TABLES DO NOT contain information about salaries\nOR how TO calculate an average salary. Additionally,\n                       the TABLES DO NOT have a direct LINK BETWEEN ACCOUNT numbers AND client genders."
        },
        "db_id": "financial"
    },
    {
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.\"A11\", T1.account_id",
            "normalized": "SELECT T1.account_id\nFROM ACCOUNT AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nINNER JOIN client AS T3 ON T2.client_id = T3.client_id\nINNER JOIN district AS T4 ON T4.district_id = T1.district_id\nWHERE T2.client_id =\n    (SELECT client_id\n     FROM client\n     ORDER BY birth_date DESC\n     LIMIT 1)\nGROUP BY T4.\"A11\",\n         T1.account_id"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the salary of clients in any of the tables. The \"income\" table provides amounts received, but it is not linked to clients or accounts, nor is there an indication that it represents a salary.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the salary OF clients IN ANY OF the tables. The \"income\" TABLE provides amounts received,\n                                                                                                                                                                                     but it IS NOT linked TO clients\nOR accounts,\n   nor IS there an indication that it represents a salary."
        },
        "db_id": "financial"
    },
    {
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
            "normalized": "SELECT COUNT(T1.account_id)\nFROM ACCOUNT AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nWHERE T2.type = 'OWNER'\n  AND T1.frequency = 'POPLATEK TYDNE'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information or column in the given tables that directly relates to customers being \"Owner\" or choosing a \"statement of weekly issuance.\"",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information\nOR COLUMN IN the given TABLES that directly relates TO customers being \"Owner\"\nOR choosing a \"statement of weekly issuance.\""
        },
        "db_id": "financial"
    },
    {
        "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
        "reference_sql_query": {
            "raw": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
            "normalized": "SELECT T2.client_id\nFROM ACCOUNT AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nWHERE T1.frequency = 'POPLATEK PO OBRATU'\n  AND T2.type = 'DISPONENT'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.client_id\nFROM public.client c\nJOIN public.disp d ON c.client_id = d.client_id\nJOIN public.account a ON d.account_id = a.account_id\nWHERE d.type = 'DISPONENT' AND a.frequency = 'statement of issuance after transaction';",
            "normalized": "SELECT c.client_id\nFROM public.client c\nJOIN public.disp d ON c.client_id = d.client_id\nJOIN public.account a ON d.account_id = a.account_id\nWHERE d.type = 'DISPONENT'\n  AND a.frequency = 'statement of issuance after transaction';"
        },
        "db_id": "financial"
    },
    {
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "reference_sql_query": {
            "raw": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE EXTRACT(YEAR FROM T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
            "normalized": "SELECT T2.account_id\nFROM loan AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nWHERE EXTRACT(YEAR\n              FROM T1.date) = '1997'\n  AND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT a.account_id, l.amount, a.frequency\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nWHERE EXTRACT(YEAR FROM l.date) = 1997\nAND l.status = 'approved'\nAND a.frequency = 'weekly'\nORDER BY l.amount ASC\nLIMIT 1;",
            "normalized": "SELECT a.account_id,\n       l.amount,\n       a.frequency\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nWHERE EXTRACT(YEAR\n              FROM l.date) = 1997\n  AND l.status = 'approved'\n  AND a.frequency = 'weekly'\nORDER BY l.amount ASC\nLIMIT 1;"
        },
        "db_id": "financial"
    },
    {
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE EXTRACT(YEAR FROM T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
            "normalized": "SELECT T1.account_id\nFROM loan AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nWHERE EXTRACT(YEAR\n              FROM T2.date) = '1993'\n  AND T1.duration > 12\nORDER BY T1.amount DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT l.account_id, l.amount\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nWHERE l.duration > 12\nAND EXTRACT(YEAR FROM a.date) = 1993\nORDER BY l.amount DESC\nLIMIT 1;",
            "normalized": "SELECT l.account_id,\n       l.amount\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nWHERE l.duration > 12\n  AND EXTRACT(YEAR\n              FROM a.date) = 1993\nORDER BY l.amount DESC\nLIMIT 1;"
        },
        "db_id": "financial"
    },
    {
        "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND EXTRACT(YEAR FROM T2.birth_date) < '1950' AND T1.\"A2\" = 'Sokolov'",
            "normalized": "SELECT COUNT(T2.client_id)\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nWHERE T2.gender = 'F'\n  AND EXTRACT(YEAR\n              FROM T2.birth_date) < '1950'\n  AND T1.\"A2\" = 'Sokolov'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT c.client_id) AS female_customers_count\nFROM public.client c\nJOIN public.account a ON c.district_id = a.district_id\nWHERE c.gender = 'female'\nAND c.birth_date < '1950-01-01'\nAND c.district_id = (SELECT district_id FROM public.district WHERE name = 'Sokolov');",
            "normalized": "SELECT COUNT(DISTINCT c.client_id) AS female_customers_count\nFROM public.client c\nJOIN public.account a ON c.district_id = a.district_id\nWHERE c.gender = 'female'\n  AND c.birth_date < '1950-01-01'\n  AND c.district_id =\n    (SELECT district_id\n     FROM public.district\n     WHERE name = 'Sokolov');"
        },
        "db_id": "financial"
    },
    {
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "reference_sql_query": {
            "raw": "SELECT account_id FROM trans WHERE EXTRACT(YEAR FROM date) = '1995' ORDER BY date ASC LIMIT 1",
            "normalized": "SELECT account_id\nFROM trans\nWHERE EXTRACT(YEAR\n              FROM date) = '1995'\nORDER BY date ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT account_id, MIN(date) as earliest_date\nFROM public.account\nWHERE date >= '1995-01-01' AND date < '1996-01-01'\nGROUP BY account_id\nORDER BY earliest_date\nLIMIT 1;",
            "normalized": "SELECT account_id,\n       MIN(date) AS earliest_date\nFROM public.account\nWHERE date >= '1995-01-01'\n  AND date < '1996-01-01'\nGROUP BY account_id\nORDER BY earliest_date\nLIMIT 1;"
        },
        "db_id": "financial"
    },
    {
        "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE EXTRACT(YEAR FROM T2.date) < '1997' AND T1.amount > 3000",
            "normalized": "SELECT DISTINCT T2.account_id\nFROM trans AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nWHERE EXTRACT(YEAR\n              FROM T2.date) < '1997'\n  AND T1.amount > 3000"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT a.account_id\nFROM public.account a\nJOIN public.loan l ON a.account_id = l.account_id\nWHERE a.date < '1997-01-01' AND l.amount > 3000;",
            "normalized": "SELECT DISTINCT a.account_id\nFROM public.account a\nJOIN public.loan l ON a.account_id = l.account_id\nWHERE a.date < '1997-01-01'\n  AND l.amount > 3000;"
        },
        "db_id": "financial"
    },
    {
        "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
        "reference_sql_query": {
            "raw": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
            "normalized": "SELECT T2.client_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN card AS T3 ON T2.disp_id = T3.disp_id\nWHERE T3.issued = '1994-03-03'"
        },
        "generated_sql_query": {
            "raw": "SELECT client.client_id\nFROM client\nJOIN card ON client.client_id = card.disp_id\nWHERE card.issued = '1994-03-03';",
            "normalized": "SELECT client.client_id\nFROM client\nJOIN card ON client.client_id = card.disp_id\nWHERE card.issued = '1994-03-03';"
        },
        "db_id": "financial"
    },
    {
        "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
        "reference_sql_query": {
            "raw": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
            "normalized": "SELECT T1.date\nFROM ACCOUNT AS T1\nINNER JOIN trans AS T2 ON T1.account_id = T2.account_id\nWHERE T2.amount = 840\n  AND T2.date = '1998-10-14'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.date AS account_opened_date\nFROM public.transactions_1k t\nJOIN public.account a ON t.CustomerID = a.account_id\nWHERE t.Amount = 840 AND t.Date = '1998-10-14';",
            "normalized": "SELECT a.date AS account_opened_date\nFROM public.transactions_1k t\nJOIN public.account a ON t.CustomerID = a.account_id\nWHERE t.Amount = 840\n  AND t.Date = '1998-10-14';"
        },
        "db_id": "financial"
    },
    {
        "question": "There was a loan approved in 1994/8/25, where was that account opened, give the district Id of the branch.",
        "reference_sql_query": {
            "raw": "SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'",
            "normalized": "SELECT T1.district_id\nFROM ACCOUNT AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nWHERE T2.date = '1994-08-25'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.district_id\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE l.date = '1994-08-25' AND l.status = 'approved';",
            "normalized": "SELECT d.district_id\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE l.date = '1994-08-25'\n  AND l.status = 'approved';"
        },
        "db_id": "financial"
    },
    {
        "question": "What is the biggest amount of transaction that the client whose card was opened in 1996/10/21 made?",
        "reference_sql_query": {
            "raw": "SELECT T4.amount FROM card AS T1 JOIN disp AS T2 ON T1.disp_id = T2.disp_id JOIN account AS T3 on T2.account_id = T3.account_id JOIN trans AS T4 on T3.account_id = T4.account_id WHERE T1.issued = '1996-10-21' ORDER BY T4.amount DESC LIMIT 1",
            "normalized": "SELECT T4.amount\nFROM card AS T1\nJOIN disp AS T2 ON T1.disp_id = T2.disp_id\nJOIN ACCOUNT AS T3 ON T2.account_id = T3.account_id\nJOIN trans AS T4 ON T3.account_id = T4.account_id\nWHERE T1.issued = '1996-10-21'\nORDER BY T4.amount DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(t.Amount) AS max_transaction_amount\nFROM public.transactions_1k t\nJOIN public.card c ON t.CardID = c.card_id\nWHERE c.issued = '1996-10-21';",
            "normalized": "SELECT MAX(t.Amount) AS max_transaction_amount\nFROM public.transactions_1k t\nJOIN public.card c ON t.CardID = c.card_id\nWHERE c.issued = '1996-10-21';"
        },
        "db_id": "financial"
    },
    {
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "reference_sql_query": {
            "raw": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.\"A11\" DESC, T2.birth_date ASC LIMIT 1",
            "normalized": "SELECT T2.gender\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nORDER BY T1.\"A11\" DESC,\n         T2.birth_date ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the salary or income associated with a branch. The tables do not have columns that relate account districts to income amounts to determine which branch has the highest average salary.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the salary\nOR income associated WITH a branch. The TABLES DO NOT have columns that relate ACCOUNT districts TO income amounts TO determine which branch has the highest average salary."
        },
        "db_id": "financial"
    },
    {
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "reference_sql_query": {
            "raw": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
            "normalized": "SELECT T3.amount\nFROM loan AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nORDER BY T1.amount DESC,\n         T3.date ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT t1.\"Amount\"\nFROM public.transactions_1k t1\nJOIN public.loan l ON t1.\"CustomerID\" = l.account_id\nJOIN (\n    SELECT account_id, MIN(date) as account_open_date\n    FROM public.account\n    GROUP BY account_id\n) a ON l.account_id = a.account_id\nWHERE l.amount = (\n    SELECT MAX(amount)\n    FROM public.loan\n)\nAND t1.\"Date\" = (\n    SELECT MIN(t2.\"Date\")\n    FROM public.transactions_1k t2\n    WHERE t2.\"CustomerID\" = t1.\"CustomerID\" AND t2.\"Date\" >= a.account_open_date\n)\nLIMIT 1;",
            "normalized": "SELECT t1.\"Amount\"\nFROM public.transactions_1k t1\nJOIN public.loan l ON t1.\"CustomerID\" = l.account_id\nJOIN\n  (SELECT account_id,\n          MIN(date) AS account_open_date\n   FROM public.account\n   GROUP BY account_id) a ON l.account_id = a.account_id\nWHERE l.amount =\n    (SELECT MAX(amount)\n     FROM public.loan)\n  AND t1.\"Date\" =\n    (SELECT MIN(t2.\"Date\")\n     FROM public.transactions_1k t2\n     WHERE t2.\"CustomerID\" = t1.\"CustomerID\"\n       AND t2.\"Date\" >= a.account_open_date)\nLIMIT 1;"
        },
        "db_id": "financial"
    },
    {
        "question": "How many clients opened their accounts in Jesenik branch were women?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.\"A2\" = 'Jesenik'",
            "normalized": "SELECT COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\n  AND T2.\"A2\" = 'Jesenik'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated.",
            "normalized": "It can't be generated."
        },
        "db_id": "financial"
    },
    {
        "question": "What is the disposition id of the client who made 5100 USD transaction in 1998/9/2?",
        "reference_sql_query": {
            "raw": "SELECT T1.disp_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.date='1997-08-20' AND T3.amount = 5100",
            "normalized": "SELECT T1.disp_id\nFROM disp AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.date='1997-08-20'\n  AND T3.amount = 5100"
        },
        "generated_sql_query": {
            "raw": "SELECT d.disp_id\nFROM public.transactions_1k t\nJOIN public.card c ON t.CardID = c.card_id\nJOIN public.disp d ON c.disp_id = d.disp_id\nWHERE t.Amount = 5100 AND t.Date = '1998-09-02';",
            "normalized": "SELECT d.disp_id\nFROM public.transactions_1k t\nJOIN public.card c ON t.CardID = c.card_id\nJOIN public.disp d ON c.disp_id = d.disp_id\nWHERE t.Amount = 5100\n  AND t.Date = '1998-09-02';"
        },
        "db_id": "financial"
    },
    {
        "question": "How many accounts were opened in Litomerice in 1996?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE EXTRACT(YEAR FROM T2.date) = '1996' AND T1.\"A2\" = 'Litomerice'",
            "normalized": "SELECT COUNT(T2.account_id)\nFROM district AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.district_id = T2.district_id\nWHERE EXTRACT(YEAR\n              FROM T2.date) = '1996'\n  AND T1.\"A2\" = 'Litomerice'"
        },
        "generated_sql_query": {
            "raw": "Error running intermediate SQL: You need to connect to a database first by running vn.connect_to_snowflake(), vn.connect_to_postgres(), similar function, or manually set vn.run_sql",
            "normalized": "Error running intermediate SQL: You need TO CONNECT TO a DATABASE FIRST BY running vn.connect_to_snowflake(),\n                                                                           vn.connect_to_postgres(),\n                                                                           SIMILAR FUNCTION,\nOR manually\nSET vn.run_sql"
        },
        "db_id": "financial"
    },
    {
        "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"A2\" FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
            "normalized": "SELECT T1.\"A2\"\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nWHERE T2.birth_date = '1976-01-29'\n  AND T2.gender = 'F'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.*\nFROM public.client c\nJOIN public.account a ON c.district_id = a.district_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE c.gender = 'female' AND c.birth_date = '1976-01-29';",
            "normalized": "SELECT d.*\nFROM public.client c\nJOIN public.account a ON c.district_id = a.district_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE c.gender = 'female'\n  AND c.birth_date = '1976-01-29';"
        },
        "db_id": "financial"
    },
    {
        "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
        "reference_sql_query": {
            "raw": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
            "normalized": "SELECT T4.birth_date\nFROM loan AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nINNER JOIN disp AS T3 ON T2.account_id = T3.account_id\nINNER JOIN client AS T4 ON T3.client_id = T4.client_id\nWHERE T1.date = '1996-01-03'\n  AND T1.amount = 98832"
        },
        "generated_sql_query": {
            "raw": "SELECT c.birth_date\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.client c ON a.district_id = c.district_id\nWHERE l.amount = 98832 AND l.date = '1996-01-03';",
            "normalized": "SELECT c.birth_date\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.client c ON a.district_id = c.district_id\nWHERE l.amount = 98832\n  AND l.date = '1996-01-03';"
        },
        "db_id": "financial"
    },
    {
        "question": "For the first client who opened his/her account in Prague, what is his/her account ID?",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.\"A3\" = 'Prague' ORDER BY T1.date ASC LIMIT 1",
            "normalized": "SELECT T1.account_id\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.\"A3\" = 'Prague'\nORDER BY T1.date ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT a.account_id\nFROM public.account a\nJOIN public.client c ON a.district_id = c.district_id\nWHERE c.district_id = (\n    SELECT district_id\n    FROM public.client\n    WHERE district_id IN (\n        SELECT district_id\n        FROM public.client\n        WHERE district_id = (SELECT district_id FROM public.client WHERE district_id = (SELECT MIN(district_id) FROM public.client WHERE district_id IS NOT NULL))\n    )\n) \nORDER BY a.date\nLIMIT 1;",
            "normalized": "SELECT a.account_id\nFROM public.account a\nJOIN public.client c ON a.district_id = c.district_id\nWHERE c.district_id =\n    (SELECT district_id\n     FROM public.client\n     WHERE district_id IN\n         (SELECT district_id\n          FROM public.client\n          WHERE district_id =\n              (SELECT district_id\n               FROM public.client\n               WHERE district_id =\n                   (SELECT MIN(district_id)\n                    FROM public.client\n                    WHERE district_id IS NOT NULL))))\nORDER BY a.date\nLIMIT 1;"
        },
        "db_id": "financial"
    },
    {
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.\"A3\" = 'south Bohemia' GROUP BY T2.\"A4\" ORDER BY T2.\"A4\" DESC LIMIT 1",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T1.gender = 'M' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.\"A3\" = 'south Bohemia'\nGROUP BY T2.\"A4\"\nORDER BY T2.\"A4\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about branch locations or how to determine which branch is located in the south Bohemia with the biggest number of inhabitants. The necessary data, such as a table linking branches to locations or additional geographical information, is missing.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about branch locations\nOR how TO determine which branch IS located IN the south Bohemia WITH the biggest number OF inhabitants. The necessary DATA,\n                                                                                                                       such AS a TABLE linking branches TO locations\nOR additional geographical information,\n                           IS missing."
        },
        "db_id": "financial"
    },
    {
        "question": "For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?",
        "reference_sql_query": {
            "raw": "SELECT CAST((SUM(CASE WHEN T3.date = '1998-12-27' THEN T3.balance ELSE 0 END) - SUM(CASE WHEN T3.date = '1993-03-22' THEN T3.balance ELSE 0 END)) AS DOUBLE PRECISION) * 100 / SUM(CASE WHEN T3.date = '1993-03-22' THEN T3.balance ELSE 0 END) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
            "normalized": "SELECT CAST((SUM(CASE\n                     WHEN T3.date = '1998-12-27' THEN T3.balance\n                     ELSE 0\n                 END) - SUM(CASE\n                                WHEN T3.date = '1993-03-22' THEN T3.balance\n                                ELSE 0\n                            END)) AS DOUBLE PRECISION) * 100 / SUM(CASE\n                                                                       WHEN T3.date = '1993-03-22' THEN T3.balance\n                                                                       ELSE 0\n                                                                   END)\nFROM loan AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nINNER JOIN trans AS T3 ON T3.account_id = T2.account_id\nWHERE T1.date = '1993-07-05'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to answer the question because there are no tables or columns that provide information about account balances over time. We have the `loan`, `account`, and `client` tables, but there is no data related to account balances or transactions that would allow us to calculate the increase rate in account balance.",
            "normalized": "The provided context IS insufficient TO answer the question because there ARE NO TABLES\nOR columns that provide information about ACCOUNT balances OVER time. We have the `loan`,\n                                                                              `account`,\nAND `client` TABLES,\n             but there IS NO DATA related TO ACCOUNT balances\nOR transactions that would allow us TO calculate the increase rate IN ACCOUNT balance."
        },
        "db_id": "financial"
    },
    {
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "reference_sql_query": {
            "raw": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS DOUBLE PRECISION) * 100) / SUM(amount) FROM loan",
            "normalized": "SELECT (CAST(SUM(CASE\n                     WHEN status = 'A' THEN amount\n                     ELSE 0\n                 END) AS DOUBLE PRECISION) * 100) / SUM(amount)\nFROM loan"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) / SUM(amount) * 100) AS percentage_fully_paid\nFROM \n    public.loan;",
            "normalized": "SELECT (SUM(CASE\n                WHEN status = 'A' THEN amount\n                ELSE 0\n            END) / SUM(amount) * 100) AS percentage_fully_paid\nFROM public.loan;"
        },
        "db_id": "financial"
    },
    {
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN status = 'C' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(account_id)\nFROM loan\nWHERE amount < 100000"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(CASE WHEN status = 'running' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_running\nFROM \n    public.loan\nWHERE \n    amount < 100000;",
            "normalized": "SELECT (COUNT(CASE\n                  WHEN status = 'running' THEN 1\n              END) * 100.0 / COUNT(*)) AS percentage_running\nFROM public.loan\nWHERE amount < 100000;"
        },
        "db_id": "financial"
    },
    {
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id, T2.\"A2\", T2.\"A3\" FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND EXTRACT(YEAR FROM T1.date)= '1993'",
            "normalized": "SELECT T1.account_id,\n       T2.\"A2\",\n       T2.\"A3\"\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.frequency = 'POPLATEK PO OBRATU'\n  AND EXTRACT(YEAR\n              FROM T1.date)= '1993'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.account_id, d.A2 AS district_name, d.A3 AS district_region\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE a.date >= '1993-01-01' AND a.date <= '1993-12-31'\nAND a.frequency = 'issued_after_transaction';",
            "normalized": "SELECT a.account_id,\n       d.A2 AS district_name,\n       d.A3 AS district_region\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE a.date >= '1993-01-01'\n  AND a.date <= '1993-12-31'\n  AND a.frequency = 'issued_after_transaction';"
        },
        "db_id": "financial"
    },
    {
        "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.\"A3\" = 'east Bohemia' AND EXTRACT(YEAR FROM T1.date) BETWEEN '1995' AND '2000'",
            "normalized": "SELECT T1.account_id,\n       T1.frequency\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.\"A3\" = 'east Bohemia'\n  AND EXTRACT(YEAR\n              FROM T1.date) BETWEEN '1995' AND '2000'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.account_id, a.frequency\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE d.A2 = 'east Bohemia'\nAND a.date BETWEEN '1995-01-01' AND '2000-12-31';",
            "normalized": "SELECT a.account_id,\n       a.frequency\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE d.A2 = 'east Bohemia'\n  AND a.date BETWEEN '1995-01-01' AND '2000-12-31';"
        },
        "db_id": "financial"
    },
    {
        "question": "List account ID and account opening date for accounts from 'Prachatice'.",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.\"A2\" = 'Prachatice'",
            "normalized": "SELECT T1.account_id,\n       T1.date\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.\"A2\" = 'Prachatice'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not include information on how to connect the `account` table with a location such as 'Prachatice'. Therefore, it is not possible to generate a SQL query to answer the question with the given context.",
            "normalized": "The provided context does NOT INCLUDE information ON how TO CONNECT the `account` TABLE WITH a LOCATION such AS 'Prachatice'. Therefore,\n                                                                                                                              it IS NOT possible TO generate a SQL query TO answer the question WITH the given context."
        },
        "db_id": "financial"
    },
    {
        "question": "State the district and region for loan ID '4990'.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"A2\", T2.\"A3\" FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
            "normalized": "SELECT T2.\"A2\",\n       T2.\"A3\"\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.loan_id = 4990"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information in the given table schemas that links loan IDs directly to any specific region information. The \"district\" table is likely relevant, but there is no clear connection between its columns and a \"region\" or a specific way to determine the district name or region based on the loan ID.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information IN the given TABLE schemas that links loan IDs directly TO ANY SPECIFIC region information. The \"district\" TABLE IS likely relevant,\n                                                                                                                                                                                                                   but there IS NO clear CONNECTION BETWEEN its columns AND a \"region\"\nOR a SPECIFIC way TO determine the district name\nOR region based ON the loan ID."
        },
        "db_id": "financial"
    },
    {
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "reference_sql_query": {
            "raw": "SELECT T1.account_id, T2.\"A2\", T2.\"A3\" FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
            "normalized": "SELECT T1.account_id,\n       T2.\"A2\",\n       T2.\"A3\"\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.amount > 300000"
        },
        "generated_sql_query": {
            "raw": "SELECT a.account_id, d.district_id, d.A2 AS region\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;",
            "normalized": "SELECT a.account_id,\n       d.district_id,\n       d.A2 AS region\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE l.amount > 300000;"
        },
        "db_id": "financial"
    },
    {
        "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
        "reference_sql_query": {
            "raw": "SELECT T3.loan_id, T2.\"A2\", T2.\"A11\" FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
            "normalized": "SELECT T3.loan_id,\n       T2.\"A2\",\n       T2.\"A11\"\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.duration = 60"
        },
        "generated_sql_query": {
            "raw": "SELECT l.loan_id, d.A2 AS district_name, d.A10 AS average_salary\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE l.duration = 60;",
            "normalized": "SELECT l.loan_id,\n       d.A2 AS district_name,\n       d.A10 AS average_salary\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE l.duration = 60;"
        },
        "db_id": "financial"
    },
    {
        "question": "For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "reference_sql_query": {
            "raw": "SELECT CAST((T3.\"A13\" - T3.\"A12\") AS DOUBLE PRECISION) * 100 / T3.\"A12\" FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
            "normalized": "SELECT CAST((T3.\"A13\" - T3.\"A12\") AS DOUBLE PRECISION) * 100 / T3.\"A12\"\nFROM loan AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nINNER JOIN district AS T3 ON T2.district_id = T3.district_id\nWHERE T1.status = 'D'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the unemployment rate or how it changed from 1995 to 1996 in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the unemployment rate\nOR how it changed\nFROM 1995 TO 1996 IN the given tables."
        },
        "db_id": "financial"
    },
    {
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T1.\"A2\" = 'Decin' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE EXTRACT(YEAR FROM T2.date) = '1993'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T1.\"A2\" = 'Decin' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(account_id)\nFROM district AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.district_id = T2.district_id\nWHERE EXTRACT(YEAR\n              FROM T2.date) = '1993'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(a.account_id) FILTER (WHERE d.A3 = 'Decin')::FLOAT / COUNT(a.account_id) * 100) AS percentage_decin\nFROM \n    public.account a\nJOIN \n    public.district d ON a.district_id = d.district_id\nWHERE \n    EXTRACT(YEAR FROM a.date) = 1993;",
            "normalized": "SELECT (COUNT(a.account_id) FILTER (\n                                    WHERE d.A3 = 'Decin')::FLOAT / COUNT(a.account_id) * 100) AS percentage_decin\nFROM public.account a\nJOIN public.district d ON a.district_id = d.district_id\nWHERE EXTRACT(YEAR\n              FROM a.date) = 1993;"
        },
        "db_id": "financial"
    },
    {
        "question": "List the account IDs with monthly issuance of statements.",
        "reference_sql_query": {
            "raw": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
            "normalized": "SELECT account_id\nFROM ACCOUNT\nWHERE Frequency = 'POPLATEK MESICNE'"
        },
        "generated_sql_query": {
            "raw": "SELECT account_id \nFROM public.account \nWHERE frequency = 'monthly';",
            "normalized": "SELECT account_id\nFROM public.account\nWHERE frequency = 'monthly';"
        },
        "db_id": "financial"
    },
    {
        "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"A2\", COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.\"A2\" ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
            "normalized": "SELECT T2.\"A2\",\n       COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id,\n         T2.\"A2\"\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9"
        },
        "generated_sql_query": {
            "raw": "SELECT d.district_id, COUNT(c.client_id) AS female_account_holders\nFROM public.client c\nJOIN public.account a ON c.district_id = a.district_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE c.gender = 'female'\nGROUP BY d.district_id\nORDER BY female_account_holders DESC\nLIMIT 9;",
            "normalized": "SELECT d.district_id,\n       COUNT(c.client_id) AS female_account_holders\nFROM public.client c\nJOIN public.account a ON c.district_id = a.district_id\nJOIN public.district d ON a.district_id = d.district_id\nWHERE c.gender = 'female'\nGROUP BY d.district_id\nORDER BY female_account_holders DESC\nLIMIT 9;"
        },
        "db_id": "financial"
    },
    {
        "question": "Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"A2\" FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ' AND T3.date::TEXT LIKE '1996-01%' ORDER BY \"A2\" ASC LIMIT 10",
            "normalized": "SELECT DISTINCT T1.\"A2\"\nFROM district AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ'\n  AND T3.date::TEXT LIKE '1996-01%'\nORDER BY \"A2\" ASC\nLIMIT 10"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because the provided context does not include any table or columns that clearly indicate a record of withdrawals, nor is there a direct relationship between transactions and district names. Additionally, the context does not specify which transactions are non-credit card withdrawals.",
            "normalized": "It can't be GENERATED because the provided context does NOT INCLUDE ANY TABLE\nOR columns that clearly indicate a record OF withdrawals,\n                                             nor IS there a direct relationship BETWEEN transactions AND district names. Additionally,\n                                                                                                         the context does NOT specify which transactions ARE non-credit card withdrawals."
        },
        "db_id": "financial"
    },
    {
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.\"A3\" = 'south Bohemia' AND T3.type != 'OWNER'",
            "normalized": "SELECT COUNT(T3.account_id)\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T2.client_id = T3.client_id\nWHERE T1.\"A3\" = 'south Bohemia'\n  AND T3.type != 'OWNER'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because the provided context does not contain any information about the region or location of account holders, such as \"South Bohemia\". The tables provided do not include any geographical data related to account holders.",
            "normalized": "It can't be GENERATED because the provided context does NOT contain ANY information about the region\nOR LOCATION OF ACCOUNT holders,\n                       such AS \"South Bohemia\". The TABLES provided DO NOT INCLUDE ANY geographical DATA related TO ACCOUNT holders."
        },
        "db_id": "financial"
    },
    {
        "question": "Which district has highest active loan?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"A3\" FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T2.\"A3\" ORDER BY SUM(T3.amount) DESC LIMIT 1",
            "normalized": "SELECT T2.\"A3\"\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.status IN ('C',\n                    'D')\nGROUP BY T2.\"A3\"\nORDER BY SUM(T3.amount) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate a SQL query to answer the question. The \"loan\" table contains information about loans including their status, but there is no direct link or column indicating which loans are \"active.\" Additionally, the \"district\" table is separate and does not have a direct relationship with the \"loan\" table in the given schema. More information is needed on how to determine if a loan is active and how to associate loans with districts.",
            "normalized": "The provided context IS insufficient TO generate a SQL query TO answer the question. The \"loan\" TABLE CONTAINS information about loans INCLUDING their status,\n                                                                                                                                                 but there IS NO direct LINK\nOR COLUMN indicating which loans ARE \"active.\" Additionally,\n                                     the \"district\" TABLE IS separate\nAND does NOT have a direct relationship WITH the \"loan\" TABLE IN the given schema.\nMORE information IS needed ON how TO determine IF a loan IS active\nAND how TO associate loans WITH districts."
        },
        "db_id": "financial"
    },
    {
        "question": "What is the average loan amount by male borrowers?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
            "normalized": "SELECT AVG(T4.amount)\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN ACCOUNT AS T3 ON T2.account_id = T3.account_id\nINNER JOIN loan AS T4 ON T3.account_id = T4.account_id\nWHERE T1.gender = 'M'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(l.amount) AS average_loan_amount\nFROM public.loan l\nJOIN public.client c ON l.account_id = c.client_id\nWHERE c.gender = 'male';",
            "normalized": "SELECT AVG(l.amount) AS average_loan_amount\nFROM public.loan l\nJOIN public.client c ON l.account_id = c.client_id\nWHERE c.gender = 'male';"
        },
        "db_id": "financial"
    },
    {
        "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
        "reference_sql_query": {
            "raw": "SELECT district_id, \"A2\" FROM district ORDER BY \"A13\" DESC LIMIT 1",
            "normalized": "SELECT district_id,\n       \"A2\"\nFROM district\nORDER BY \"A13\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information on unemployment rates in any of the tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information ON unemployment rates IN ANY OF the tables."
        },
        "db_id": "financial"
    },
    {
        "question": "In the branch where the largest number of crimes were committed in 1996, how many accounts were opened?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY T1.\"A16\" ORDER BY T1.\"A16\" DESC LIMIT 1",
            "normalized": "SELECT COUNT(T2.account_id)\nFROM district AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.district_id = T2.district_id\nGROUP BY T1.\"A16\"\nORDER BY T1.\"A16\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no information related to branches or crimes committed in 1996 in the available tables. The context only includes tables related to accounts, SAT scores, loans, transactions, yearmonth data, members, zip codes, income, majors, and votes.",
            "normalized": "The provided context IS insufficient because there IS NO information related TO branches\nOR crimes COMMITTED IN 1996 IN the available tables. The context ONLY includes TABLES related TO accounts,\n                                                                                                 SAT scores,\n                                                                                                 loans,\n                                                                                                 transactions,\n                                                                                                 yearmonth DATA,\n                                                                                                           members,\n                                                                                                           zip codes,\n                                                                                                           income,\n                                                                                                           majors,\nAND votes."
        },
        "db_id": "financial"
    },
    {
        "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
            "normalized": "SELECT COUNT(T1.account_id)\nFROM trans AS T1\nINNER JOIN ACCOUNT AS T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0\n  AND T1.operation = 'VYBER KARTOU'\n  AND T2.frequency = 'POPLATEK MESICNE'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query. The available tables do not contain information about account balances or withdrawals. Additionally, there is no direct link between card transactions and account balances in the provided schema.",
            "normalized": "The provided context IS insufficient TO generate the SQL query. The available TABLES DO NOT contain information about ACCOUNT balances\nOR withdrawals. Additionally,\n   there IS NO direct LINK BETWEEN card transactions AND ACCOUNT balances IN the provided schema."
        },
        "db_id": "financial"
    },
    {
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
            "normalized": "SELECT COUNT(T1.account_id)\nFROM ACCOUNT AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31'\n  AND T1.frequency = 'POPLATEK MESICNE'\n  AND T2.amount >= 250000"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT l.account_id) AS num_loans\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nWHERE l.date BETWEEN '1995-01-01' AND '1997-12-31'\n  AND l.amount >= 250000\n  AND a.frequency = 'monthly'\n  AND l.status = 'approved';",
            "normalized": "SELECT COUNT(DISTINCT l.account_id) AS num_loans\nFROM public.loan l\nJOIN public.account a ON l.account_id = a.account_id\nWHERE l.date BETWEEN '1995-01-01' AND '1997-12-31'\n  AND l.amount >= 250000\n  AND a.frequency = 'monthly'\n  AND l.status = 'approved';"
        },
        "db_id": "financial"
    },
    {
        "question": "How many accounts have running contracts in Branch location 1?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
            "normalized": "SELECT COUNT(T1.account_id)\nFROM ACCOUNT AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T1.district_id = 1\n  AND (T3.status = 'C'\n       OR T3.status = 'D')"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about \"Branch location 1\" or any column in the tables that corresponds to branch locations.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about \"Branch location 1\"\nOR ANY COLUMN IN the TABLES that corresponds TO branch locations."
        },
        "db_id": "financial"
    },
    {
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.\"A15\" = (SELECT T3.\"A15\" FROM district AS T3 ORDER BY T3.\"A15\" DESC LIMIT 1 OFFSET 1)",
            "normalized": "SELECT COUNT(T1.client_id)\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M'\n  AND T2.\"A15\" =\n    (SELECT T3.\"A15\"\n     FROM district AS T3\n     ORDER BY T3.\"A15\" DESC\n     LIMIT 1\n     OFFSET 1)"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information given about crimes, branches, or how they relate to clients in the available tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information given about crimes,\n                                                                                                     branches,\nOR how they relate TO clients IN the available tables."
        },
        "db_id": "financial"
    },
    {
        "question": "What is the most common bond type?",
        "reference_sql_query": {
            "raw": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
            "normalized": "SELECT T.bond_type\nFROM\n  (SELECT bond_type,\n          COUNT(bond_id)\n   FROM bond\n   GROUP BY bond_type\n   ORDER BY COUNT(bond_id) DESC\n   LIMIT 1) AS T"
        },
        "generated_sql_query": {
            "raw": "SELECT bond_type, COUNT(*) AS bond_count\nFROM public.bond\nGROUP BY bond_type\nORDER BY bond_count DESC\nLIMIT 1;",
            "normalized": "SELECT bond_type,\n       COUNT(*) AS bond_count\nFROM public.bond\nGROUP BY bond_type\nORDER BY bond_count DESC\nLIMIT 1;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "In the non-carcinogenic molecules, how many contain chlorine atoms?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '-'",
            "normalized": "SELECT COUNT(DISTINCT T1.molecule_id)\nFROM molecule AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.element = 'cl'\n  AND T1.label = '-'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because it does not include any information about whether a molecule is carcinogenic or non-carcinogenic. Additional data or context is needed to identify non-carcinogenic molecules.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because it does NOT INCLUDE ANY information about whether a molecule IS carcinogenic\nOR non-carcinogenic. Additional DATA\nOR context IS needed TO identify non-carcinogenic molecules."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "reference_sql_query": {
            "raw": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
            "normalized": "SELECT AVG(oxygen_count)\nFROM\n  (SELECT T1.molecule_id,\n          COUNT(T1.element) AS oxygen_count\n   FROM atom AS T1\n   INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\n   WHERE T2.bond_type = '-'\n     AND T1.element = 'o'\n   GROUP BY T1.molecule_id) AS oxygen_counts"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(oxygen_count) AS average_oxygen_atoms\nFROM (\n    SELECT m.molecule_id, COUNT(a.atom_id) AS oxygen_count\n    FROM molecule m\n    JOIN atom a ON m.molecule_id = a.molecule_id\n    JOIN bond b ON m.molecule_id = b.molecule_id\n    WHERE a.element = 'O' AND b.bond_type = 'single'\n    GROUP BY m.molecule_id\n) AS oxygen_counts;",
            "normalized": "SELECT AVG(oxygen_count) AS average_oxygen_atoms\nFROM\n  (SELECT m.molecule_id,\n          COUNT(a.atom_id) AS oxygen_count\n   FROM molecule m\n   JOIN atom a ON m.molecule_id = a.molecule_id\n   JOIN bond b ON m.molecule_id = b.molecule_id\n   WHERE a.element = 'O'\n     AND b.bond_type = 'single'\n   GROUP BY m.molecule_id) AS oxygen_counts;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "On average how many carcinogenic molecules are single bonded?",
        "reference_sql_query": {
            "raw": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
            "normalized": "SELECT AVG(single_bond_count)\nFROM\n  (SELECT T3.molecule_id,\n          COUNT(T1.bond_type) AS single_bond_count\n   FROM bond AS T1\n   INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n   INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id\n   WHERE T1.bond_type = '-'\n     AND T3.label = '+'\n   GROUP BY T3.molecule_id) AS subquery"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information on which molecules are carcinogenic, and there is no explicit mention of single bonds in the tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information ON which molecules ARE carcinogenic,\nAND there IS NO explicit mention OF single bonds IN the tables."
        },
        "db_id": "toxicology"
    },
    {
        "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
            "normalized": "SELECT COUNT(DISTINCT T2.molecule_id)\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'na'\n  AND T2.label = '-'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information regarding whether a molecule is carcinogenic or non-carcinogenic. Therefore, it is insufficient to generate a SQL query to answer the question.",
            "normalized": "The provided context does NOT contain information regarding whether a molecule IS carcinogenic\nOR non-carcinogenic. Therefore,\n   it IS insufficient TO generate a SQL query TO answer the question."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
            "normalized": "SELECT DISTINCT T2.molecule_id\nFROM bond AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#'\n  AND T2.label = '+'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information regarding molecules being carcinogenic or any related column in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information regarding molecules being carcinogenic\nOR ANY related COLUMN IN the given tables."
        },
        "db_id": "toxicology"
    },
    {
        "question": "What is the percentage of carbon in double-bond molecules?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS DOUBLE PRECISION) * 100 / COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='",
            "normalized": "SELECT CAST(COUNT(DISTINCT CASE\n                               WHEN T1.element = 'c' THEN T1.atom_id\n                               ELSE NULL\n                           END) AS DOUBLE PRECISION) * 100 / COUNT(DISTINCT T1.atom_id)\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.bond_type = '='"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (CAST(COUNT(DISTINCT a.atom_id) AS FLOAT) / CAST(COUNT(DISTINCT b.molecule_id) AS FLOAT)) * 100 AS percentage_of_carbon\nFROM \n    bond b\nJOIN \n    atom a ON b.molecule_id = a.molecule_id\nWHERE \n    b.bond_type = 'double' AND a.element = 'C';",
            "normalized": "SELECT (CAST(COUNT(DISTINCT a.atom_id) AS FLOAT) / CAST(COUNT(DISTINCT b.molecule_id) AS FLOAT)) * 100 AS percentage_of_carbon\nFROM bond b\nJOIN atom a ON b.molecule_id = a.molecule_id\nWHERE b.bond_type = 'double'\n  AND a.element = 'C';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many triple type bonds are there?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
            "normalized": "SELECT COUNT(T.bond_id)\nFROM bond AS T\nWHERE T.bond_type = '#'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) FROM public.bond WHERE bond_type = 'triple';",
            "normalized": "SELECT COUNT(*)\nFROM public.bond\nWHERE bond_type = 'triple';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "In how many atoms is there no bromine?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
            "normalized": "SELECT COUNT(DISTINCT T.atom_id)\nFROM atom AS T\nWHERE T.element <> 'br'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM atom \nWHERE element != 'bromine';",
            "normalized": "SELECT COUNT(*)\nFROM atom\nWHERE element != 'bromine';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Of the first 100 molecules in number order, how many are carcinogenic?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND T.label = '+'",
            "normalized": "SELECT COUNT(T.molecule_id)\nFROM molecule AS T\nWHERE molecule_id BETWEEN 'TR000' AND 'TR099'\n  AND T.label = '+'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information or column in the given tables that indicates whether a molecule is carcinogenic or not.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information\nOR COLUMN IN the given TABLES that indicates whether a molecule IS carcinogenic\nOR not."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Identify by their ID the molecules in which there is carbon.",
        "reference_sql_query": {
            "raw": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
            "normalized": "SELECT T.molecule_id\nFROM atom AS T\nWHERE T.element = 'c'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE a.element = 'carbon';",
            "normalized": "SELECT DISTINCT m.molecule_id\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE a.element = 'carbon';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
            "normalized": "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR004_8_9'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id\nWHERE c.bond_id = 'TR004_8_9';",
            "normalized": "SELECT DISTINCT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id\nWHERE c.bond_id = 'TR004_8_9';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What elements are in a double type bond?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
            "normalized": "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.bond_type = '='"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT a.element\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = 'double';",
            "normalized": "SELECT DISTINCT a.element\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE b.bond_type = 'double';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "reference_sql_query": {
            "raw": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
            "normalized": "SELECT T.label\nFROM\n  (SELECT T2.label,\n          COUNT(T2.molecule_id)\n   FROM atom AS T1\n   INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n   WHERE T1.element = 'h'\n   GROUP BY T2.label\n   ORDER BY COUNT(T2.molecule_id) DESC\n   LIMIT 1) t"
        },
        "generated_sql_query": {
            "raw": "SELECT m.label, COUNT(*) AS count\nFROM public.atom a\nJOIN public.molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'hydrogen'\nGROUP BY m.label\nORDER BY count DESC\nLIMIT 1;",
            "normalized": "SELECT m.label,\n       COUNT(*) AS COUNT\nFROM public.atom a\nJOIN public.molecule m ON a.molecule_id = m.molecule_id\nWHERE a.element = 'hydrogen'\nGROUP BY m.label\nORDER BY COUNT DESC\nLIMIT 1;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Chlorine is in what type of bond?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
            "normalized": "SELECT DISTINCT T1.bond_type\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id\nWHERE T3.element = 'cl'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT b.bond_type\nFROM public.atom a\nJOIN public.connected c ON a.atom_id = c.atom_id\nJOIN public.bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'Chlorine';",
            "normalized": "SELECT DISTINCT b.bond_type\nFROM public.atom a\nJOIN public.connected c ON a.atom_id = c.atom_id\nJOIN public.bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'Chlorine';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What atoms are connected in single type bonds?",
        "reference_sql_query": {
            "raw": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
            "normalized": "SELECT T2.atom_id,\n       T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.atom_id, c.atom_id2\nFROM public.connected c\nJOIN public.bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = 'single';",
            "normalized": "SELECT c.atom_id,\n       c.atom_id2\nFROM public.connected c\nJOIN public.bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = 'single';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
            "normalized": "SELECT DISTINCT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.label = '-'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the query. To determine which atoms are connected in non-carcinogenic type molecules, we would need additional information about which molecules are considered non-carcinogenic. This information is not present in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the query. TO determine which atoms ARE connected IN non-carcinogenic TYPE molecules,\n                                                                                                                            we would need additional information about which molecules ARE considered non-carcinogenic. This information IS NOT present IN the given tables."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "reference_sql_query": {
            "raw": "SELECT T.element FROM (SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 1) t",
            "normalized": "SELECT T.element\nFROM\n  (SELECT T1.element,\n          COUNT(DISTINCT T1.molecule_id)\n   FROM atom AS T1\n   INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n   WHERE T2.label = '-'\n   GROUP BY T1.element\n   ORDER BY COUNT(DISTINCT T1.molecule_id) ASC\n   LIMIT 1) t"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about which molecules are non-carcinogenic. Additional data or criteria are needed to identify non-carcinogenic molecules within the tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about which molecules ARE non-carcinogenic. Additional DATA\nOR criteria ARE needed TO identify non-carcinogenic molecules within the tables."
        },
        "db_id": "toxicology"
    },
    {
        "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
        "reference_sql_query": {
            "raw": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
            "normalized": "SELECT T1.bond_type\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T2.atom_id = 'TR004_8'\n  AND T2.atom_id2 = 'TR004_20'\n  OR T2.atom_id2 = 'TR004_8'\n  AND T2.atom_id = 'TR004_20'"
        },
        "generated_sql_query": {
            "raw": "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR004_8' AND c.atom_id2 = 'TR004_20')\n   OR (c.atom_id = 'TR004_20' AND c.atom_id2 = 'TR004_8');",
            "normalized": "SELECT b.bond_type\nFROM connected c\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE (c.atom_id = 'TR004_8'\n       AND c.atom_id2 = 'TR004_20')\n  OR (c.atom_id = 'TR004_20'\n      AND c.atom_id2 = 'TR004_8');"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What type of label is not on molecules with atoms with tin?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
            "normalized": "SELECT DISTINCT T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element != 'sn'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n    SELECT a.molecule_id\n    FROM atom a\n    WHERE a.element = 'tin'\n);",
            "normalized": "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN\n    (SELECT a.molecule_id\n     FROM atom a\n     WHERE a.element = 'tin');"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
            "normalized": "SELECT COUNT(DISTINCT CASE\n                          WHEN T1.element = 'i' THEN T1.atom_id\n                          ELSE NULL\n                      END) AS iodine_nums,\n       COUNT(DISTINCT CASE\n                          WHEN T1.element = 's' THEN T1.atom_id\n                          ELSE NULL\n                      END) AS sulfur_nums\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_type = '-'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT a.atom_id) AS count_of_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.element IN ('iodine', 'sulfur') AND b.bond_type = 'single';",
            "normalized": "SELECT COUNT(DISTINCT a.atom_id) AS count_of_atoms\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nWHERE a.element IN ('iodine',\n                    'sulfur')\n  AND b.bond_type = 'single';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Identify all connected atoms with a triple bond.",
        "reference_sql_query": {
            "raw": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
            "normalized": "SELECT T2.atom_id,\n       T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '#'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.atom_id, c.atom_id2\nFROM public.connected c\nJOIN public.bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = 'triple';",
            "normalized": "SELECT c.atom_id,\n       c.atom_id2\nFROM public.connected c\nJOIN public.bond b ON c.bond_id = b.bond_id\nWHERE b.bond_type = 'triple';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "reference_sql_query": {
            "raw": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
            "normalized": "SELECT T2.atom_id,\n       T2.atom_id2\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id\nWHERE T1.molecule_id = 'TR181'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.atom_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id2\nWHERE a.molecule_id = 'TR181';",
            "normalized": "SELECT a.atom_id\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id2\nWHERE a.molecule_id = 'TR181';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS DOUBLE PRECISION) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
            "normalized": "SELECT CAST(COUNT(DISTINCT CASE\n                               WHEN T1.element <> 'f' THEN T2.molecule_id\n                               ELSE NULL\n                           END) AS DOUBLE PRECISION) * 100 / COUNT(DISTINCT T2.molecule_id)\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(DISTINCT m.molecule_id) FILTER(WHERE a.atom_id IS NULL) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage_without_fluorine\nFROM \n    molecule m\nLEFT JOIN \n    atom a ON m.molecule_id = a.molecule_id AND a.element = 'Fluorine'\nJOIN \n    bond b ON m.molecule_id = b.molecule_id AND b.bond_type = 'carcinogenic'",
            "normalized": "SELECT (COUNT(DISTINCT m.molecule_id) FILTER(\n                                             WHERE a.atom_id IS NULL) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage_without_fluorine\nFROM molecule m\nLEFT JOIN atom a ON m.molecule_id = a.molecule_id\nAND a.element = 'Fluorine'\nJOIN bond b ON m.molecule_id = b.molecule_id\nAND b.bond_type = 'carcinogenic'"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What is the percentage of carcinogenic molecules in triple type bonds?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS DOUBLE PRECISION) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#'",
            "normalized": "SELECT CAST(COUNT(DISTINCT CASE\n                               WHEN T2.label = '+' THEN T2.molecule_id\n                               ELSE NULL\n                           END) AS DOUBLE PRECISION) * 100 / COUNT(DISTINCT T2.molecule_id)\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine the percentage of carcinogenic molecules in triple type bonds. There is no information or column in the given tables that indicates whether a molecule is carcinogenic or not.",
            "normalized": "The provided context IS insufficient TO determine the percentage OF carcinogenic molecules IN triple TYPE bonds. There IS NO information\nOR COLUMN IN the given TABLES that indicates whether a molecule IS carcinogenic\nOR not."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
            "normalized": "SELECT DISTINCT T.element\nFROM atom AS T\nWHERE T.molecule_id = 'TR000'\nORDER BY T.element\nLIMIT 3"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information on toxicology or any related data in the context. The available tables do not contain any columns or data related to toxicology.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information ON toxicology\nOR ANY related DATA IN the context. The available TABLES DO NOT contain ANY columns\nOR DATA related TO toxicology."
        },
        "db_id": "toxicology"
    },
    {
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "reference_sql_query": {
            "raw": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
            "normalized": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1,\n       T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2\nFROM bond AS T\nWHERE T.molecule_id = 'TR001'\n  AND T.bond_id = 'TR001_2_6'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.atom_id, a.element\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR001_2_6' AND b.molecule_id = \n    (SELECT molecule_id FROM molecule WHERE label = 'TR001');",
            "normalized": "SELECT a.atom_id,\n       a.element\nFROM atom a\nJOIN bond b ON a.molecule_id = b.molecule_id\nJOIN connected c ON b.bond_id = c.bond_id\nWHERE b.bond_id = 'TR001_2_6'\n  AND b.molecule_id =\n    (SELECT molecule_id\n     FROM molecule\n     WHERE label = 'TR001');"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
            "normalized": "SELECT COUNT(CASE\n                 WHEN T.label = '+' THEN T.molecule_id\n                 ELSE NULL\n             END) - COUNT(CASE\n                              WHEN T.label = '-' THEN T.molecule_id\n                              ELSE NULL\n                          END) AS diff_car_notcar\nFROM molecule t"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because there is no information in the provided context that indicates whether a molecule is carcinogenic or not.",
            "normalized": "It can't be GENERATED because there IS NO information IN the provided context that indicates whether a molecule IS carcinogenic\nOR not."
        },
        "db_id": "toxicology"
    },
    {
        "question": "What are the atom IDs of the bond TR000_2_5?",
        "reference_sql_query": {
            "raw": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
            "normalized": "SELECT T.atom_id\nFROM connected AS T\nWHERE T.bond_id = 'TR000_2_5'"
        },
        "generated_sql_query": {
            "raw": "SELECT atom_id, atom_id2\nFROM public.connected\nWHERE bond_id = 'TR000_2_5';",
            "normalized": "SELECT atom_id,\n       atom_id2\nFROM public.connected\nWHERE bond_id = 'TR000_2_5';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What are the bond IDs that have the same atom ID 2 of TR000_2?",
        "reference_sql_query": {
            "raw": "SELECT T.bond_id FROM connected AS T WHERE T.atom_id2 = 'TR000_2'",
            "normalized": "SELECT T.bond_id\nFROM connected AS T\nWHERE T.atom_id2 = 'TR000_2'"
        },
        "generated_sql_query": {
            "raw": "SELECT bond_id\nFROM public.connected\nWHERE atom_id2 = 'TR000_2';",
            "normalized": "SELECT bond_id\nFROM public.connected\nWHERE atom_id2 = 'TR000_2';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Please list top five molecules that have double bonds in alphabetical order.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '=' ORDER BY T.molecule_id LIMIT 5",
            "normalized": "SELECT DISTINCT T.molecule_id\nFROM bond AS T\nWHERE T.bond_type = '='\nORDER BY T.molecule_id\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "SELECT m.label\nFROM public.molecule m\nJOIN public.bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = 'double'\nGROUP BY m.label\nORDER BY m.label\nLIMIT 5;",
            "normalized": "SELECT m.label\nFROM public.molecule m\nJOIN public.bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = 'double'\nGROUP BY m.label\nORDER BY m.label\nLIMIT 5;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "reference_sql_query": {
            "raw": "SELECT ROUND(CASE WHEN COUNT(T.bond_id) > 0 THEN (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END)::NUMERIC * 100 / COUNT(T.bond_id)) ELSE 0 END, 5) AS percentage FROM bond AS T WHERE T.molecule_id = 'TR008'",
            "normalized": "SELECT ROUND(CASE\n                 WHEN COUNT(T.bond_id) > 0 THEN (COUNT(CASE\n                                                           WHEN T.bond_type = '=' THEN T.bond_id\n                                                           ELSE NULL\n                                                       END)::NUMERIC * 100 / COUNT(T.bond_id))\n                 ELSE 0\n             END, 5) AS percentage\nFROM bond AS T\nWHERE T.molecule_id = 'TR008'"
        },
        "generated_sql_query": {
            "raw": "WITH double_bonds AS (\n    SELECT COUNT(*) AS double_bond_count\n    FROM bond\n    WHERE bond_type = 'double'\n    AND molecule_id = 'TR008'\n),\ntotal_bonds AS (\n    SELECT COUNT(*) AS total_bond_count\n    FROM bond\n    WHERE molecule_id = 'TR008'\n)\nSELECT \n    (CAST(double_bond_count AS DECIMAL) / total_bond_count) * 100 AS double_bond_percentage\nFROM double_bonds, total_bonds;",
            "normalized": "WITH double_bonds AS\n  (SELECT COUNT(*) AS double_bond_count\n   FROM bond\n   WHERE bond_type = 'double'\n     AND molecule_id = 'TR008'),\n     total_bonds AS\n  (SELECT COUNT(*) AS total_bond_count\n   FROM bond\n   WHERE molecule_id = 'TR008')\nSELECT (CAST(double_bond_count AS DECIMAL) / total_bond_count) * 100 AS double_bond_percentage\nFROM double_bonds,\n     total_bonds;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "reference_sql_query": {
            "raw": "SELECT ROUND(CASE WHEN COUNT(T.molecule_id) > 0 THEN (COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END)::NUMERIC * 100 / COUNT(T.molecule_id)) ELSE 0 END, 3) AS percentage FROM molecule AS T",
            "normalized": "SELECT ROUND(CASE\n                 WHEN COUNT(T.molecule_id) > 0 THEN (COUNT(CASE\n                                                               WHEN T.label = '+' THEN T.molecule_id\n                                                               ELSE NULL\n                                                           END)::NUMERIC * 100 / COUNT(T.molecule_id))\n                 ELSE 0\n             END, 3) AS percentage\nFROM molecule AS T"
        },
        "generated_sql_query": {
            "raw": "It is not possible to generate the SQL query because the provided context does not include any information about which molecules are carcinogenic.",
            "normalized": "It IS NOT possible TO generate the SQL query because the provided context does NOT INCLUDE ANY information about which molecules ARE carcinogenic."
        },
        "db_id": "toxicology"
    },
    {
        "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
        "reference_sql_query": {
            "raw": "SELECT ROUND(CASE WHEN COUNT(T.atom_id) > 0 THEN (COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END)::NUMERIC * 100 / COUNT(T.atom_id)) ELSE 0 END, 4) AS percentage FROM atom AS T WHERE T.molecule_id = 'TR206'",
            "normalized": "SELECT ROUND(CASE\n                 WHEN COUNT(T.atom_id) > 0 THEN (COUNT(CASE\n                                                           WHEN T.element = 'h' THEN T.atom_id\n                                                           ELSE NULL\n                                                       END)::NUMERIC * 100 / COUNT(T.atom_id))\n                 ELSE 0\n             END, 4) AS percentage\nFROM atom AS T\nWHERE T.molecule_id = 'TR206'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(a.atom_id) FILTER (WHERE a.element = 'H')::FLOAT / COUNT(a.atom_id)::FLOAT) * 100 AS hydrogen_percentage\nFROM \n    molecule m\nJOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = 'TR206';",
            "normalized": "SELECT (COUNT(a.atom_id) FILTER (\n                                 WHERE a.element = 'H')::FLOAT / COUNT(a.atom_id)::FLOAT) * 100 AS hydrogen_percentage\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = 'TR206';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
            "normalized": "SELECT DISTINCT T.bond_type\nFROM bond AS T\nWHERE T.molecule_id = 'TR000'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT b.bond_type\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = 'TR000';",
            "normalized": "SELECT DISTINCT b.bond_type\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE m.label = 'TR000';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "What are the elements of the toxicology and label of molecule TR060?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
            "normalized": "SELECT DISTINCT T1.element,\n                T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.molecule_id = 'TR060'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.element, m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = 'TR060';",
            "normalized": "SELECT a.element,\n       m.label\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = 'TR060';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "reference_sql_query": {
            "raw": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
            "normalized": "SELECT T.bond_type\nFROM\n  (SELECT T1.bond_type,\n          COUNT(T1.molecule_id)\n   FROM bond AS T1\n   WHERE T1.molecule_id = 'TR010'\n   GROUP BY T1.bond_type\n   ORDER BY COUNT(T1.molecule_id) DESC\n   LIMIT 1) AS T"
        },
        "generated_sql_query": {
            "raw": "SELECT bond_type, COUNT(*) as bond_count\nFROM bond\nWHERE molecule_id = 'TR010'\nGROUP BY bond_type\nORDER BY bond_count DESC\nLIMIT 1;",
            "normalized": "SELECT bond_type,\n       COUNT(*) AS bond_count\nFROM bond\nWHERE molecule_id = 'TR010'\nGROUP BY bond_type\nORDER BY bond_count DESC\nLIMIT 1;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
            "normalized": "SELECT DISTINCT T2.molecule_id\nFROM bond AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '-'\n  AND T2.label = '-'\nORDER BY T2.molecule_id\nLIMIT 3"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about whether a molecule is carcinogenic or not in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about whether a molecule IS carcinogenic\nOR NOT IN the given tables."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
            "normalized": "SELECT DISTINCT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.molecule_id = 'TR006'\nORDER BY T2.bond_id\nLIMIT 2"
        },
        "generated_sql_query": {
            "raw": "SELECT bond_id\nFROM bond\nWHERE molecule_id = 'TR006'\nORDER BY bond_id\nLIMIT 2;",
            "normalized": "SELECT bond_id\nFROM bond\nWHERE molecule_id = 'TR006'\nORDER BY bond_id\nLIMIT 2;"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
            "normalized": "SELECT COUNT(T2.bond_id)\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.molecule_id = 'TR009'\n  AND T2.atom_id = T1.molecule_id || '_1'\n  AND T2.atom_id2 = T1.molecule_id || '_2'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(b.bond_id) AS bond_count\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON (c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id)\nWHERE m.label = 'TR009' AND a.atom_id = '12';",
            "normalized": "SELECT COUNT(b.bond_id) AS bond_count\nFROM bond b\nJOIN molecule m ON b.molecule_id = m.molecule_id\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a ON (c.atom_id = a.atom_id\n                OR c.atom_id2 = a.atom_id)\nWHERE m.label = 'TR009'\n  AND a.atom_id = '12';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many molecules are carcinogenic and have the bromine element?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
            "normalized": "SELECT COUNT(DISTINCT T2.molecule_id)\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'\n  AND T1.element = 'br'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated. The provided context does not include any information about whether molecules are carcinogenic.",
            "normalized": "It can't be generated. The provided context does NOT INCLUDE ANY information about whether molecules ARE carcinogenic."
        },
        "db_id": "toxicology"
    },
    {
        "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
        "reference_sql_query": {
            "raw": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
            "normalized": "SELECT T1.bond_type,\n       T2.atom_id,\n       T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T2.bond_id = 'TR001_6_9'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    b.bond_type,\n    a1.element AS atom1,\n    a2.element AS atom2\nFROM \n    bond b\nJOIN \n    connected c ON b.bond_id = c.bond_id\nJOIN \n    atom a1 ON c.atom_id = a1.atom_id\nJOIN \n    atom a2 ON c.atom_id2 = a2.atom_id\nWHERE \n    b.bond_id = 'TR001_6_9';",
            "normalized": "SELECT b.bond_type,\n       a1.element AS atom1,\n       a2.element AS atom2\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE b.bond_id = 'TR001_6_9';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not.",
        "reference_sql_query": {
            "raw": "SELECT T2.molecule_id , CASE WHEN T2.label = '+' THEN 'YES' ELSE 'NO' END AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
            "normalized": "SELECT T2.molecule_id,\n       CASE\n           WHEN T2.label = '+' THEN 'YES'\n           ELSE 'NO'\n       END AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.atom_id = 'TR001_10'"
        },
        "generated_sql_query": {
            "raw": "SELECT m.molecule_id, m.label\nFROM public.atom a\nJOIN public.molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR001_10';",
            "normalized": "SELECT m.molecule_id,\n       m.label\nFROM public.atom a\nJOIN public.molecule m ON a.molecule_id = m.molecule_id\nWHERE a.atom_id = 'TR001_10';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many molecules have a triple bond type?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'",
            "normalized": "SELECT COUNT(DISTINCT T.molecule_id)\nFROM bond AS T\nWHERE T.bond_type = '#'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT m.molecule_id) AS num_molecules_with_triple_bond\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = 'triple';",
            "normalized": "SELECT COUNT(DISTINCT m.molecule_id) AS num_molecules_with_triple_bond\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = 'triple';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many connections does the atom 19 have?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
            "normalized": "SELECT COUNT(T.bond_id)\nFROM connected AS T\nWHERE SUBSTR(T.atom_id, -2) = '19'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS connection_count\nFROM public.connected\nWHERE atom_id = '19' OR atom_id2 = '19';",
            "normalized": "SELECT COUNT(*) AS connection_count\nFROM public.connected\nWHERE atom_id = '19'\n  OR atom_id2 = '19';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "List all the elements of the toxicology of the molecule \"TR004\".",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
            "normalized": "SELECT DISTINCT T.element\nFROM atom AS T\nWHERE T.molecule_id = 'TR004'"
        },
        "generated_sql_query": {
            "raw": "SELECT a.element\nFROM public.atom a\nJOIN public.molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = 'TR004';",
            "normalized": "SELECT a.element\nFROM public.atom a\nJOIN public.molecule m ON a.molecule_id = m.molecule_id\nWHERE m.label = 'TR004';"
        },
        "db_id": "toxicology"
    },
    {
        "question": "How many of the molecules are not carcinogenic?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '-'",
            "normalized": "SELECT COUNT(T.molecule_id)\nFROM molecule AS T\nWHERE T.label = '-'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine whether a molecule is carcinogenic or not. The tables given do not contain any information related to the carcinogenicity of molecules.",
            "normalized": "The provided context IS insufficient TO determine whether a molecule IS carcinogenic\nOR not. The TABLES given DO NOT contain ANY information related TO the carcinogenicity OF molecules."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
            "normalized": "SELECT DISTINCT T2.molecule_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25'\n  AND T2.label = '+'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the query because there is no information regarding which molecules are carcinogenic. Additional data or a table specifying carcinogenic molecules is required.",
            "normalized": "The provided context IS insufficient TO generate the query because there IS NO information regarding which molecules ARE carcinogenic. Additional DATA\nOR a TABLE specifying carcinogenic molecules IS required."
        },
        "db_id": "toxicology"
    },
    {
        "question": "What are the bonds that have phosphorus and nitrogen as their atom elements?",
        "reference_sql_query": {
            "raw": "SELECT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id IN ( SELECT T3.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p' ) AND T1.element = 'n'",
            "normalized": "SELECT T2.bond_id\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id IN\n    (SELECT T3.bond_id\n     FROM connected AS T3\n     INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id\n     WHERE T4.element = 'p')\n  AND T1.element = 'n'"
        },
        "generated_sql_query": {
            "raw": "SELECT b.bond_id\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE (a1.element = 'Phosphorus' AND a2.element = 'Nitrogen')\n   OR (a1.element = 'Nitrogen' AND a2.element = 'Phosphorus');",
            "normalized": "SELECT b.bond_id\nFROM bond b\nJOIN connected c ON b.bond_id = c.bond_id\nJOIN atom a1 ON c.atom_id = a1.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nWHERE (a1.element = 'Phosphorus'\n       AND a2.element = 'Nitrogen')\n  OR (a1.element = 'Nitrogen'\n      AND a2.element = 'Phosphorus');"
        },
        "db_id": "toxicology"
    },
    {
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "reference_sql_query": {
            "raw": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
            "normalized": "SELECT T1.label\nFROM molecule AS T1\nINNER JOIN\n  (SELECT T.molecule_id,\n          COUNT(T.bond_type)\n   FROM bond AS T\n   WHERE T.bond_type = '='\n   GROUP BY T.molecule_id\n   ORDER BY COUNT(T.bond_type) DESC\n   LIMIT 1) AS T2 ON T1.molecule_id = T2.molecule_id"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine if the molecule with the most double bonds is carcinogenic. The tables do not contain any information about the carcinogenic properties of molecules. Additional data or context about the carcinogenic properties of molecules would be necessary to answer this question.",
            "normalized": "The provided context IS insufficient TO determine IF the molecule WITH the most DOUBLE bonds IS carcinogenic. The TABLES DO NOT contain ANY information about the carcinogenic properties OF molecules. Additional DATA\nOR context about the carcinogenic properties OF molecules would be necessary TO answer this question."
        },
        "db_id": "toxicology"
    },
    {
        "question": "Which are the cards that have incredibly powerful foils.",
        "reference_sql_query": {
            "raw": "SELECT id FROM cards WHERE \"cardKingdomFoilId\" IS NOT NULL AND \"cardKingdomId\" IS NOT NULL",
            "normalized": "SELECT id\nFROM cards\nWHERE \"cardKingdomFoilId\" IS NOT NULL\n  AND \"cardKingdomId\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain specific information about what constitutes \"incredibly powerful foils\" for cards. Therefore, it's not possible to generate a SQL query to answer this question without additional context or criteria for what makes a foil \"incredibly powerful\".",
            "normalized": "The provided context does NOT contain SPECIFIC information about what constitutes \"incredibly powerful foils\"\nFOR cards. Therefore,\n    it's NOT possible TO generate a SQL query TO answer this question WITHOUT additional context\nOR criteria\nFOR what makes a foil \"incredibly powerful\"."
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the borderless cards available without powerful foils?",
        "reference_sql_query": {
            "raw": "SELECT id FROM cards WHERE \"borderColor\" = 'borderless' AND (\"cardKingdomId\" IS NULL OR \"cardKingdomId\" IS NULL)",
            "normalized": "SELECT id\nFROM cards\nWHERE \"borderColor\" = 'borderless'\n  AND (\"cardKingdomId\" IS NULL\n       OR \"cardKingdomId\" IS NULL)"
        },
        "generated_sql_query": {
            "raw": "SELECT * \nFROM public.cards\nWHERE \"isFullArt\" = 1 AND \"hasFoil\" = 0;",
            "normalized": "SELECT *\nFROM public.cards\nWHERE \"isFullArt\" = 1\n  AND \"hasFoil\" = 0;"
        },
        "db_id": "card_games"
    },
    {
        "question": "List the card names with value that cost more converted mana for the face.",
        "reference_sql_query": {
            "raw": "SELECT name FROM cards ORDER BY \"faceConvertedManaCost\" LIMIT 1",
            "normalized": "SELECT name\nFROM cards\nORDER BY \"faceConvertedManaCost\"\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT name \nFROM public.cards \nWHERE faceConvertedManaCost > convertedManaCost;",
            "normalized": "SELECT name\nFROM public.cards\nWHERE faceConvertedManaCost > convertedManaCost;"
        },
        "db_id": "card_games"
    },
    {
        "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
        "reference_sql_query": {
            "raw": "SELECT id FROM cards WHERE \"edhrecRank\" < 100 AND \"frameVersion\" = '2015'",
            "normalized": "SELECT id\nFROM cards\nWHERE \"edhrecRank\" < 100\n  AND \"frameVersion\" = '2015'"
        },
        "generated_sql_query": {
            "raw": "SELECT name \nFROM public.cards \nWHERE frameVersion = '2015' AND edhrecRank < 100;",
            "normalized": "SELECT name\nFROM public.cards\nWHERE frameVersion = '2015'\n  AND edhrecRank < 100;"
        },
        "db_id": "card_games"
    },
    {
        "question": "List all the mythic rarity print cards banned in gladiator format.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
            "normalized": "SELECT DISTINCT T1.id\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T2.format = 'gladiator'\n  AND T2.status = 'Banned'\n  AND T1.rarity = 'mythic'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.*\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic' AND l.format = 'gladiator' AND l.status = 'banned';",
            "normalized": "SELECT c.*\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic'\n  AND l.format = 'gladiator'\n  AND l.status = 'banned';"
        },
        "db_id": "card_games"
    },
    {
        "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
            "normalized": "SELECT DISTINCT T2.status\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.type = 'Artifact'\n  AND T2.format = 'vintage'\n  AND T1.side IS NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name, l.status\nFROM public.cards c\nJOIN public.legalities l ON c.uuid = l.uuid\nWHERE c.type LIKE '%Artifact%'\n  AND c.layout NOT IN ('split', 'flip', 'transform', 'modal_dfc', 'meld', 'adventure', 'saga', 'leveler', 'class', 'planes')\n  AND l.format = 'Vintage';",
            "normalized": "SELECT c.name,\n       l.status\nFROM public.cards c\nJOIN public.legalities l ON c.uuid = l.uuid\nWHERE c.type LIKE '%Artifact%'\n  AND c.layout NOT IN ('split',\n                       'flip',\n                       'transform',\n                       'modal_dfc',\n                       'meld',\n                       'adventure',\n                       'saga',\n                       'leveler',\n                       'class',\n                       'planes')\n  AND l.format = 'Vintage';"
        },
        "db_id": "card_games"
    },
    {
        "question": "List all the card id and artist with unknown power which are legal for commander play format.",
        "reference_sql_query": {
            "raw": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
            "normalized": "SELECT T1.id,\n       T1.artist\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Legal'\n  AND T2.format = 'commander'\n  AND (T1.power IS NULL\n       OR T1.power = '*')"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the query. The tables provided do not have a direct relation or column that indicates a power is \"unknown,\" nor is there a clear indication of how to determine cards that are legal for the \"commander\" format. Additionally, the relationship between card IDs and power is not established in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the query. The TABLES provided DO NOT have a direct relation\nOR COLUMN that indicates a power IS \"unknown,\" nor IS there a clear indication OF how TO determine cards that ARE legal\nFOR the \"commander\" format. Additionally,\n                    the relationship BETWEEN card IDs AND power IS NOT established IN the given tables."
        },
        "db_id": "card_games"
    },
    {
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "reference_sql_query": {
            "raw": "SELECT T1.id, T2.text, T1.\"hasContentWarning\" FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
            "normalized": "SELECT T1.id,\n       T2.text,\n       T1.\"hasContentWarning\"\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name, r.text AS ruling_text\nFROM public.cards c\nJOIN public.rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Stephen Daniel';",
            "normalized": "SELECT c.name,\n       r.text AS ruling_text\nFROM public.cards c\nJOIN public.rulings r ON c.uuid = r.uuid\nWHERE c.artist = 'Stephen Daniel';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
        "reference_sql_query": {
            "raw": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
            "normalized": "SELECT T2.text\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Sublime Epiphany'\n  AND T1.number = '74s'"
        },
        "generated_sql_query": {
            "raw": "SELECT r.*\nFROM public.rulings r\nJOIN public.cards c ON r.uuid = c.uuid\nWHERE c.name = 'Sublime Epiphany' AND c.number = '74s';",
            "normalized": "SELECT r.*\nFROM public.rulings r\nJOIN public.cards c ON r.uuid = c.uuid\nWHERE c.name = 'Sublime Epiphany'\n  AND c.number = '74s';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "reference_sql_query": {
            "raw": "SELECT T1.name, T1.artist, T1.\"isPromo\" FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.\"isPromo\" = 1 AND T1.artist = (SELECT artist FROM cards WHERE \"isPromo\" = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE \"isPromo\" = 1 GROUP BY artist ))) LIMIT 1",
            "normalized": "SELECT T1.name,\n       T1.artist,\n       T1.\"isPromo\"\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.\"isPromo\" = 1\n  AND T1.artist =\n    (SELECT artist\n     FROM cards\n     WHERE \"isPromo\" = 1\n     GROUP BY artist\n     HAVING COUNT(DISTINCT UUID) =\n       (SELECT MAX(count_uuid)\n        FROM\n          (SELECT COUNT(DISTINCT UUID) AS count_uuid\n           FROM cards\n           WHERE \"isPromo\" = 1\n           GROUP BY artist)))\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name AS card_name, c.artist, c.isPromo, COUNT(r.id) AS ruling_count\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nGROUP BY c.name, c.artist, c.isPromo\nORDER BY ruling_count DESC\nLIMIT 1;",
            "normalized": "SELECT c.name AS card_name,\n       c.artist,\n       c.isPromo,\n       COUNT(r.id) AS ruling_count\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nGROUP BY c.name,\n         c.artist,\n         c.isPromo\nORDER BY ruling_count DESC\nLIMIT 1;"
        },
        "db_id": "card_games"
    },
    {
        "question": "State the alternative languages available for card named Annul numbered 29.",
        "reference_sql_query": {
            "raw": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = '29'",
            "normalized": "SELECT T2.language\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Annul'\n  AND T1.number = '29'"
        },
        "generated_sql_query": {
            "raw": "SELECT st.language\nFROM public.cards c\nJOIN public.set_translations st ON c.\"setCode\" = st.\"setCode\"\nWHERE c.name = 'Annul' AND c.number = '29';",
            "normalized": "SELECT st.language\nFROM public.cards c\nJOIN public.set_translations st ON c.\"setCode\" = st.\"setCode\"\nWHERE c.name = 'Annul'\n  AND c.number = '29';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Name all the cards which have alternative language in Japanese.",
        "reference_sql_query": {
            "raw": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
            "normalized": "SELECT T1.name\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'Japanese'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name \nFROM public.cards c\nJOIN public.foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Japanese';",
            "normalized": "SELECT c.name\nFROM public.cards c\nJOIN public.foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Japanese';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T2.language = 'Chinese Simplified' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(T1.id)\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(*) FILTER (WHERE availability LIKE '%Chinese Simplified%')::FLOAT / COUNT(*)) * 100 AS percentage_chinese_simplified\nFROM \n    public.cards;",
            "normalized": "SELECT (COUNT(*) FILTER (\n                         WHERE availability LIKE '%Chinese Simplified%')::FLOAT / COUNT(*)) * 100 AS percentage_chinese_simplified\nFROM public.cards;"
        },
        "db_id": "card_games"
    },
    {
        "question": "List all the sets available in Italian translation. State the total number of cards per set.",
        "reference_sql_query": {
            "raw": "SELECT T1.name, T1.\"totalSetSize\" FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.\"setCode\" WHERE T2.language = 'Italian'",
            "normalized": "SELECT T1.name,\n       T1.\"totalSetSize\"\nFROM\nSETS AS T1\nINNER JOIN set_translations AS T2 ON T1.code = T2.\"setCode\"\nWHERE T2.language = 'Italian'"
        },
        "generated_sql_query": {
            "raw": "SELECT s.name AS set_name, st.language, COUNT(c.id) AS total_cards\nFROM sets s\nJOIN set_translations st ON s.code = st.setCode\nJOIN cards c ON s.code = c.setCode\nWHERE st.language = 'Italian'\nGROUP BY s.name, st.language;",
            "normalized": "SELECT s.name AS set_name,\n       st.language,\n       COUNT(c.id) AS total_cards\nFROM\nSETS s\nJOIN set_translations st ON s.code = st.setCode\nJOIN cards c ON s.code = c.setCode\nWHERE st.language = 'Italian'\nGROUP BY s.name,\n         st.language;"
        },
        "db_id": "card_games"
    },
    {
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
            "normalized": "SELECT COUNT(TYPE)\nFROM cards\nWHERE artist = 'Aaron Boyd'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT type) AS card_types_count\nFROM public.cards\nWHERE artist = 'Aaron Boyd';",
            "normalized": "SELECT COUNT(DISTINCT TYPE) AS card_types_count\nFROM public.cards\nWHERE artist = 'Aaron Boyd';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the keyword found on card 'Angel of Mercy'?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
            "normalized": "SELECT DISTINCT keywords\nFROM cards\nWHERE name = 'Angel of Mercy'"
        },
        "generated_sql_query": {
            "raw": "SELECT keywords \nFROM public.cards \nWHERE name = 'Angel of Mercy';",
            "normalized": "SELECT keywords\nFROM public.cards\nWHERE name = 'Angel of Mercy';"
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards have infinite power?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(*) FROM cards WHERE power = '*'",
            "normalized": "SELECT COUNT(*)\nFROM cards\nWHERE power = '*'"
        },
        "generated_sql_query": {
            "raw": "Error running intermediate SQL: You need to connect to a database first by running vn.connect_to_snowflake(), vn.connect_to_postgres(), similar function, or manually set vn.run_sql",
            "normalized": "Error running intermediate SQL: You need TO CONNECT TO a DATABASE FIRST BY running vn.connect_to_snowflake(),\n                                                                           vn.connect_to_postgres(),\n                                                                           SIMILAR FUNCTION,\nOR manually\nSET vn.run_sql"
        },
        "db_id": "card_games"
    },
    {
        "question": "What type of promotion is of card 'Duress'?",
        "reference_sql_query": {
            "raw": "SELECT \"promoTypes\" FROM cards WHERE name = 'Duress' AND \"promoTypes\" IS NOT NULL",
            "normalized": "SELECT \"promoTypes\"\nFROM cards\nWHERE name = 'Duress'\n  AND \"promoTypes\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT \"promoTypes\" \nFROM public.cards \nWHERE name = 'Duress';",
            "normalized": "SELECT \"promoTypes\"\nFROM public.cards\nWHERE name = 'Duress';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the border color of card \"Ancestor's Chosen\"?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT \"borderColor\" FROM cards WHERE name = 'Ancestor''s Chosen'",
            "normalized": "SELECT DISTINCT \"borderColor\"\nFROM cards\nWHERE name = 'Ancestor''s Chosen'"
        },
        "generated_sql_query": {
            "raw": "SELECT borderColor FROM public.cards WHERE name = 'Ancestor''s Chosen';",
            "normalized": "SELECT borderColor\nFROM public.cards\nWHERE name = 'Ancestor''s Chosen';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
        "reference_sql_query": {
            "raw": "SELECT \"originalType\" FROM cards WHERE name = 'Ancestor''s Chosen' AND \"originalType\" IS NOT NULL",
            "normalized": "SELECT \"originalType\"\nFROM cards\nWHERE name = 'Ancestor''s Chosen'\n  AND \"originalType\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT \"originalType\" \nFROM public.cards \nWHERE name = 'Ancestor''s Chosen';",
            "normalized": "SELECT \"originalType\"\nFROM public.cards\nWHERE name = 'Ancestor''s Chosen';"
        },
        "db_id": "card_games"
    },
    {
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "reference_sql_query": {
            "raw": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
            "normalized": "SELECT LANGUAGE\nFROM set_translations\nWHERE id IN\n    (SELECT id\n     FROM cards\n     WHERE name = 'Angel of Mercy')"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT st.language\nFROM public.cards c\nJOIN public.sets s ON c.\"setCode\" = s.code\nJOIN public.set_translations st ON s.code = st.\"setCode\"\nWHERE c.name = 'Angel of Mercy';",
            "normalized": "SELECT DISTINCT st.language\nFROM public.cards c\nJOIN public.sets s ON c.\"setCode\" = s.code\nJOIN public.set_translations st ON s.code = st.\"setCode\"\nWHERE c.name = 'Angel of Mercy';"
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.\"isTextless\" = 0",
            "normalized": "SELECT COUNT(DISTINCT T1.id)\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Restricted'\n  AND T1.\"isTextless\" = 0"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT l.uuid) \nFROM public.legalities l\nJOIN public.cards c ON l.uuid = c.uuid\nWHERE l.status = 'restricted' AND c.text IS NOT NULL;",
            "normalized": "SELECT COUNT(DISTINCT l.uuid)\nFROM public.legalities l\nJOIN public.cards c ON l.uuid = c.uuid\nWHERE l.status = 'restricted'\n  AND c.text IS NOT NULL;"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "reference_sql_query": {
            "raw": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
            "normalized": "SELECT T2.text\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Condemn'"
        },
        "generated_sql_query": {
            "raw": "SELECT r.text\nFROM public.rulings r\nJOIN public.cards c ON r.uuid = c.uuid\nWHERE c.name = 'Condemn';",
            "normalized": "SELECT r.text\nFROM public.rulings r\nJOIN public.cards c ON r.uuid = c.uuid\nWHERE c.name = 'Condemn';"
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.\"isStarter\" = 1",
            "normalized": "SELECT COUNT(DISTINCT T1.id)\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Restricted'\n  AND T1.\"isStarter\" = 1"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT l.uuid) AS restricted_card_count\nFROM public.legalities l\nJOIN public.cards c ON l.uuid = c.uuid\nWHERE l.status = 'restricted' AND c.\"isStarter\" = 1;",
            "normalized": "SELECT COUNT(DISTINCT l.uuid) AS restricted_card_count\nFROM public.legalities l\nJOIN public.cards c ON l.uuid = c.uuid\nWHERE l.status = 'restricted'\n  AND c.\"isStarter\" = 1;"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
            "normalized": "SELECT DISTINCT T2.status\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Cloudchaser Eagle'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine the status of the card \"Cloudchaser Eagle\" as there is no direct relationship or linking information between the `cards` table and the `status` table.",
            "normalized": "The provided context IS insufficient TO determine the status OF the card \"Cloudchaser Eagle\" AS there IS NO direct relationship\nOR linking information BETWEEN the `cards` TABLE AND the `status` table."
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the type of card \"Benalish Knight\"?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
            "normalized": "SELECT DISTINCT T1.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Benalish Knight'"
        },
        "generated_sql_query": {
            "raw": "SELECT type FROM public.cards WHERE name = 'Benalish Knight';",
            "normalized": "SELECT TYPE\nFROM public.cards\nWHERE name = 'Benalish Knight';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "reference_sql_query": {
            "raw": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
            "normalized": "SELECT T2.format\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Benalish Knight'"
        },
        "generated_sql_query": {
            "raw": "SELECT text \nFROM public.rulings \nWHERE uuid = (SELECT uuid FROM public.cards WHERE \"asciiName\" = 'Benalish Knight');",
            "normalized": "SELECT text\nFROM public.rulings\nWHERE UUID =\n    (SELECT UUID\n     FROM public.cards\n     WHERE \"asciiName\" = 'Benalish Knight');"
        },
        "db_id": "card_games"
    },
    {
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "reference_sql_query": {
            "raw": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
            "normalized": "SELECT T1.artist\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'Phyrexian'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT artist \nFROM public.cards \nWHERE \"asciiName\" = 'Phyrexian';",
            "normalized": "SELECT DISTINCT artist\nFROM public.cards\nWHERE \"asciiName\" = 'Phyrexian';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the percentage of borderless cards?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"borderColor\" = 'borderless' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(id) FROM cards",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"borderColor\" = 'borderless' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(id)\nFROM cards"
        },
        "generated_sql_query": {
            "raw": "The provided context does not specify a column that indicates whether a card is borderless. Therefore, it is not possible to generate a SQL query to determine the percentage of borderless cards.",
            "normalized": "The provided context does NOT specify a COLUMN that indicates whether a card IS borderless. Therefore,\n                                                                                it IS NOT possible TO generate a SQL query TO determine the percentage OF borderless cards."
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards that illusrtated in German have been reprinted?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.\"isReprint\" = 1",
            "normalized": "SELECT COUNT(T1.id)\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'German'\n  AND T1.\"isReprint\" = 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the language in which the cards were illustrated. There is also no column indicating the language of the illustration in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the LANGUAGE IN which the cards were illustrated. There IS also NO COLUMN indicating the LANGUAGE OF the illustration IN the given tables."
        },
        "db_id": "card_games"
    },
    {
        "question": "How many borderless cards are illustrated in Russian?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.\"borderColor\" = 'borderless' AND T2.language = 'Russian'",
            "normalized": "SELECT COUNT(T1.id)\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.\"borderColor\" = 'borderless'\n  AND T2.language = 'Russian'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the language in which the cards are illustrated or any indication of borderless cards in the tables. The `cards` table does have a `borderColor` column, but it does not specifically denote \"borderless\" cards, and there is no direct linkage to the `foreign_data` table to identify illustrations in Russian. Additional context or tables are needed to establish these connections.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the LANGUAGE IN which the cards ARE illustrated\nOR ANY indication OF borderless cards IN the tables. The `cards` TABLE does have a `borderColor` COLUMN,\n                                                                                                 but it does NOT specifically denote \"borderless\" cards,\nAND there IS NO direct linkage TO the `foreign_data` TABLE TO identify illustrations IN Russian. Additional context\nOR TABLES ARE needed TO establish these connections."
        },
        "db_id": "card_games"
    },
    {
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.\"isStorySpotlight\" = 1",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T2.language = 'French' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(T1.id)\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.\"isStorySpotlight\" = 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no direct information about which cards are Story Spotlight cards or how to identify them in the given tables. Additionally, there is no direct link between card languages and Story Spotlight attributes in the tables provided.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO direct information about which cards ARE Story Spotlight cards\nOR how TO identify them IN the given tables. Additionally,\n                                     there IS NO direct LINK BETWEEN card languages AND Story Spotlight attributes IN the TABLES provided."
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards are there with toughness of 99?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM cards WHERE toughness = '99'",
            "normalized": "SELECT COUNT(id)\nFROM cards\nWHERE toughness = '99'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.cards \nWHERE toughness = '99';",
            "normalized": "SELECT COUNT(*)\nFROM public.cards\nWHERE toughness = '99';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Name the cards that were illustrated by Aaron Boyd.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
            "normalized": "SELECT DISTINCT name\nFROM cards\nWHERE artist = 'Aaron Boyd'"
        },
        "generated_sql_query": {
            "raw": "SELECT name \nFROM public.cards \nWHERE artist = 'Aaron Boyd';",
            "normalized": "SELECT name\nFROM public.cards\nWHERE artist = 'Aaron Boyd';"
        },
        "db_id": "card_games"
    },
    {
        "question": "How many black border cards are only available on mtgo?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND \"borderColor\" = 'black'",
            "normalized": "SELECT COUNT(id)\nFROM cards\nWHERE availability = 'mtgo'\n  AND \"borderColor\" = 'black'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.cards \nWHERE \"borderColor\" = 'black' \nAND \"availability\" = 'mtgo'\nAND \"availability\" NOT LIKE '%paper%'\nAND \"availability\" NOT LIKE '%arena%'\nAND \"availability\" NOT LIKE '%mtgo,arena%'\nAND \"availability\" NOT LIKE '%paper,arena%'\nAND \"availability\" NOT LIKE '%paper,mtgo%'\nAND \"availability\" NOT LIKE '%paper,mtgo,arena%';",
            "normalized": "SELECT COUNT(*)\nFROM public.cards\nWHERE \"borderColor\" = 'black'\n  AND \"availability\" = 'mtgo'\n  AND \"availability\" NOT LIKE '%paper%'\n  AND \"availability\" NOT LIKE '%arena%'\n  AND \"availability\" NOT LIKE '%mtgo,arena%'\n  AND \"availability\" NOT LIKE '%paper,arena%'\n  AND \"availability\" NOT LIKE '%paper,mtgo%'\n  AND \"availability\" NOT LIKE '%paper,mtgo,arena%';"
        },
        "db_id": "card_games"
    },
    {
        "question": "List down all the card IDs with converted mana cost of 0.",
        "reference_sql_query": {
            "raw": "SELECT id FROM cards WHERE \"convertedManaCost\" = 0",
            "normalized": "SELECT id\nFROM cards\nWHERE \"convertedManaCost\" = 0"
        },
        "generated_sql_query": {
            "raw": "SELECT id FROM public.cards WHERE \"convertedManaCost\" = 0;",
            "normalized": "SELECT id\nFROM public.cards\nWHERE \"convertedManaCost\" = 0;"
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the card layout of cards with keyword of flying?",
        "reference_sql_query": {
            "raw": "SELECT layout FROM cards WHERE keywords = 'Flying'",
            "normalized": "SELECT layout\nFROM cards\nWHERE keywords = 'Flying'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT layout\nFROM public.cards\nWHERE keywords LIKE '%flying%'",
            "normalized": "SELECT DISTINCT layout\nFROM public.cards\nWHERE keywords LIKE '%flying%'"
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM cards WHERE \"originalType\" = 'Summon - Angel' AND subtypes != 'Angel'",
            "normalized": "SELECT COUNT(id)\nFROM cards\nWHERE \"originalType\" = 'Summon - Angel'\n  AND subtypes != 'Angel'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM public.cards\nWHERE \"originalType\" = 'Summon - Angel' \nAND subtypes IS NOT NULL \nAND subtypes <> 'Angel';",
            "normalized": "SELECT COUNT(*)\nFROM public.cards\nWHERE \"originalType\" = 'Summon - Angel'\n  AND subtypes IS NOT NULL\n  AND subtypes <> 'Angel';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
        "reference_sql_query": {
            "raw": "SELECT id FROM cards WHERE \"cardKingdomId\" IS NOT NULL AND \"cardKingdomFoilId\" IS NOT NULL",
            "normalized": "SELECT id\nFROM cards\nWHERE \"cardKingdomId\" IS NOT NULL\n  AND \"cardKingdomFoilId\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "The provided context does not have sufficient information to determine which foiled cards are incredibly powerful when paired with non-foiled cards. The context includes the `cards` table with a `hasFoil` column indicating if a card has a foil version, but it does not include any criteria or attributes to evaluate whether a card is \"incredibly powerful\" when paired with another card. Additional information or context is required to generate the desired SQL query.",
            "normalized": "The provided context does NOT have sufficient information TO determine which foiled cards ARE incredibly powerful WHEN paired WITH non-foiled cards. The context includes the `cards` TABLE WITH a `hasFoil` COLUMN indicating IF a card has a foil VERSION,\n                                                                                                                                                                                                                                                    but it does NOT INCLUDE ANY criteria\nOR attributes TO evaluate whether a card IS \"incredibly powerful\" WHEN paired WITH another card. Additional information\nOR context IS required TO generate the desired SQL query."
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the cards belong to duel deck a? List the ID.",
        "reference_sql_query": {
            "raw": "SELECT id FROM cards WHERE \"duelDeck\" = 'a'",
            "normalized": "SELECT id\nFROM cards\nWHERE \"duelDeck\" = 'a'"
        },
        "generated_sql_query": {
            "raw": "SELECT id \nFROM public.cards \nWHERE \"duelDeck\" = 'a';",
            "normalized": "SELECT id\nFROM public.cards\nWHERE \"duelDeck\" = 'a';"
        },
        "db_id": "card_games"
    },
    {
        "question": "List down the name of artists for cards in Chinese Simplified.",
        "reference_sql_query": {
            "raw": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
            "normalized": "SELECT T1.artist\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'Chinese Simplified'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT artist \nFROM public.cards \nWHERE availability LIKE '%Chinese Simplified%'",
            "normalized": "SELECT DISTINCT artist\nFROM public.cards\nWHERE availability LIKE '%Chinese Simplified%'"
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the cards that only available in paper and Japanese language?",
        "reference_sql_query": {
            "raw": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
            "normalized": "SELECT T1.name\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.availability = 'paper'\n  AND T2.language = 'Japanese'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the query because it doesn't contain any columns related to the availability format (such as paper) or the language of the cards in the available tables.",
            "normalized": "The provided context IS insufficient TO generate the query because it doesn't contain ANY columns related TO the availability format (such AS paper)\nOR the LANGUAGE OF the cards IN the available tables."
        },
        "db_id": "card_games"
    },
    {
        "question": "How many of the banned cards are white border?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.\"borderColor\" = 'white'",
            "normalized": "SELECT COUNT(T1.id)\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Banned'\n  AND T1.\"borderColor\" = 'white'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain sufficient information to generate a SQL query to answer the question about banned cards with a white border. The context does not include any information about banned cards.",
            "normalized": "The provided context does NOT contain sufficient information TO generate a SQL query TO answer the question about banned cards WITH a white border. The context does NOT INCLUDE ANY information about banned cards."
        },
        "db_id": "card_games"
    },
    {
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "reference_sql_query": {
            "raw": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
            "normalized": "SELECT T1.uuid,\n       T3.language\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nINNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'legacy'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.uuid, fd.language\nFROM public.cards c\nJOIN public.legalities l ON c.uuid = l.uuid\nJOIN public.foreign_data fd ON c.uuid = fd.uuid\nWHERE l.format = 'Legacy';",
            "normalized": "SELECT c.uuid,\n       fd.language\nFROM public.cards c\nJOIN public.legalities l ON c.uuid = l.uuid\nJOIN public.foreign_data fd ON c.uuid = fd.uuid\nWHERE l.format = 'Legacy';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Write down the ruling of Beacon of Immortality.",
        "reference_sql_query": {
            "raw": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
            "normalized": "SELECT T2.text\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Beacon of Immortality'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about the ruling of \"Beacon of Immortality.\" The `rulings` table seems relevant, but without specific knowledge that \"Beacon of Immortality\" is included in the `text` or `uuid` columns, a direct query cannot be generated. \n\nTo proceed, we would need to know how \"Beacon of Immortality\" is referenced within the `rulings` table.",
            "normalized": "The provided context does NOT contain information about the ruling OF \"Beacon of Immortality.\" The `rulings` TABLE seems relevant,\n                                                                                                                   but WITHOUT SPECIFIC knowledge that \"Beacon of Immortality\" IS included IN the `text`\nOR `uuid` columns,\n   a direct query cannot be generated. TO proceed,\n                                          we would need TO know how \"Beacon of Immortality\" IS referenced within the `rulings` table."
        },
        "db_id": "card_games"
    },
    {
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.\"frameVersion\" = 'future'",
            "normalized": "SELECT COUNT(T1.id)\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T1.\"frameVersion\" = 'future'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT c.uuid) AS card_count, l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.\"frameVersion\" = 'future'\nGROUP BY l.status;",
            "normalized": "SELECT COUNT(DISTINCT c.uuid) AS card_count,\n       l.status\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.\"frameVersion\" = 'future'\nGROUP BY l.status;"
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "reference_sql_query": {
            "raw": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE \"setCode\" = 'OGW' )",
            "normalized": "SELECT id,\n       colors\nFROM cards\nWHERE id IN\n    (SELECT id\n     FROM set_translations\n     WHERE \"setCode\" = 'OGW')"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name, cl.colour\nFROM public.cards c\nJOIN public.colour cl ON c.id = cl.id\nWHERE c.setCode = 'OGW';",
            "normalized": "SELECT c.name,\n       cl.colour\nFROM public.cards c\nJOIN public.colour cl ON c.id = cl.id\nWHERE c.setCode = 'OGW';"
        },
        "db_id": "card_games"
    },
    {
        "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
        "reference_sql_query": {
            "raw": "SELECT id, language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE \"convertedManaCost\" = 5 ) AND \"setCode\" = '10E'",
            "normalized": "SELECT id,\n       LANGUAGE\nFROM set_translations\nWHERE id IN\n    (SELECT id\n     FROM cards\n     WHERE \"convertedManaCost\" = 5)\n  AND \"setCode\" = '10E'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name AS card_name, st.language\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.setCode = '10E' AND c.convertedManaCost = 5;",
            "normalized": "SELECT c.name AS card_name,\n       st.language\nFROM cards c\nJOIN set_translations st ON c.setCode = st.setCode\nWHERE c.setCode = '10E'\n  AND c.convertedManaCost = 5;"
        },
        "db_id": "card_games"
    },
    {
        "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "reference_sql_query": {
            "raw": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.\"originalType\" = 'Creature - Elf'",
            "normalized": "SELECT T1.id,\n       T2.date\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.\"originalType\" = 'Creature - Elf'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name, r.date AS ruling_date\nFROM public.cards c\nJOIN public.rulings r ON c.uuid = r.uuid\nWHERE c.\"originalType\" = 'Creature - Elf';",
            "normalized": "SELECT c.name,\n       r.date AS ruling_date\nFROM public.cards c\nJOIN public.rulings r ON c.uuid = r.uuid\nWHERE c.\"originalType\" = 'Creature - Elf';"
        },
        "db_id": "card_games"
    },
    {
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "reference_sql_query": {
            "raw": "SELECT \"DisplayName\" FROM users WHERE \"DisplayName\" IN ('Harlan', 'Jarrod Dixon') AND \"Reputation\" = ( SELECT MAX(\"Reputation\") FROM users WHERE \"DisplayName\" IN ('Harlan', 'Jarrod Dixon') )",
            "normalized": "SELECT \"DisplayName\"\nFROM users\nWHERE \"DisplayName\" IN ('Harlan',\n                        'Jarrod Dixon')\n  AND \"Reputation\" =\n    (SELECT MAX(\"Reputation\")\n     FROM users\n     WHERE \"DisplayName\" IN ('Harlan',\n                             'Jarrod Dixon'))"
        },
        "generated_sql_query": {
            "raw": "SELECT \"DisplayName\", \"Reputation\"\nFROM public.users\nWHERE \"DisplayName\" IN ('Harlan', 'Jarrod Dixon')\nORDER BY \"Reputation\" DESC;",
            "normalized": "SELECT \"DisplayName\",\n       \"Reputation\"\nFROM public.users\nWHERE \"DisplayName\" IN ('Harlan',\n                        'Jarrod Dixon')\nORDER BY \"Reputation\" DESC;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Please list the display names of all the users whose accounts were created in the year 2011.",
        "reference_sql_query": {
            "raw": "SELECT \"DisplayName\" FROM users WHERE EXTRACT(YEAR FROM \"CreationDate\") = '2011'",
            "normalized": "SELECT \"DisplayName\"\nFROM users\nWHERE EXTRACT(YEAR\n              FROM \"CreationDate\") = '2011'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"DisplayName\"\nFROM public.users\nWHERE EXTRACT(YEAR FROM \"CreationDate\") = 2011;",
            "normalized": "SELECT \"DisplayName\"\nFROM public.users\nWHERE EXTRACT(YEAR\n              FROM \"CreationDate\") = 2011;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "How many users last accessed the website after 2014/9/1?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"Id\") FROM users WHERE date(\"LastAccessDate\") > '2014-09-01'",
            "normalized": "SELECT COUNT(\"Id\")\nFROM users\nWHERE date(\"LastAccessDate\") > '2014-09-01'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.users \nWHERE \"LastAccessDate\" > '2014-09-01';",
            "normalized": "SELECT COUNT(*)\nFROM public.users\nWHERE \"LastAccessDate\" > '2014-09-01';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the display name of the user who has the most number of views?",
        "reference_sql_query": {
            "raw": "SELECT \"DisplayName\" FROM users WHERE \"Views\" = ( SELECT MAX(\"Views\") FROM users )",
            "normalized": "SELECT \"DisplayName\"\nFROM users\nWHERE \"Views\" =\n    (SELECT MAX(\"Views\")\n     FROM users)"
        },
        "generated_sql_query": {
            "raw": "SELECT \"DisplayName\"\nFROM public.users\nORDER BY \"Views\" DESC\nLIMIT 1;",
            "normalized": "SELECT \"DisplayName\"\nFROM public.users\nORDER BY \"Views\" DESC\nLIMIT 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Among the users who have more than 100 upvotes, how many of them have more then 1 downvotes?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"Id\") FROM users WHERE \"UpVotes\" > 100 AND \"DownVotes\" > 1",
            "normalized": "SELECT COUNT(\"Id\")\nFROM users\nWHERE \"UpVotes\" > 100\n  AND \"DownVotes\" > 1"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.users \nWHERE UpVotes > 100 AND DownVotes > 1;",
            "normalized": "SELECT COUNT(*)\nFROM public.users\nWHERE UpVotes > 100\n  AND DownVotes > 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "How many users with more than 10 views created their account after the year 2013?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"Id\") FROM users WHERE EXTRACT(YEAR FROM \"CreationDate\") > '2013' AND \"Views\" > 10",
            "normalized": "SELECT COUNT(\"Id\")\nFROM users\nWHERE EXTRACT(YEAR\n              FROM \"CreationDate\") > '2013'\n  AND \"Views\" > 10"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.users \nWHERE Views > 10 AND CreationDate > '2013-12-31';",
            "normalized": "SELECT COUNT(*)\nFROM public.users\nWHERE VIEWS > 10\n  AND CreationDate > '2013-12-31';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "How many posts does the user csgillespie own?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM public.posts p\nJOIN public.users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';",
            "normalized": "SELECT COUNT(*)\nFROM public.posts p\nJOIN public.users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Please list the titles of the posts owned by the user csgillespie?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Title\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT T1.\"Title\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "SELECT p.Title \nFROM public.posts p\nJOIN public.users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';",
            "normalized": "SELECT p.Title\nFROM public.posts p\nJOIN public.users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Who is the owner of the post \"Eliciting priors from experts\"?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"DisplayName\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T1.\"Title\" = 'Eliciting priors from experts'",
            "normalized": "SELECT T2.\"DisplayName\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T1.\"Title\" = 'Eliciting priors from experts'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"OwnerDisplayName\"\nFROM public.posts\nWHERE \"Title\" = 'Eliciting priors from experts';",
            "normalized": "SELECT \"OwnerDisplayName\"\nFROM public.posts\nWHERE \"Title\" = 'Eliciting priors from experts';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the title of the post that is owned by csgillespie and has the highest popularity?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Title\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie' ORDER BY T1.\"ViewCount\" DESC LIMIT 1",
            "normalized": "SELECT T1.\"Title\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'\nORDER BY T1.\"ViewCount\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT Title \nFROM public.posts \nWHERE OwnerDisplayName = 'csgillespie' \nORDER BY ViewCount DESC \nLIMIT 1;",
            "normalized": "SELECT Title\nFROM public.posts\nWHERE OwnerDisplayName = 'csgillespie'\nORDER BY ViewCount DESC\nLIMIT 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the display name of the user who is the owner of the most valuable post?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"DisplayName\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" ORDER BY T1.\"FavoriteCount\" DESC LIMIT 1",
            "normalized": "SELECT T2.\"DisplayName\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nORDER BY T1.\"FavoriteCount\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT u.DisplayName\nFROM public.posts p\nJOIN public.users u ON p.OwnerUserId = u.Id\nORDER BY p.Score DESC\nLIMIT 1;",
            "normalized": "SELECT u.DisplayName\nFROM public.posts p\nJOIN public.users u ON p.OwnerUserId = u.Id\nORDER BY p.Score DESC\nLIMIT 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the total number of comments of all the posts owned by csgillespie?",
        "reference_sql_query": {
            "raw": "SELECT SUM(T1.\"CommentCount\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT SUM(T1.\"CommentCount\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "SELECT SUM(CommentCount) AS TotalComments\nFROM posts\nWHERE OwnerDisplayName = 'csgillespie';",
            "normalized": "SELECT SUM(CommentCount) AS TotalComments\nFROM posts\nWHERE OwnerDisplayName = 'csgillespie';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "For the post that got the most number of answers owned by csgillespie, how many answers did it get?",
        "reference_sql_query": {
            "raw": "SELECT MAX(T1.\"AnswerCount\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT MAX(T1.\"AnswerCount\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(AnswerCount) AS MostAnswers\nFROM posts\nWHERE OwnerDisplayName = 'csgillespie';",
            "normalized": "SELECT MAX(AnswerCount) AS MostAnswers\nFROM posts\nWHERE OwnerDisplayName = 'csgillespie';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"DisplayName\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"LastEditorUserId\" = T2.\"Id\" WHERE T1.\"Title\" = 'Examples for teaching: Correlation does not mean causation'",
            "normalized": "SELECT T2.\"DisplayName\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"LastEditorUserId\" = T2.\"Id\"\nWHERE T1.\"Title\" = 'Examples for teaching: Correlation does not mean causation'"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"LastEditorDisplayName\"\nFROM public.posts p\nWHERE p.\"Title\" = 'Examples for teaching: Correlation does not mean causation';",
            "normalized": "SELECT p.\"LastEditorDisplayName\"\nFROM public.posts p\nWHERE p.\"Title\" = 'Examples for teaching: Correlation does not mean causation';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Among the posts owned by csgillespie, how many of them are root posts?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie' AND T1.\"ParentId\" IS NULL",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'\n  AND T1.\"ParentId\" IS NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS root_post_count\nFROM posts\nWHERE OwnerDisplayName = 'csgillespie' AND ParentId IS NULL;",
            "normalized": "SELECT COUNT(*) AS root_post_count\nFROM posts\nWHERE OwnerDisplayName = 'csgillespie'\n  AND ParentId IS NULL;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Please list the display names of all the users who owns a post that is well-finished.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"DisplayName\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T1.\"ClosedDate\" IS NOT NULL",
            "normalized": "SELECT T2.\"DisplayName\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T1.\"ClosedDate\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "It seems that the context provided does not define what constitutes a \"well-finished\" post. To generate the SQL query, we need a specific criterion for what makes a post well-finished, such as a high score, a certain number of views, or another measurable attribute. Without this information, the query cannot be accurately generated. Please provide the specific criteria for a \"well-finished\" post.",
            "normalized": "It seems that the context provided does NOT DEFINE what constitutes a \"well-finished\" post. TO generate the SQL query,\n                                                                                                                we need a SPECIFIC criterion\nFOR what makes a post well-finished,\n                      such AS a high score,\n                                     a certain number OF VIEWS,\nOR another measurable attribute. WITHOUT this information,\n                                         the query cannot be accurately generated. Please provide the SPECIFIC criteria\nFOR a \"well-finished\" post."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Among the posts owned by an elder user, how many of them have a score of over 19?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T1.\"Score\" >= 20 AND T2.\"Age\" > 65",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T1.\"Score\" >= 20\n  AND T2.\"Age\" > 65"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query. The available tables do not include a direct way to determine if a user is an \"elder user\". Additional information or criteria defining \"elder user\" is needed to construct the query.",
            "normalized": "The provided context IS insufficient TO generate the SQL query. The available TABLES DO NOT INCLUDE a direct way TO determine IF a USER IS an \"elder user\". Additional information\nOR criteria defining \"elder user\" IS needed TO construct the query."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the location of the owner of the post \"Eliciting priors from experts\"?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Location\" FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T1.\"Title\" = 'Eliciting priors from experts'",
            "normalized": "SELECT T2.\"Location\"\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T1.\"Title\" = 'Eliciting priors from experts'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about the location of the owner of a post. Therefore, it can't be generated.",
            "normalized": "The provided context does NOT contain information about the LOCATION OF the OWNER OF a post. Therefore,\n                                                                                     it can't be generated."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "From which post is the tag \"bayesian\" excerpted from? Please give the body of the post.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Body\" FROM tags AS T1 INNER JOIN posts AS T2 ON T2.\"Id\" = T1.\"ExcerptPostId\" WHERE T1.\"TagName\" = 'bayesian'",
            "normalized": "SELECT T2.\"Body\"\nFROM tags AS T1\nINNER JOIN posts AS T2 ON T2.\"Id\" = T1.\"ExcerptPostId\"\nWHERE T1.\"TagName\" = 'bayesian'"
        },
        "generated_sql_query": {
            "raw": "SELECT p.Body\nFROM posts p\nJOIN tags t ON p.Id = t.ExcerptPostId\nWHERE t.TagName = 'bayesian';",
            "normalized": "SELECT p.Body\nFROM posts p\nJOIN tags t ON p.Id = t.ExcerptPostId\nWHERE t.TagName = 'bayesian';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
        "reference_sql_query": {
            "raw": "SELECT \"Body\" FROM posts WHERE \"Id\" = ( SELECT \"ExcerptPostId\" FROM tags ORDER BY \"Count\" DESC LIMIT 1 )",
            "normalized": "SELECT \"Body\"\nFROM posts\nWHERE \"Id\" =\n    (SELECT \"ExcerptPostId\"\n     FROM tags\n     ORDER BY \"Count\" DESC\n     LIMIT 1)"
        },
        "generated_sql_query": {
            "raw": "SELECT p.Body\nFROM public.tags t\nJOIN public.posts p ON t.ExcerptPostId = p.Id\nORDER BY t.Count DESC\nLIMIT 1;",
            "normalized": "SELECT p.Body\nFROM public.tags t\nJOIN public.posts p ON t.ExcerptPostId = p.Id\nORDER BY t.Count DESC\nLIMIT 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "How many badges has the user csgillespie obtained?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM badges AS T1 INNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because the necessary information to link a user display name, such as \"csgillespie\", to a user ID is missing. The query would require joining the `users` table with the `badges` table using the `UserId`, but there is no direct reference to display names in the badges context provided.",
            "normalized": "The provided context IS insufficient because the necessary information TO LINK a USER display name,\n                                                                                      such AS \"csgillespie\",\n                                                                                      TO a USER ID IS missing. The query would require joining the `users` TABLE WITH the `badges` TABLE USING the `UserId`,\n                                                                                                                                                                                               but there IS NO direct reference TO display NAMES IN the badges context provided."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Please list the names of the badges obtained by csgillespie.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Name\"FROM badges AS T1 INNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT T1.\"Name\"\nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "SELECT b.Name\nFROM badges b\nJOIN posts p ON b.UserId = p.OwnerUserId\nWHERE p.OwnerDisplayName = 'csgillespie';",
            "normalized": "SELECT b.Name\nFROM badges b\nJOIN posts p ON b.UserId = p.OwnerUserId\nWHERE p.OwnerDisplayName = 'csgillespie';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Among the badges obtained by csgillespie, how many of them were obtained in the year 2011?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM badges AS T1 INNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\" WHERE EXTRACT(YEAR FROM T1.\"Date\") = '2011' AND T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\"\nWHERE EXTRACT(YEAR\n              FROM T1.\"Date\") = '2011'\n  AND T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not include information about the relationship between user names such as \"csgillespie\" and the \"UserId\" in the badges table. Therefore, it is not possible to generate the SQL query to answer the question.",
            "normalized": "The provided context does NOT INCLUDE information about the relationship BETWEEN USER NAMES such AS \"csgillespie\" AND the \"UserId\" IN the badges table. Therefore,\n                                                                                                                                                 it IS NOT possible TO generate the SQL query TO answer the question."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the display name of the user who has obtained the most number of badges?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"DisplayName\" FROM badges AS T1 INNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\" GROUP BY T2.\"DisplayName\" ORDER BY COUNT(T1.\"Id\") DESC LIMIT 1",
            "normalized": "SELECT T2.\"DisplayName\"\nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\"\nGROUP BY T2.\"DisplayName\"\nORDER BY COUNT(T1.\"Id\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT u.DisplayName\nFROM public.users u\nJOIN (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM public.badges\n    GROUP BY UserId\n    ORDER BY BadgeCount DESC\n    LIMIT 1\n) AS b ON u.Id = b.UserId;",
            "normalized": "SELECT u.DisplayName\nFROM public.users u\nJOIN\n  (SELECT UserId,\n          COUNT(*) AS BadgeCount\n   FROM public.badges\n   GROUP BY UserId\n   ORDER BY BadgeCount DESC\n   LIMIT 1) AS b ON u.Id = b.UserId;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the average score of the posts owned by the user csgillespie?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T1.\"Score\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T2.\"DisplayName\" = 'csgillespie'",
            "normalized": "SELECT AVG(T1.\"Score\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T2.\"DisplayName\" = 'csgillespie'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(p.\"Score\") AS average_score\nFROM public.posts p\nJOIN public.users u ON p.\"OwnerUserId\" = u.\"Id\"\nWHERE u.\"DisplayName\" = 'csgillespie';",
            "normalized": "SELECT AVG(p.\"Score\") AS average_score\nFROM public.posts p\nJOIN public.users u ON p.\"OwnerUserId\" = u.\"Id\"\nWHERE u.\"DisplayName\" = 'csgillespie';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(T1.\"Id\") AS DOUBLE PRECISION) / COUNT(DISTINCT T2.\"DisplayName\") FROM badges AS T1 INNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\" WHERE T2.\"Views\" > 200",
            "normalized": "SELECT CAST(COUNT(T1.\"Id\") AS DOUBLE PRECISION) / COUNT(DISTINCT T2.\"DisplayName\")\nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.\"UserId\" = T2.\"Id\"\nWHERE T2.\"Views\" > 200"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(badge_count) AS average_badges\nFROM (\n    SELECT u.Id, COUNT(b.Id) AS badge_count\n    FROM public.users u\n    JOIN public.badges b ON u.Id = b.UserId\n    WHERE u.Views > 200\n    GROUP BY u.Id\n) AS user_badge_counts;",
            "normalized": "SELECT AVG(badge_count) AS average_badges\nFROM\n  (SELECT u.Id,\n          COUNT(b.Id) AS badge_count\n   FROM public.users u\n   JOIN public.badges b ON u.Id = b.UserId\n   WHERE u.Views > 200\n   GROUP BY u.Id) AS user_badge_counts;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T2.\"Age\" > 65 THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(T1.\"Id\") FROM posts AS T1 INNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\" WHERE T1.\"Score\" > 5",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T2.\"Age\" > 65 THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(T1.\"Id\")\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.\"OwnerUserId\" = T2.\"Id\"\nWHERE T1.\"Score\" > 5"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no definition of what constitutes an \"elder user\" in the given tables. We need additional information or criteria to determine which users are considered elder users, such as a specific age range or account creation date threshold.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO definition OF what constitutes an \"elder user\" IN the given tables. We need additional information\nOR criteria TO determine which users ARE considered elder users,\n                                                          such AS a SPECIFIC age RANGE\nOR ACCOUNT creation date threshold."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "How many votes did the user No.58 take on 2010/7/19?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"Id\") FROM votes WHERE \"UserId\" = 58 AND \"CreationDate\" = '2010-07-19'",
            "normalized": "SELECT COUNT(\"Id\")\nFROM votes\nWHERE \"UserId\" = 58\n  AND \"CreationDate\" = '2010-07-19'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS vote_count\nFROM votes\nWHERE UserId = 58 AND CreationDate = '2010-07-19';",
            "normalized": "SELECT COUNT(*) AS vote_count\nFROM votes\nWHERE UserId = 58\n  AND CreationDate = '2010-07-19';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Indicate the creation date of the maximum number of votes.",
        "reference_sql_query": {
            "raw": "SELECT \"CreationDate\" FROM votes GROUP BY \"CreationDate\" ORDER BY COUNT(\"Id\") DESC LIMIT 1",
            "normalized": "SELECT \"CreationDate\"\nFROM votes\nGROUP BY \"CreationDate\"\nORDER BY COUNT(\"Id\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT \"CreationDate\", COUNT(*) as vote_count\nFROM public.votes\nGROUP BY \"CreationDate\"\nORDER BY vote_count DESC\nLIMIT 1;",
            "normalized": "SELECT \"CreationDate\",\n       COUNT(*) AS vote_count\nFROM public.votes\nGROUP BY \"CreationDate\"\nORDER BY vote_count DESC\nLIMIT 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Give the number of \"Revival\" badges.",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"Id\") FROM badges WHERE \"Name\" = 'Revival'",
            "normalized": "SELECT COUNT(\"Id\")\nFROM badges\nWHERE \"Name\" = 'Revival'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.badges \nWHERE \"Name\" = 'Revival';",
            "normalized": "SELECT COUNT(*)\nFROM public.badges\nWHERE \"Name\" = 'Revival';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the title for the post which got the highest score comment?",
        "reference_sql_query": {
            "raw": "SELECT \"Title\" FROM posts WHERE \"Id\" = ( SELECT \"PostId\" FROM comments ORDER BY \"Score\" DESC LIMIT 1 )",
            "normalized": "SELECT \"Title\"\nFROM posts\nWHERE \"Id\" =\n    (SELECT \"PostId\"\n     FROM comments\n     ORDER BY \"Score\" DESC\n     LIMIT 1)"
        },
        "generated_sql_query": {
            "raw": "SELECT p.Title\nFROM public.posts p\nJOIN public.comments c ON p.Id = c.PostId\nWHERE c.Score = (SELECT MAX(Score) FROM public.comments);",
            "normalized": "SELECT p.Title\nFROM public.posts p\nJOIN public.comments c ON p.Id = c.PostId\nWHERE c.Score =\n    (SELECT MAX(Score)\n     FROM public.comments);"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "For the post which got 1910 view counts, how many comments does it get?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM posts AS T1 INNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"PostId\" WHERE T1.\"ViewCount\" = 1910",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM posts AS T1\nINNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"PostId\"\nWHERE T1.\"ViewCount\" = 1910"
        },
        "generated_sql_query": {
            "raw": "SELECT p.Id, p.ViewCount, p.CommentCount\nFROM public.posts p\nWHERE p.ViewCount = 1910;",
            "normalized": "SELECT p.Id,\n       p.ViewCount,\n       p.CommentCount\nFROM public.posts p\nWHERE p.ViewCount = 1910;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"FavoriteCount\" FROM posts AS T1 INNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"PostId\" WHERE T2.\"CreationDate\" = '2014-04-23 20:29:39.0' AND T2.\"UserId\" = 3025",
            "normalized": "SELECT T1.\"FavoriteCount\"\nFROM posts AS T1\nINNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"PostId\"\nWHERE T2.\"CreationDate\" = '2014-04-23 20:29:39.0'\n  AND T2.\"UserId\" = 3025"
        },
        "generated_sql_query": {
            "raw": "SELECT p.FavoriteCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE c.UserId = 3025\n  AND c.CreationDate = '2014-04-23 20:29:39';",
            "normalized": "SELECT p.FavoriteCount\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nWHERE c.UserId = 3025\n  AND c.CreationDate = '2014-04-23 20:29:39';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Give the only one comment text of the post with parent id 107829.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Text\" FROM posts AS T1 INNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"PostId\" WHERE T1.\"ParentId\" = 107829 AND T1.\"CommentCount\" = 1",
            "normalized": "SELECT T2.\"Text\"\nFROM posts AS T1\nINNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"PostId\"\nWHERE T1.\"ParentId\" = 107829\n  AND T1.\"CommentCount\" = 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.\"Text\"\nFROM public.comments c\nJOIN public.posts p ON c.\"PostId\" = p.\"Id\"\nWHERE p.\"ParentId\" = 107829\nLIMIT 1;",
            "normalized": "SELECT c.\"Text\"\nFROM public.comments c\nJOIN public.posts p ON c.\"PostId\" = p.\"Id\"\nWHERE p.\"ParentId\" = 107829\nLIMIT 1;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "reference_sql_query": {
            "raw": "SELECT CASE WHEN T2.\"ClosedDate\" IS NULL THEN 'NOT well-finished' ELSE 'well-finished' END AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.\"PostId\" = T2.\"Id\" WHERE T1.\"UserId\" = 23853 AND T1.\"CreationDate\" = '2013-07-12 09:08:18.0'",
            "normalized": "SELECT CASE\n           WHEN T2.\"ClosedDate\" IS NULL THEN 'NOT well-finished'\n           ELSE 'well-finished'\n       END AS resylt\nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.\"PostId\" = T2.\"Id\"\nWHERE T1.\"UserId\" = 23853\n  AND T1.\"CreationDate\" = '2013-07-12 09:08:18.0'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine whether the post was well-finished. The context does not define what qualifies a post as \"well-finished\" and there is no specific column or criteria provided to evaluate this. Additional information or criteria for what constitutes a \"well-finished\" post is needed.",
            "normalized": "The provided context IS insufficient TO determine whether the post was well-finished. The context does NOT DEFINE what qualifies a post AS \"well-finished\"\nAND there IS NO SPECIFIC COLUMN\nOR criteria provided TO evaluate this. Additional information\nOR criteria\nFOR what constitutes a \"well-finished\" post IS needed."
        },
        "db_id": "codebase_community"
    },
    {
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Reputation\" FROM users AS T1 INNER JOIN posts AS T2 ON T1.\"Id\" = T2.\"OwnerUserId\" WHERE T2.\"Id\" = 65041",
            "normalized": "SELECT T1.\"Reputation\"\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.\"Id\" = T2.\"OwnerUserId\"\nWHERE T2.\"Id\" = 65041"
        },
        "generated_sql_query": {
            "raw": "SELECT u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Id = 65041;",
            "normalized": "SELECT u.Reputation\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE p.Id = 65041;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "For the user with the display name of \"Tiago Pasqualini\", how many posts did he/she own?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM users AS T1 INNER JOIN posts AS T2 ON T1.\"Id\" = T2.\"OwnerUserId\" WHERE T1.\"DisplayName\" = 'Tiago Pasqualini'",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.\"Id\" = T2.\"OwnerUserId\"\nWHERE T1.\"DisplayName\" = 'Tiago Pasqualini'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS post_count\nFROM public.posts\nJOIN public.users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName = 'Tiago Pasqualini';",
            "normalized": "SELECT COUNT(*) AS post_count\nFROM public.posts\nJOIN public.users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName = 'Tiago Pasqualini';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Provide the display name of the user who made the vote No.6347.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"DisplayName\" FROM users AS T1 INNER JOIN votes AS T2 ON T1.\"Id\" = T2.\"UserId\" WHERE T2.\"Id\" = 6347",
            "normalized": "SELECT T1.\"DisplayName\"\nFROM users AS T1\nINNER JOIN votes AS T2 ON T1.\"Id\" = T2.\"UserId\"\nWHERE T2.\"Id\" = 6347"
        },
        "generated_sql_query": {
            "raw": "SELECT u.DisplayName\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.Id = 6347;",
            "normalized": "SELECT u.DisplayName\nFROM votes v\nJOIN users u ON v.UserId = u.Id\nWHERE v.Id = 6347;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Give the number of votes for the post about data visualization.",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"Id\") FROM posts AS T1 INNER JOIN votes AS T2 ON T1.\"Id\" = T2.\"PostId\" WHERE T1.\"Title\" LIKE '%data visualization%'",
            "normalized": "SELECT COUNT(T1.\"Id\")\nFROM posts AS T1\nINNER JOIN votes AS T2 ON T1.\"Id\" = T2.\"PostId\"\nWHERE T1.\"Title\" LIKE '%data visualization%'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS NumberOfVotes\nFROM votes\nWHERE PostId IN (\n    SELECT Id\n    FROM posts\n    WHERE Title LIKE '%data visualization%'\n);",
            "normalized": "SELECT COUNT(*) AS NumberOfVotes\nFROM votes\nWHERE PostId IN\n    (SELECT Id\n     FROM posts\n     WHERE Title LIKE '%data visualization%');"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "For the user whose display name is \"DatEpicCoderGuyWhoPrograms\", what is his/her badge's name?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Name\" FROM users AS T1 INNER JOIN badges AS T2 ON T1.\"Id\" = T2.\"UserId\" WHERE T1.\"DisplayName\" = 'DatEpicCoderGuyWhoPrograms'",
            "normalized": "SELECT T2.\"Name\"\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.\"Id\" = T2.\"UserId\"\nWHERE T1.\"DisplayName\" = 'DatEpicCoderGuyWhoPrograms'"
        },
        "generated_sql_query": {
            "raw": "SELECT b.Name \nFROM public.users u\nJOIN public.badges b ON u.Id = b.UserId\nWHERE u.DisplayName = 'DatEpicCoderGuyWhoPrograms';",
            "normalized": "SELECT b.Name\nFROM public.users u\nJOIN public.badges b ON u.Id = b.UserId\nWHERE u.DisplayName = 'DatEpicCoderGuyWhoPrograms';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(T2.\"Id\") AS DOUBLE PRECISION) / COUNT(DISTINCT T1.\"Id\") FROM votes AS T1 INNER JOIN posts AS T2 ON T1.\"UserId\" = T2.\"OwnerUserId\" WHERE T1.\"UserId\" = 24",
            "normalized": "SELECT CAST(COUNT(T2.\"Id\") AS DOUBLE PRECISION) / COUNT(DISTINCT T1.\"Id\")\nFROM votes AS T1\nINNER JOIN posts AS T2 ON T1.\"UserId\" = T2.\"OwnerUserId\"\nWHERE T1.\"UserId\" = 24"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SELECT COUNT(*) FROM posts WHERE OwnerUserId = 24) AS PostCount,\n    (SELECT COUNT(*) FROM votes WHERE UserId = 24) AS VoteCount",
            "normalized": "SELECT\n  (SELECT COUNT(*)\n   FROM posts\n   WHERE OwnerUserId = 24) AS PostCount,\n\n  (SELECT COUNT(*)\n   FROM votes\n   WHERE UserId = 24) AS VoteCount"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
        "reference_sql_query": {
            "raw": "SELECT \"ViewCount\" FROM posts WHERE \"Title\" = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
            "normalized": "SELECT \"ViewCount\"\nFROM posts\nWHERE \"Title\" = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"ViewCount\"\nFROM public.posts\nWHERE \"Title\" = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';",
            "normalized": "SELECT \"ViewCount\"\nFROM public.posts\nWHERE \"Title\" = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Write the contents of comments with a score of 17.",
        "reference_sql_query": {
            "raw": "SELECT \"Text\" FROM comments WHERE \"Score\" = 17",
            "normalized": "SELECT \"Text\"\nFROM comments\nWHERE \"Score\" = 17"
        },
        "generated_sql_query": {
            "raw": "SELECT * FROM public.comments WHERE \"Score\" = 17;",
            "normalized": "SELECT *\nFROM public.comments\nWHERE \"Score\" = 17;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Which user has the website URL listed at 'http://stackoverflow.com'",
        "reference_sql_query": {
            "raw": "SELECT \"DisplayName\" FROM users WHERE \"WebsiteUrl\" = 'http://stackoverflow.com'",
            "normalized": "SELECT \"DisplayName\"\nFROM users\nWHERE \"WebsiteUrl\" = 'http://stackoverflow.com'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"DisplayName\" \nFROM public.users \nWHERE \"WebsiteUrl\" = 'http://stackoverflow.com';",
            "normalized": "SELECT \"DisplayName\"\nFROM public.users\nWHERE \"WebsiteUrl\" = 'http://stackoverflow.com';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "What is the badge name that user 'SilentGhost' obtained?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Name\" FROM users AS T1 INNER JOIN badges AS T2 ON T1.\"Id\" = T2.\"UserId\" WHERE T1.\"DisplayName\" = 'SilentGhost'",
            "normalized": "SELECT T2.\"Name\"\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.\"Id\" = T2.\"UserId\"\nWHERE T1.\"DisplayName\" = 'SilentGhost'"
        },
        "generated_sql_query": {
            "raw": "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.DisplayName = 'SilentGhost';",
            "normalized": "SELECT b.Name\nFROM badges b\nJOIN users u ON b.UserId = u.Id\nWHERE u.DisplayName = 'SilentGhost';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Name the user that commented 'thank you user93!'",
        "reference_sql_query": {
            "raw": "SELECT T1.\"DisplayName\" FROM users AS T1 INNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"UserId\" WHERE T2.\"Text\" = 'thank you user93!'",
            "normalized": "SELECT T1.\"DisplayName\"\nFROM users AS T1\nINNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"UserId\"\nWHERE T2.\"Text\" = 'thank you user93!'"
        },
        "generated_sql_query": {
            "raw": "SELECT UserDisplayName \nFROM public.comments \nWHERE Text = 'thank you user93!';",
            "normalized": "SELECT UserDisplayName\nFROM public.comments\nWHERE Text = 'thank you user93!';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Write all comments made by user 'A Lion.'",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Text\" FROM users AS T1 INNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"UserId\" WHERE T1.\"DisplayName\" = 'A Lion'",
            "normalized": "SELECT T2.\"Text\"\nFROM users AS T1\nINNER JOIN comments AS T2 ON T1.\"Id\" = T2.\"UserId\"\nWHERE T1.\"DisplayName\" = 'A Lion'"
        },
        "generated_sql_query": {
            "raw": "SELECT *\nFROM public.comments\nWHERE \"UserDisplayName\" = 'A Lion.'",
            "normalized": "SELECT *\nFROM public.comments\nWHERE \"UserDisplayName\" = 'A Lion.'"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"DisplayName\", T1.\"Reputation\" FROM users AS T1 INNER JOIN posts AS T2 ON T1.\"Id\" = T2.\"OwnerUserId\" WHERE T2.\"Title\" = 'Understanding what Dassault iSight is doing?'",
            "normalized": "SELECT T1.\"DisplayName\",\n       T1.\"Reputation\"\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.\"Id\" = T2.\"OwnerUserId\"\nWHERE T2.\"Title\" = 'Understanding what Dassault iSight is doing?'"
        },
        "generated_sql_query": {
            "raw": "SELECT u.DisplayName, u.Reputation\nFROM public.users u\nJOIN public.posts p ON u.Id = p.OwnerUserId\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';",
            "normalized": "SELECT u.DisplayName,\n       u.Reputation\nFROM public.users u\nJOIN public.posts p ON u.Id = p.OwnerUserId\nWHERE p.Title = 'Understanding what Dassault iSight is doing?';"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Text\" FROM comments AS T1 INNER JOIN posts AS T2 ON T1.\"PostId\" = T2.\"Id\" WHERE T2.\"Title\" = 'How does gentle boosting differ from AdaBoost?'",
            "normalized": "SELECT T1.\"Text\"\nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.\"PostId\" = T2.\"Id\"\nWHERE T2.\"Title\" = 'How does gentle boosting differ from AdaBoost?'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.*\nFROM public.comments c\nJOIN public.posts p ON c.PostId = p.Id\nWHERE p.Title = 'How does gentle boosting differ from AdaBoost?'",
            "normalized": "SELECT c.*\nFROM public.comments c\nJOIN public.posts p ON c.PostId = p.Id\nWHERE p.Title = 'How does gentle boosting differ from AdaBoost?'"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Name 10 users with the badge name 'Necromancer.'",
        "reference_sql_query": {
            "raw": "SELECT T1.\"DisplayName\" FROM users AS T1 INNER JOIN badges AS T2 ON T1.\"Id\" = T2.\"UserId\" WHERE T2.\"Name\" = 'Necromancer' LIMIT 10",
            "normalized": "SELECT T1.\"DisplayName\"\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.\"Id\" = T2.\"UserId\"\nWHERE T2.\"Name\" = 'Necromancer'\nLIMIT 10"
        },
        "generated_sql_query": {
            "raw": "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;",
            "normalized": "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;"
        },
        "db_id": "codebase_community"
    },
    {
        "question": "Please list all the superpowers of 3-D Man.",
        "reference_sql_query": {
            "raw": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'",
            "normalized": "SELECT T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = '3-D Man'"
        },
        "generated_sql_query": {
            "raw": "SELECT sp.power_name\nFROM public.superhero sh\nJOIN public.hero_power hp ON sh.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = '3-D Man';",
            "normalized": "SELECT sp.power_name\nFROM public.superhero sh\nJOIN public.hero_power hp ON sh.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = '3-D Man';"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many superheroes have the super power of \"Super Strength\"?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Super Strength'",
            "normalized": "SELECT COUNT(T1.hero_id)\nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nWHERE T2.power_name = 'Super Strength'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT hero_id) AS superhero_count\nFROM public.hero_power\nJOIN public.superpower ON hero_power.power_id = superpower.id\nWHERE superpower.power_name = 'Super Strength';",
            "normalized": "SELECT COUNT(DISTINCT hero_id) AS superhero_count\nFROM public.hero_power\nJOIN public.superpower ON hero_power.power_id = superpower.id\nWHERE superpower.power_name = 'Super Strength';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Super Strength'\n  AND T1.height_cm > 200"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT s.id) AS num_superheroes\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength' AND s.height_cm > 200;",
            "normalized": "SELECT COUNT(DISTINCT s.id) AS num_superheroes\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength'\n  AND s.height_cm > 200;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Please list the full names of all the superheroes with over 15 super powers.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.full_name HAVING COUNT(T2.power_id) > 15",
            "normalized": "SELECT DISTINCT T1.full_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nGROUP BY T1.full_name\nHAVING COUNT(T2.power_id) > 15"
        },
        "generated_sql_query": {
            "raw": "SELECT sh.full_name\nFROM public.superhero sh\nJOIN public.hero_power hp ON sh.id = hp.hero_id\nGROUP BY sh.id, sh.full_name\nHAVING COUNT(hp.power_id) > 15;",
            "normalized": "SELECT sh.full_name\nFROM public.superhero sh\nJOIN public.hero_power hp ON sh.id = hp.hero_id\nGROUP BY sh.id,\n         sh.full_name\nHAVING COUNT(hp.power_id) > 15;"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many superheroes have blue eyes?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.superhero\nWHERE eye_colour_id = (\n    SELECT id \n    FROM public.colour\n    WHERE colour = 'blue'\n);",
            "normalized": "SELECT COUNT(*)\nFROM public.superhero\nWHERE eye_colour_id =\n    (SELECT id\n     FROM public.colour\n     WHERE colour = 'blue');"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the colour of Apocalypse's skin?",
        "reference_sql_query": {
            "raw": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'",
            "normalized": "SELECT T2.colour\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id\nWHERE T1.superhero_name = 'Apocalypse'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.colour\nFROM public.superhero s\nJOIN public.colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse';",
            "normalized": "SELECT c.colour\nFROM public.superhero s\nJOIN public.colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Among the superheroes with blue eyes, how many of them have the super power of \"Agility\"?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nINNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id\nWHERE T3.power_name = 'Agility'\n  AND T4.colour = 'Blue'"
        },
        "generated_sql_query": {
            "raw": "Error running intermediate SQL: You need to connect to a database first by running vn.connect_to_snowflake(), vn.connect_to_postgres(), similar function, or manually set vn.run_sql",
            "normalized": "Error running intermediate SQL: You need TO CONNECT TO a DATABASE FIRST BY running vn.connect_to_snowflake(),\n                                                                           vn.connect_to_postgres(),\n                                                                           SIMILAR FUNCTION,\nOR manually\nSET vn.run_sql"
        },
        "db_id": "superhero"
    },
    {
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "reference_sql_query": {
            "raw": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
            "normalized": "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T2.colour = 'Blue'\n  AND T3.colour = 'Blond'"
        },
        "generated_sql_query": {
            "raw": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.colour ec ON s.eye_colour_id = ec.id\nJOIN public.colour hc ON s.hair_colour_id = hc.id\nWHERE ec.colour = 'blue' AND hc.colour = 'blond';",
            "normalized": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.colour ec ON s.eye_colour_id = ec.id\nJOIN public.colour hc ON s.hair_colour_id = hc.id\nWHERE ec.colour = 'blue'\n  AND hc.colour = 'blond';"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many superheroes are published by Marvel Comics?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'Marvel Comics'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.superhero \nJOIN public.publisher ON public.superhero.publisher_id = public.publisher.id \nWHERE public.publisher.publisher_name = 'Marvel Comics';",
            "normalized": "SELECT COUNT(*)\nFROM public.superhero\nJOIN public.publisher ON public.superhero.publisher_id = public.publisher.id\nWHERE public.publisher.publisher_name = 'Marvel Comics';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "reference_sql_query": {
            "raw": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
            "normalized": "SELECT superhero_name,\n       height_cm,\n       RANK() OVER (\n                    ORDER BY height_cm DESC) AS HeightRank\nFROM superhero\nINNER JOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics'"
        },
        "generated_sql_query": {
            "raw": "SELECT superhero_name, height_cm\nFROM public.superhero\nWHERE publisher_id = (SELECT id FROM public.publisher WHERE publisher_name = 'Marvel Comics')\nORDER BY height_cm DESC;",
            "normalized": "SELECT superhero_name,\n       height_cm\nFROM public.superhero\nWHERE publisher_id =\n    (SELECT id\n     FROM public.publisher\n     WHERE publisher_name = 'Marvel Comics')\nORDER BY height_cm DESC;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Who is the publisher of Sauron?",
        "reference_sql_query": {
            "raw": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
            "normalized": "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name = 'Sauron'"
        },
        "generated_sql_query": {
            "raw": "SELECT p.publisher_name\nFROM public.superhero s\nJOIN public.publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';",
            "normalized": "SELECT p.publisher_name\nFROM public.superhero s\nJOIN public.publisher p ON s.publisher_id = p.id\nWHERE s.superhero_name = 'Sauron';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "reference_sql_query": {
            "raw": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
            "normalized": "SELECT colour.colour AS EyeColor,\n       COUNT(superhero.id) AS COUNT,\n       RANK() OVER (\n                    ORDER BY COUNT(superhero.id) DESC) AS PopularityRank\nFROM superhero\nINNER JOIN colour ON superhero.eye_colour_id = colour.id\nINNER JOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics'\nGROUP BY colour.colour"
        },
        "generated_sql_query": {
            "raw": "SELECT c.colour AS eye_color, COUNT(*) AS superhero_count\nFROM public.superhero s\nJOIN public.colour c ON s.eye_colour_id = c.id\nJOIN public.publisher p ON s.publisher_id = p.id\nWHERE p.name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;",
            "normalized": "SELECT c.colour AS eye_color,\n       COUNT(*) AS superhero_count\nFROM public.superhero s\nJOIN public.colour c ON s.eye_colour_id = c.id\nJOIN public.publisher p ON s.publisher_id = p.id\nWHERE p.name = 'Marvel Comics'\nGROUP BY c.colour\nORDER BY superhero_count DESC;"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the average height of the superheroes from Marvel Comics?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
            "normalized": "SELECT AVG(T1.height_cm)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'Marvel Comics'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(height_cm) AS average_height\nFROM public.superhero\nWHERE publisher_id = (SELECT id FROM public.publisher WHERE name = 'Marvel Comics');",
            "normalized": "SELECT AVG(height_cm) AS average_height\nFROM public.superhero\nWHERE publisher_id =\n    (SELECT id\n     FROM public.publisher\n     WHERE name = 'Marvel Comics');"
        },
        "db_id": "superhero"
    },
    {
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "reference_sql_query": {
            "raw": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
            "normalized": "SELECT superhero_name\nFROM superhero AS T1\nWHERE EXISTS\n    (SELECT 1\n     FROM hero_power AS T2\n     INNER JOIN superpower AS T3 ON T2.power_id = T3.id\n     WHERE T3.power_name = 'Super Strength'\n       AND T1.id = T2.hero_id)\n  AND EXISTS\n    (SELECT 1\n     FROM publisher AS T4\n     WHERE T4.publisher_name = 'Marvel Comics'\n       AND T1.publisher_id = T4.id)"
        },
        "generated_sql_query": {
            "raw": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength' AND s.publisher_id = (\n    SELECT id FROM public.superhero WHERE superhero_name = 'Marvel Comics'\n);",
            "normalized": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength'\n  AND s.publisher_id =\n    (SELECT id\n     FROM public.superhero\n     WHERE superhero_name = 'Marvel Comics');"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many superheroes did DC Comics publish?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.superhero\nWHERE publisher_id = (SELECT id FROM public.publisher WHERE publisher_name = 'DC Comics');",
            "normalized": "SELECT COUNT(*)\nFROM public.superhero\nWHERE publisher_id =\n    (SELECT id\n     FROM public.publisher\n     WHERE publisher_name = 'DC Comics');"
        },
        "db_id": "superhero"
    },
    {
        "question": "Which publisher published the slowest superhero?",
        "reference_sql_query": {
            "raw": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
            "normalized": "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nINNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id\nINNER JOIN attribute AS T4 ON T3.attribute_id = T4.id\nWHERE T4.attribute_name = 'Speed'\nORDER BY T3.attribute_value\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the speed attribute of superheroes, and how to associate it with the publisher. The tables related to superheroes don't contain any specific attribute indicating speed that could be used to determine the slowest superhero.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the speed attribute OF superheroes,\nAND how TO associate it WITH the publisher. The TABLES related TO superheroes don't contain ANY SPECIFIC attribute indicating speed that could be used TO determine the slowest superhero."
        },
        "db_id": "superhero"
    },
    {
        "question": "How many gold-eyed superheroes did Marvel Comics publish?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.colour = 'Gold'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nINNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id\nWHERE T2.publisher_name = 'Marvel Comics'\n  AND T3.colour = 'Gold'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS gold_eyed_superheroes_count\nFROM public.superhero\nJOIN public.colour ON public.superhero.eye_colour_id = public.colour.id\nJOIN public.publisher ON public.superhero.publisher_id = public.publisher.id\nWHERE public.colour.colour = 'Gold' AND public.publisher.publisher_name = 'Marvel Comics';",
            "normalized": "SELECT COUNT(*) AS gold_eyed_superheroes_count\nFROM public.superhero\nJOIN public.colour ON public.superhero.eye_colour_id = public.colour.id\nJOIN public.publisher ON public.superhero.publisher_id = public.publisher.id\nWHERE public.colour.colour = 'Gold'\n  AND public.publisher.publisher_name = 'Marvel Comics';"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the publisher's name of Blue Beetle II?",
        "reference_sql_query": {
            "raw": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'",
            "normalized": "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name = 'Blue Beetle II'"
        },
        "generated_sql_query": {
            "raw": "SELECT publisher.publisher_name\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE superhero.superhero_name = 'Blue Beetle II';",
            "normalized": "SELECT publisher.publisher_name\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE superhero.superhero_name = 'Blue Beetle II';"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many superheroes with blonde hair are there?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE T2.colour = 'Blond'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id\nWHERE T2.colour = 'Blond'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.superhero s\nJOIN public.colour c ON s.hair_colour_id = c.id\nWHERE c.colour = 'Blonde';",
            "normalized": "SELECT COUNT(*)\nFROM public.superhero s\nJOIN public.colour c ON s.hair_colour_id = c.id\nWHERE c.colour = 'Blonde';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Who is the dumbest superhero?",
        "reference_sql_query": {
            "raw": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
            "normalized": "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Intelligence'\nORDER BY T2.attribute_value\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine who the dumbest superhero is, as it does not contain information about the intelligence or attributes related to intelligence of superheroes.",
            "normalized": "The provided context IS insufficient TO determine who the dumbest superhero IS, AS it does NOT contain information about the intelligence\nOR attributes related TO intelligence OF superheroes."
        },
        "db_id": "superhero"
    },
    {
        "question": "What is Copycat's race?",
        "reference_sql_query": {
            "raw": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
            "normalized": "SELECT T2.race\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T1.superhero_name = 'Copycat'"
        },
        "generated_sql_query": {
            "raw": "SELECT race.race\nFROM superhero\nJOIN race ON superhero.race_id = race.id\nWHERE superhero.superhero_name = 'Copycat';",
            "normalized": "SELECT race.race\nFROM superhero\nJOIN race ON superhero.race_id = race.id\nWHERE superhero.superhero_name = 'Copycat';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Which superheroes have a durability attribute value of less than 50?",
        "reference_sql_query": {
            "raw": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_attribute AS T2 INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50 AND T1.id = T2.hero_id)",
            "normalized": "SELECT superhero_name\nFROM superhero AS T1\nWHERE EXISTS\n    (SELECT 1\n     FROM hero_attribute AS T2\n     INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\n     WHERE T3.attribute_name = 'Durability'\n       AND T2.attribute_value < 50\n       AND T1.id = T2.hero_id)"
        },
        "generated_sql_query": {
            "raw": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_attribute ha ON s.id = ha.hero_id\nJOIN public.attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'durability' AND ha.attribute_value < 50;",
            "normalized": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_attribute ha ON s.id = ha.hero_id\nJOIN public.attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'durability'\n  AND ha.attribute_value < 50;"
        },
        "db_id": "superhero"
    },
    {
        "question": "What are the names of the superheroes with the power of death touch?",
        "reference_sql_query": {
            "raw": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
            "normalized": "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Death Touch'"
        },
        "generated_sql_query": {
            "raw": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Death Touch';",
            "normalized": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Death Touch';"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many female superheroes have a strength value of 100?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nINNER JOIN gender AS T4 ON T1.gender_id = T4.id\nWHERE T3.attribute_name = 'Strength'\n  AND T2.attribute_value = 100\n  AND T4.gender = 'Female'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.superhero AS s\nJOIN public.hero_attribute AS ha ON s.id = ha.hero_id\nJOIN public.gender AS g ON s.gender_id = g.id\nWHERE g.gender = 'Female' AND ha.attribute_id = (SELECT id FROM public.hero_attribute WHERE attribute_id = 'strength') AND ha.attribute_value = 100;",
            "normalized": "SELECT COUNT(*)\nFROM public.superhero AS s\nJOIN public.hero_attribute AS ha ON s.id = ha.hero_id\nJOIN public.gender AS g ON s.gender_id = g.id\nWHERE g.gender = 'Female'\n  AND ha.attribute_id =\n    (SELECT id\n     FROM public.hero_attribute\n     WHERE attribute_id = 'strength')\n  AND ha.attribute_value = 100;"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the name of the superhero that has the most powers?",
        "reference_sql_query": {
            "raw": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
            "normalized": "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nGROUP BY T1.superhero_name\nORDER BY COUNT(T2.hero_id) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nGROUP BY s.superhero_name\nORDER BY COUNT(hp.power_id) DESC\nLIMIT 1;",
            "normalized": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_power hp ON s.id = hp.hero_id\nGROUP BY s.superhero_name\nORDER BY COUNT(hp.power_id) DESC\nLIMIT 1;"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many vampire superheroes are there?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.superhero_name) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
            "normalized": "SELECT COUNT(T1.superhero_name)\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Vampire'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS vampire_superheroes_count\nFROM public.superhero\nJOIN public.hero_attribute ON public.superhero.id = public.hero_attribute.hero_id\nWHERE public.hero_attribute.attribute_id = (\n    SELECT id FROM public.superpower WHERE power_name = 'vampire'\n);",
            "normalized": "SELECT COUNT(*) AS vampire_superheroes_count\nFROM public.superhero\nJOIN public.hero_attribute ON public.superhero.id = public.hero_attribute.hero_id\nWHERE public.hero_attribute.attribute_id =\n    (SELECT id\n     FROM public.superpower\n     WHERE power_name = 'vampire');"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "reference_sql_query": {
            "raw": "SELECT (CAST(COUNT(*) AS DOUBLE PRECISION) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
            "normalized": "SELECT (CAST(COUNT(*) AS DOUBLE PRECISION) * 100 /\n          (SELECT COUNT(*)\n           FROM superhero)), CAST(SUM(CASE\n                                          WHEN T2.publisher_name = 'Marvel Comics' THEN 1\n                                          ELSE 0\n                                      END) AS DOUBLE PRECISION)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nINNER JOIN alignment AS T3 ON T3.id = T1.alignment_id\nWHERE T3.alignment = 'Bad'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(*) FILTER (WHERE alignment_id = (SELECT id FROM public.alignment WHERE alignment_name = 'neutral')) * 100.0 / COUNT(*)) AS percentage_self_interest,\n    COUNT(*) FILTER (WHERE alignment_id = (SELECT id FROM public.alignment WHERE alignment_name = 'neutral') AND publisher_id = (SELECT id FROM public.publisher WHERE publisher_name = 'Marvel Comics')) AS marvel_neutral_superheroes\nFROM \n    public.superhero;",
            "normalized": "SELECT (COUNT(*) FILTER (\n                         WHERE alignment_id =\n                             (SELECT id\n                              FROM public.alignment\n                              WHERE alignment_name = 'neutral')) * 100.0 / COUNT(*)) AS percentage_self_interest,\n       COUNT(*) FILTER (\n                        WHERE alignment_id =\n                            (SELECT id\n                             FROM public.alignment\n                             WHERE alignment_name = 'neutral')\n                          AND publisher_id =\n                            (SELECT id\n                             FROM public.publisher\n                             WHERE publisher_name = 'Marvel Comics')) AS marvel_neutral_superheroes\nFROM public.superhero;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
            "normalized": "SELECT SUM(CASE\n               WHEN T2.publisher_name = 'Marvel Comics' THEN 1\n               ELSE 0\n           END) - SUM(CASE\n                          WHEN T2.publisher_name = 'DC Comics' THEN 1\n                          ELSE 0\n                      END)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SELECT publisher_name FROM public.publisher WHERE id = dc_publisher_id) AS publisher_dc,\n    (SELECT COUNT(*) FROM public.superhero WHERE publisher_id = dc_publisher_id) AS count_dc,\n    (SELECT publisher_name FROM public.publisher WHERE id = marvel_publisher_id) AS publisher_marvel,\n    (SELECT COUNT(*) FROM public.superhero WHERE publisher_id = marvel_publisher_id) AS count_marvel,\n    ABS((SELECT COUNT(*) FROM public.superhero WHERE publisher_id = dc_publisher_id) - \n        (SELECT COUNT(*) FROM public.superhero WHERE publisher_id = marvel_publisher_id)) AS difference\nFROM\n    (SELECT id AS dc_publisher_id FROM public.publisher WHERE publisher_name = 'DC Comics') AS dc_table,\n    (SELECT id AS marvel_publisher_id FROM public.publisher WHERE publisher_name = 'Marvel Comics') AS marvel_table;",
            "normalized": "SELECT\n  (SELECT publisher_name\n   FROM public.publisher\n   WHERE id = dc_publisher_id) AS publisher_dc,\n\n  (SELECT COUNT(*)\n   FROM public.superhero\n   WHERE publisher_id = dc_publisher_id) AS count_dc,\n\n  (SELECT publisher_name\n   FROM public.publisher\n   WHERE id = marvel_publisher_id) AS publisher_marvel,\n\n  (SELECT COUNT(*)\n   FROM public.superhero\n   WHERE publisher_id = marvel_publisher_id) AS count_marvel,\n       ABS(\n             (SELECT COUNT(*)\n              FROM public.superhero\n              WHERE publisher_id = dc_publisher_id) -\n             (SELECT COUNT(*)\n              FROM public.superhero\n              WHERE publisher_id = marvel_publisher_id)) AS difference\nFROM\n  (SELECT id AS dc_publisher_id\n   FROM public.publisher\n   WHERE publisher_name = 'DC Comics') AS dc_table,\n\n  (SELECT id AS marvel_publisher_id\n   FROM public.publisher\n   WHERE publisher_name = 'Marvel Comics') AS marvel_table;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Give the publisher ID of Star Trek.",
        "reference_sql_query": {
            "raw": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
            "normalized": "SELECT id\nFROM publisher\nWHERE publisher_name = 'Star Trek'"
        },
        "generated_sql_query": {
            "raw": "SELECT id FROM public.publisher WHERE publisher_name = 'Star Trek';",
            "normalized": "SELECT id\nFROM public.publisher\nWHERE publisher_name = 'Star Trek';"
        },
        "db_id": "superhero"
    },
    {
        "question": "Calculate the average attribute value of all superheroes.",
        "reference_sql_query": {
            "raw": "SELECT AVG(attribute_value) FROM hero_attribute",
            "normalized": "SELECT AVG(attribute_value)\nFROM hero_attribute"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(attribute_value) AS average_attribute_value\nFROM public.hero_attribute;",
            "normalized": "SELECT AVG(attribute_value) AS average_attribute_value\nFROM public.hero_attribute;"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the total number of superheroes without full name?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
            "normalized": "SELECT COUNT(id)\nFROM superhero\nWHERE full_name IS NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS total_superheroes_without_full_name\nFROM public.superhero\nWHERE full_name IS NULL OR full_name = '';",
            "normalized": "SELECT COUNT(*) AS total_superheroes_without_full_name\nFROM public.superhero\nWHERE full_name IS NULL\n  OR full_name = '';"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the eye colour of superhero with superhero ID 75?",
        "reference_sql_query": {
            "raw": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75",
            "normalized": "SELECT T2.colour\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T1.id = 75"
        },
        "generated_sql_query": {
            "raw": "SELECT c.colour AS eye_colour\nFROM public.superhero s\nJOIN public.colour c ON s.eye_colour_id = c.id\nWHERE s.id = 75;",
            "normalized": "SELECT c.colour AS eye_colour\nFROM public.superhero s\nJOIN public.colour c ON s.eye_colour_id = c.id\nWHERE s.id = 75;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Provide the superpowers of the superhero called Deathlok.",
        "reference_sql_query": {
            "raw": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Deathlok'",
            "normalized": "SELECT T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = 'Deathlok'"
        },
        "generated_sql_query": {
            "raw": "SELECT sp.power_name\nFROM public.superpower sp\nJOIN public.hero_power hp ON sp.id = hp.power_id\nJOIN public.superhero sh ON hp.hero_id = sh.id\nWHERE sh.superhero_name = 'Deathlok';",
            "normalized": "SELECT sp.power_name\nFROM public.superpower sp\nJOIN public.hero_power hp ON sp.id = hp.power_id\nJOIN public.superhero sh ON hp.hero_id = sh.id\nWHERE sh.superhero_name = 'Deathlok';"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the average weight of all female superheroes?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'",
            "normalized": "SELECT AVG(T1.weight_kg)\nFROM superhero AS T1\nINNER JOIN gender AS T2 ON T1.gender_id = T2.id\nWHERE T2.gender = 'Female'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(weight_kg) AS average_weight_of_female_superheroes\nFROM public.superhero\nJOIN public.gender ON public.superhero.gender_id = public.gender.id\nWHERE public.gender.gender = 'Female';",
            "normalized": "SELECT AVG(weight_kg) AS average_weight_of_female_superheroes\nFROM public.superhero\nJOIN public.gender ON public.superhero.gender_id = public.gender.id\nWHERE public.gender.gender = 'Female';"
        },
        "db_id": "superhero"
    },
    {
        "question": "List down at least five superpowers of male superheroes.",
        "reference_sql_query": {
            "raw": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
            "normalized": "SELECT T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T3.id = T2.power_id\nINNER JOIN gender AS T4 ON T4.id = T1.gender_id\nWHERE T4.gender = 'Male'\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nJOIN gender g ON sh.gender_id = g.id\nWHERE g.gender = 'Male'\nLIMIT 5;",
            "normalized": "SELECT DISTINCT sp.power_name\nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nJOIN gender g ON sh.gender_id = g.id\nWHERE g.gender = 'Male'\nLIMIT 5;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Give the name of the alien superheroes.",
        "reference_sql_query": {
            "raw": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
            "normalized": "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Alien'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_id = (\n    SELECT id \n    FROM public.hero_attribute \n    WHERE attribute_value = 'alien'\n)",
            "normalized": "SELECT DISTINCT s.superhero_name\nFROM public.superhero s\nJOIN public.hero_attribute ha ON s.id = ha.hero_id\nWHERE ha.attribute_id =\n    (SELECT id\n     FROM public.hero_attribute\n     WHERE attribute_value = 'alien')"
        },
        "db_id": "superhero"
    },
    {
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
            "normalized": "SELECT DISTINCT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T1.height_cm BETWEEN 170 AND 190\n  AND T2.colour = 'No Colour'"
        },
        "generated_sql_query": {
            "raw": "SELECT superhero_name \nFROM public.superhero\nWHERE height_cm BETWEEN 170 AND 190\nAND eye_colour_id IS NULL;",
            "normalized": "SELECT superhero_name\nFROM public.superhero\nWHERE height_cm BETWEEN 170 AND 190\n  AND eye_colour_id IS NULL;"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the superpower of hero ID 56?",
        "reference_sql_query": {
            "raw": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
            "normalized": "SELECT T2.power_name\nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nWHERE T1.hero_id = 56"
        },
        "generated_sql_query": {
            "raw": "SELECT sp.power_name\nFROM public.hero_power hp\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE hp.hero_id = 56;",
            "normalized": "SELECT sp.power_name\nFROM public.hero_power hp\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE hp.hero_id = 56;"
        },
        "db_id": "superhero"
    },
    {
        "question": "List down at least five full name of Demi-God superheroes.",
        "reference_sql_query": {
            "raw": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God'",
            "normalized": "SELECT T1.full_name\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Demi-God'"
        },
        "generated_sql_query": {
            "raw": "SELECT full_name\nFROM public.superhero\nWHERE race_id = (\n    SELECT id\n    FROM public.race\n    WHERE race_name = 'Demi-God'\n)\nLIMIT 5;",
            "normalized": "SELECT full_name\nFROM public.superhero\nWHERE race_id =\n    (SELECT id\n     FROM public.race\n     WHERE race_name = 'Demi-God')\nLIMIT 5;"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many bad superheroes are there?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
            "normalized": "SELECT COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN alignment AS T2 ON T1.alignment_id = T2.id\nWHERE T2.alignment = 'Bad'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.superhero \nWHERE alignment_id = (SELECT id FROM public.alignment WHERE alignment = 'bad');",
            "normalized": "SELECT COUNT(*)\nFROM public.superhero\nWHERE alignment_id =\n    (SELECT id\n     FROM public.alignment\n     WHERE alignment = 'bad');"
        },
        "db_id": "superhero"
    },
    {
        "question": "Identify the race of the superhero who weighed 169 kg.",
        "reference_sql_query": {
            "raw": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169",
            "normalized": "SELECT T2.race\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T1.weight_kg = 169"
        },
        "generated_sql_query": {
            "raw": "SELECT r.race\nFROM public.superhero AS s\nJOIN public.race AS r ON s.race_id = r.id\nWHERE s.weight_kg = 169;",
            "normalized": "SELECT r.race\nFROM public.superhero AS s\nJOIN public.race AS r ON s.race_id = r.id\nWHERE s.weight_kg = 169;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
            "normalized": "SELECT DISTINCT T3.colour\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T1.height_cm = 185\n  AND T2.race = 'Human'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.colour AS hair_colour\nFROM public.superhero s\nJOIN public.colour c ON s.hair_colour_id = c.id\nJOIN public.race r ON s.race_id = r.id\nWHERE s.height_cm = 185 AND r.race = 'Human';",
            "normalized": "SELECT c.colour AS hair_colour\nFROM public.superhero s\nJOIN public.colour c ON s.hair_colour_id = c.id\nJOIN public.race r ON s.race_id = r.id\nWHERE s.height_cm = 185\n  AND r.race = 'Human';"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the eye clolour of the heaviest superhero?",
        "reference_sql_query": {
            "raw": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id ORDER BY T1.weight_kg DESC LIMIT 1",
            "normalized": "SELECT T2.colour\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nORDER BY T1.weight_kg DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.colour AS eye_colour\nFROM public.superhero s\nJOIN public.colour c ON s.eye_colour_id = c.id\nORDER BY s.weight_kg DESC\nLIMIT 1;",
            "normalized": "SELECT c.colour AS eye_colour\nFROM public.superhero s\nJOIN public.colour c ON s.eye_colour_id = c.id\nORDER BY s.weight_kg DESC\nLIMIT 1;"
        },
        "db_id": "superhero"
    },
    {
        "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS DOUBLE PRECISION) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
            "normalized": "SELECT CAST(COUNT(CASE\n                      WHEN T2.publisher_name = 'Marvel Comics' THEN 1\n                      ELSE NULL\n                  END) AS DOUBLE PRECISION) * 100 / COUNT(T1.id)\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.height_cm BETWEEN 150 AND 180"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(*) FILTER (WHERE publisher_id = (SELECT id FROM public.superhero WHERE superhero_name = 'Marvel Comics'))::decimal / COUNT(*)) * 100 AS marvel_percentage \nFROM \n    public.superhero\nWHERE \n    height_cm BETWEEN 150 AND 180;",
            "normalized": "SELECT (COUNT(*) FILTER (\n                         WHERE publisher_id =\n                             (SELECT id\n                              FROM public.superhero\n                              WHERE superhero_name = 'Marvel Comics'))::decimal / COUNT(*)) * 100 AS marvel_percentage\nFROM public.superhero\nWHERE height_cm BETWEEN 150 AND 180;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
        "reference_sql_query": {
            "raw": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg::BIGINT * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
            "normalized": "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN gender AS T2 ON T1.gender_id = T2.id\nWHERE T2.gender = 'Male'\n  AND T1.weight_kg::BIGINT * 100 >\n    (SELECT AVG(weight_kg)\n     FROM superhero) * 79"
        },
        "generated_sql_query": {
            "raw": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.gender g ON s.gender_id = g.id\nWHERE g.gender = 'Male'\nAND s.weight_kg > (\n    SELECT 0.79 * AVG(weight_kg)\n    FROM public.superhero\n)",
            "normalized": "SELECT s.superhero_name\nFROM public.superhero s\nJOIN public.gender g ON s.gender_id = g.id\nWHERE g.gender = 'Male'\n  AND s.weight_kg >\n    (SELECT 0.79 * AVG(weight_kg)\n     FROM public.superhero)"
        },
        "db_id": "superhero"
    },
    {
        "question": "Which power do superheroes have the most of?",
        "reference_sql_query": {
            "raw": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
            "normalized": "SELECT T2.power_name\nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(T1.hero_id) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT sp.power_name, COUNT(*) as power_count\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nGROUP BY sp.power_name\nORDER BY power_count DESC\nLIMIT 1;",
            "normalized": "SELECT sp.power_name,\n       COUNT(*) AS power_count\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nGROUP BY sp.power_name\nORDER BY power_count DESC\nLIMIT 1;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Indicate the attribute value of superhero Abomination.",
        "reference_sql_query": {
            "raw": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'",
            "normalized": "SELECT T2.attribute_value\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Abomination'"
        },
        "generated_sql_query": {
            "raw": "SELECT ha.attribute_value\nFROM public.hero_attribute ha\nJOIN public.superhero s ON ha.hero_id = s.id\nWHERE s.superhero_name = 'Abomination';",
            "normalized": "SELECT ha.attribute_value\nFROM public.hero_attribute ha\nJOIN public.superhero s ON ha.hero_id = s.id\nWHERE s.superhero_name = 'Abomination';"
        },
        "db_id": "superhero"
    },
    {
        "question": "What are the superpowers of heroes with ID 1?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
            "normalized": "SELECT DISTINCT T2.power_name\nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nWHERE T1.hero_id = 1"
        },
        "generated_sql_query": {
            "raw": "SELECT sp.power_name\nFROM public.hero_power hp\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE hp.hero_id = 1;",
            "normalized": "SELECT sp.power_name\nFROM public.hero_power hp\nJOIN public.superpower sp ON hp.power_id = sp.id\nWHERE hp.hero_id = 1;"
        },
        "db_id": "superhero"
    },
    {
        "question": "How many heroes have stealth power?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
            "normalized": "SELECT COUNT(T1.hero_id)\nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nWHERE T2.power_name = 'Stealth'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT h.hero_id) AS hero_count\nFROM hero_power h\nJOIN superpower s ON h.power_id = s.id\nWHERE s.power_name = 'Stealth';",
            "normalized": "SELECT COUNT(DISTINCT h.hero_id) AS hero_count\nFROM hero_power h\nJOIN superpower s ON h.power_id = s.id\nWHERE s.power_name = 'Stealth';"
        },
        "db_id": "superhero"
    },
    {
        "question": "What is the hero's full name with the highest attribute in strength?",
        "reference_sql_query": {
            "raw": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
            "normalized": "SELECT T1.full_name\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Strength'\nORDER BY T2.attribute_value DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT s.full_name\nFROM public.superhero s\nJOIN public.hero_attribute ha ON s.id = ha.hero_id\nJOIN public.attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'strength'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
            "normalized": "SELECT s.full_name\nFROM public.superhero s\nJOIN public.hero_attribute ha ON s.id = ha.hero_id\nJOIN public.attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'strength'\nORDER BY ha.attribute_value DESC\nLIMIT 1;"
        },
        "db_id": "superhero"
    },
    {
        "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"driverRef\" FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 20 ORDER BY T1.q1 DESC LIMIT 5",
            "normalized": "SELECT T2.\"driverRef\"\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 20\nORDER BY T1.q1 DESC\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "SELECT d.driverRef\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 20 AND q.q1 IS NOT NULL AND q.q2 IS NULL;",
            "normalized": "SELECT d.driverRef\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 20\n  AND q.q1 IS NOT NULL\n  AND q.q2 IS NULL;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "reference_sql_query": {
            "raw": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 19 ORDER BY T1.q2 ASC LIMIT 1",
            "normalized": "SELECT T2.surname\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 19\nORDER BY T1.q2 ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.surname \nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 19\nORDER BY q.q2 \nLIMIT 1;",
            "normalized": "SELECT d.surname\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 19\nORDER BY q.q2\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Please list the year during which the race is held on circuits in Shanghai.",
        "reference_sql_query": {
            "raw": "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.location = 'Shanghai'",
            "normalized": "SELECT T2.year\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.location = 'Shanghai'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.location = 'Shanghai';",
            "normalized": "SELECT DISTINCT r.year\nFROM races r\nJOIN circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.location = 'Shanghai';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
            "normalized": "SELECT DISTINCT T1.url\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        },
        "generated_sql_query": {
            "raw": "SELECT url \nFROM public.circuits \nWHERE name = 'Circuit de Barcelona-Catalunya';",
            "normalized": "SELECT url\nFROM public.circuits\nWHERE name = 'Circuit de Barcelona-Catalunya';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Please give the name of the race held on the circuits in Germany.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.country = 'Germany'",
            "normalized": "SELECT DISTINCT T2.name\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.country = 'Germany'"
        },
        "generated_sql_query": {
            "raw": "SELECT r.name\nFROM public.races r\nJOIN public.circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.country = 'Germany';",
            "normalized": "SELECT r.name\nFROM public.races r\nJOIN public.circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.country = 'Germany';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Please list the positions of the circuits built by the constructor Renault.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"position\" FROM \"constructorStandings\" AS T1 INNER JOIN constructors AS T2 ON T2.\"constructorId\" = T1.\"constructorId\" WHERE T2.name = 'Renault'",
            "normalized": "SELECT DISTINCT T1.\"position\"\nFROM \"constructorStandings\" AS T1\nINNER JOIN constructors AS T2 ON T2.\"constructorId\" = T1.\"constructorId\"\nWHERE T2.name = 'Renault'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.circuitId, c.name, c.location, c.country\nFROM constructors con\nJOIN qualifying q ON con.constructorId = q.constructorId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE con.name = 'Renault';",
            "normalized": "SELECT c.circuitId,\n       c.name,\n       c.location,\n       c.country\nFROM constructors con\nJOIN qualifying q ON con.constructorId = q.constructorId\nJOIN races r ON q.raceId = r.raceId\nJOIN circuits c ON r.circuitId = c.circuitId\nWHERE con.name = 'Renault';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T3.\"raceId\") FROM circuits AS T1 INNER JOIN races AS T3 ON T3.\"circuitId\" = T1.\"circuitId\" WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
            "normalized": "SELECT COUNT(T3.\"raceId\")\nFROM circuits AS T1\nINNER JOIN races AS T3 ON T3.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.country NOT IN ('Bahrain',\n                         'China',\n                         'Singapore',\n                         'Japan',\n                         'Korea',\n                         'Turkey',\n                         'UAE',\n                         'Malaysia',\n                         'Spain',\n                         'Monaco',\n                         'Azerbaijan',\n                         'Austria',\n                         'Belgium',\n                         'France',\n                         'Germany',\n                         'Hungary',\n                         'Italy',\n                         'UK')\n  AND T3.year = 2010"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine which races are held outside Asia and Europe. There is no information on the location or continent of the circuits in the given tables. Therefore, it is not possible to generate the SQL query.",
            "normalized": "The provided context IS insufficient TO determine which races ARE held outside Asia\nAND Europe. There IS NO information ON the LOCATION\nOR continent OF the circuits IN the given tables. Therefore,\n                                          it IS NOT possible TO generate the SQL query."
        },
        "db_id": "formula_1"
    },
    {
        "question": "Please give the names of the races held on the circuits in Spain.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.country = 'Spain'",
            "normalized": "SELECT DISTINCT T2.name\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.country = 'Spain'"
        },
        "generated_sql_query": {
            "raw": "SELECT r.name AS race_name\nFROM public.races r\nJOIN public.circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.country = 'Spain';",
            "normalized": "SELECT r.name AS race_name\nFROM public.races r\nJOIN public.circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.country = 'Spain';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What is the coordinates location of the circuits for Australian grand prix?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T2.name = 'Australian Grand Prix'",
            "normalized": "SELECT DISTINCT T1.lat,\n                T1.lng\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T2.name = 'Australian Grand Prix'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.lat, c.lng\nFROM public.circuits c\nJOIN public.races r ON c.\"circuitId\" = r.\"circuitId\"\nWHERE r.name = 'Australian Grand Prix';",
            "normalized": "SELECT c.lat,\n       c.lng\nFROM public.circuits c\nJOIN public.races r ON c.\"circuitId\" = r.\"circuitId\"\nWHERE r.name = 'Australian Grand Prix';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.name = 'Sepang International Circuit'",
            "normalized": "SELECT DISTINCT T1.url\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.name = 'Sepang International Circuit'"
        },
        "generated_sql_query": {
            "raw": "SELECT * \nFROM public.races\nJOIN public.circuits ON races.\"circuitId\" = circuits.\"circuitId\"\nWHERE circuits.name = 'Sepang International Circuit';",
            "normalized": "SELECT *\nFROM public.races\nJOIN public.circuits ON races.\"circuitId\" = circuits.\"circuitId\"\nWHERE circuits.name = 'Sepang International Circuit';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.\"time\" FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.name = 'Sepang International Circuit'",
            "normalized": "SELECT DISTINCT T2.\"time\"\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.name = 'Sepang International Circuit'"
        },
        "generated_sql_query": {
            "raw": "SELECT r.\"time\"\nFROM public.races r\nJOIN public.circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.name = 'Sepang International Circuit';",
            "normalized": "SELECT r.\"time\"\nFROM public.races r\nJOIN public.circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.name = 'Sepang International Circuit';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Which country is the constructor which got 1 point in the race No. 24 from?",
        "reference_sql_query": {
            "raw": "SELECT T2.nationality FROM \"constructorResults\" AS T1 INNER JOIN constructors AS T2 ON T2.\"constructorId\" = T1.\"constructorId\" WHERE T1.\"raceId\" = 24 AND T1.points = 1",
            "normalized": "SELECT T2.nationality\nFROM \"constructorResults\" AS T1\nINNER JOIN constructors AS T2 ON T2.\"constructorId\" = T1.\"constructorId\"\nWHERE T1.\"raceId\" = 24\n  AND T1.points = 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.nationality\nFROM constructorResults cr\nJOIN constructors c ON cr.constructorId = c.constructorId\nWHERE cr.raceId = 24 AND cr.points = 1;",
            "normalized": "SELECT c.nationality\nFROM constructorResults cr\nJOIN constructors c ON cr.constructorId = c.constructorId\nWHERE cr.raceId = 24\n  AND cr.points = 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What's Bruno Senna's Q1 result in the qualifying race No. 354?",
        "reference_sql_query": {
            "raw": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'",
            "normalized": "SELECT T1.q1\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 354\n  AND T2.forename = 'Bruno'\n  AND T2.surname = 'Senna'"
        },
        "generated_sql_query": {
            "raw": "SELECT q1 \nFROM public.qualifying q\nJOIN public.drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno' AND d.surname = 'Senna' AND q.raceId = 354;",
            "normalized": "SELECT q1\nFROM public.qualifying q\nJOIN public.drivers d ON q.driverId = d.driverId\nWHERE d.forename = 'Bruno'\n  AND d.surname = 'Senna'\n  AND q.raceId = 354;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 355 AND T1.q2 LIKE '1:40%'",
            "normalized": "SELECT DISTINCT T2.nationality\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 355\n  AND T1.q2 LIKE '1:40%'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.nationality\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 355 AND q.q2 = '0:01:40';",
            "normalized": "SELECT d.nationality\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 355\n  AND q.q2 = '0:01:40';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "reference_sql_query": {
            "raw": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 903 AND T1.q3 LIKE '1:54%'",
            "normalized": "SELECT T2.number\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 903\n  AND T1.q3 LIKE '1:54%'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.number\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 903 AND q.q3 = '0:01:54';",
            "normalized": "SELECT d.number\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 903\n  AND q.q3 = '0:01:54';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the Bahrain Grand Prix in 2007, how many drivers not finished the game?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T3.\"driverId\") FROM races AS T1 INNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\" INNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\" WHERE T1.year = 2007 AND T1.name = 'Bahrain Grand Prix' AND T2.\"time\" IS NULL",
            "normalized": "SELECT COUNT(T3.\"driverId\")\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nINNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\"\nWHERE T1.year = 2007\n  AND T1.name = 'Bahrain Grand Prix'\n  AND T2.\"time\" IS NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS not_finished_drivers_count\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nWHERE ra.name = 'Bahrain Grand Prix' AND ra.year = 2007 AND r.position IS NULL;",
            "normalized": "SELECT COUNT(*) AS not_finished_drivers_count\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nWHERE ra.name = 'Bahrain Grand Prix'\n  AND ra.year = 2007\n  AND r.position IS NULL;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Show me the season page of year when the race No. 901 took place.",
        "reference_sql_query": {
            "raw": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.\"raceId\" = 901",
            "normalized": "SELECT T2.url\nFROM races AS T1\nINNER JOIN seasons AS T2 ON T2.year = T1.year\nWHERE T1.\"raceId\" = 901"
        },
        "generated_sql_query": {
            "raw": "SELECT s.*\nFROM races r\nJOIN seasons s ON r.year = s.year\nWHERE r.raceId = 901;",
            "normalized": "SELECT s.*\nFROM races r\nJOIN seasons s ON r.year = s.year\nWHERE r.raceId = 901;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the race happened on 2015/11/29, how many drivers finished the game?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.\"driverId\") FROM races AS T1 INNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\" WHERE T1.date = '2015-11-29' AND T2.\"time\" IS NOT NULL",
            "normalized": "SELECT COUNT(T2.\"driverId\")\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nWHERE T1.date = '2015-11-29'\n  AND T2.\"time\" IS NOT NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT driverId) AS drivers_finished\nFROM results\nWHERE raceId = (\n    SELECT raceId\n    FROM races\n    WHERE date = '2015-11-29'\n);",
            "normalized": "SELECT COUNT(DISTINCT driverId) AS drivers_finished\nFROM results\nWHERE raceId =\n    (SELECT raceId\n     FROM races\n     WHERE date = '2015-11-29');"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "reference_sql_query": {
            "raw": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T2.\"raceId\" = 592 AND T2.\"time\" IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
            "normalized": "SELECT T1.forename,\n       T1.surname\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T2.\"raceId\" = 592\n  AND T2.\"time\" IS NOT NULL\n  AND T1.dob IS NOT NULL\nORDER BY T1.dob ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname, d.dob\nFROM public.results r\nJOIN public.drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 592 AND r.position IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;",
            "normalized": "SELECT d.forename,\n       d.surname,\n       d.dob\nFROM public.results r\nJOIN public.drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 592\n  AND r.position IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.forename, T2.surname, T2.url FROM \"lapTimes\" AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 161 AND T1.\"time\" LIKE '1:27%'",
            "normalized": "SELECT DISTINCT T2.forename,\n                T2.surname,\n                T2.url\nFROM \"lapTimes\" AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 161\n  AND T1.\"time\" LIKE '1:27%'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.url\nFROM public.\"lapTimes\" lt\nJOIN public.drivers d ON lt.driverId = d.driverId\nWHERE lt.raceId = 161 AND lt.time = '0:01:27';",
            "normalized": "SELECT d.url\nFROM public.\"lapTimes\" lt\nJOIN public.drivers d ON lt.driverId = d.driverId\nWHERE lt.raceId = 161\n  AND lt.time = '0:01:27';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "reference_sql_query": {
            "raw": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T2.\"raceId\" = 933 AND T2.\"fastestLapTime\" IS NOT NULL ORDER BY T2.\"fastestLapSpeed\" DESC LIMIT 1",
            "normalized": "SELECT T1.nationality\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T2.\"raceId\" = 933\n  AND T2.\"fastestLapTime\" IS NOT NULL\nORDER BY T2.\"fastestLapSpeed\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.nationality\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;",
            "normalized": "SELECT d.nationality\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 933\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T2.name = 'Malaysian Grand Prix'",
            "normalized": "SELECT DISTINCT T1.lat,\n                T1.lng\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T2.name = 'Malaysian Grand Prix'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.location, c.lat, c.lng \nFROM public.circuits c\nJOIN public.races r ON c.circuitId = r.\"circuitId\"\nWHERE r.name = 'Malaysian Grand Prix';",
            "normalized": "SELECT c.location,\n       c.lat,\n       c.lng\nFROM public.circuits c\nJOIN public.races r ON c.circuitId = r.\"circuitId\"\nWHERE r.name = 'Malaysian Grand Prix';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
        "reference_sql_query": {
            "raw": "SELECT T2.url FROM \"constructorResults\" AS T1 INNER JOIN constructors AS T2 ON T2.\"constructorId\" = T1.\"constructorId\" WHERE T1.\"raceId\" = 9 ORDER BY T1.points DESC LIMIT 1",
            "normalized": "SELECT T2.url\nFROM \"constructorResults\" AS T1\nINNER JOIN constructors AS T2 ON T2.\"constructorId\" = T1.\"constructorId\"\nWHERE T1.\"raceId\" = 9\nORDER BY T1.points DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.url \nFROM public.\"constructorResults\" cr\nJOIN public.constructors c ON cr.constructorId = c.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;",
            "normalized": "SELECT c.url\nFROM public.\"constructorResults\" cr\nJOIN public.constructors c ON cr.constructorId = c.constructorId\nWHERE cr.raceId = 9\nORDER BY cr.points DESC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What's Lucas di Grassi's Q1 result in the race No. 345?",
        "reference_sql_query": {
            "raw": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 345 AND T2.forename = 'Lucas' AND T2.surname = 'di Grassi'",
            "normalized": "SELECT T1.q1\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 345\n  AND T2.forename = 'Lucas'\n  AND T2.surname = 'di Grassi'"
        },
        "generated_sql_query": {
            "raw": "SELECT q1 \nFROM public.qualifying \nWHERE \"driverId\" = (SELECT DISTINCT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driverId\" = (SELECT \"driverId\" FROM public.qualifying WHERE \"driver",
            "normalized": "SELECT q1\nFROM public.qualifying\nWHERE \"driverId\" = (\n  SELECT DISTINCT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driverId\" = (\n  SELECT \"driverId\"\n  FROM public.qualifying WHERE \"driver"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the driver who had the Q2 time as 0:01:15 in race No. 347, where is he from?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 347 AND T1.q2 LIKE '1:15%'",
            "normalized": "SELECT DISTINCT T2.nationality\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 347\n  AND T1.q2 LIKE '1:15%'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.nationality \nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.q2 = '0:01:15' AND q.raceId = 347;",
            "normalized": "SELECT d.nationality\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.q2 = '0:01:15'\n  AND q.raceId = 347;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?",
        "reference_sql_query": {
            "raw": "SELECT T2.code FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 45 AND T1.q3 LIKE '1:33%'",
            "normalized": "SELECT T2.code\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 45\n  AND T1.q3 LIKE '1:33%'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.code\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 45 AND q.q3 = '0:01:33';",
            "normalized": "SELECT d.code\nFROM qualifying q\nJOIN drivers d ON q.driverId = d.driverId\nWHERE q.raceId = 45\n  AND q.q3 = '0:01:33';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What is the actual finish time for Bruce McLaren in the race No.743?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"time\" FROM drivers AS T1 INNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T2.\"raceId\" = 743 AND T1.forename = 'Bruce' AND T1.surname = 'McLaren'",
            "normalized": "SELECT T2.\"time\"\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T2.\"raceId\" = 743\n  AND T1.forename = 'Bruce'\n  AND T1.surname = 'McLaren'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because it does not contain any information about Bruce McLaren or any driver names associated with driver IDs.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because it does NOT contain ANY information about Bruce McLaren\nOR ANY driver NAMES associated WITH driver IDs."
        },
        "db_id": "formula_1"
    },
    {
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "reference_sql_query": {
            "raw": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\" INNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\" WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.\"position\" = 2",
            "normalized": "SELECT T3.forename,\n       T3.surname\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nINNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\"\nWHERE T1.year = 2006\n  AND T1.name = 'San Marino Grand Prix'\n  AND T2.\"position\" = 2"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2006 AND ra.name = 'San Marino Grand Prix' AND r.positionOrder = 2;",
            "normalized": "SELECT d.forename,\n       d.surname\nFROM results r\nJOIN races ra ON r.raceId = ra.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2006\n  AND ra.name = 'San Marino Grand Prix'\n  AND r.positionOrder = 2;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Show me the season page of year when the race No. 901 took place.",
        "reference_sql_query": {
            "raw": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.\"raceId\" = 901",
            "normalized": "SELECT T2.url\nFROM races AS T1\nINNER JOIN seasons AS T2 ON T2.year = T1.year\nWHERE T1.\"raceId\" = 901"
        },
        "generated_sql_query": {
            "raw": "SELECT s.*\nFROM races r\nJOIN seasons s ON r.year = s.year\nWHERE r.raceId = 901;",
            "normalized": "SELECT s.*\nFROM races r\nJOIN seasons s ON r.year = s.year\nWHERE r.raceId = 901;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the race happened in 2015/11/29, how many drivers did not finish the game?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.\"driverId\") FROM races AS T1 INNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\" WHERE T1.date = '2015-11-29' AND T2.\"time\" IS NULL",
            "normalized": "SELECT COUNT(T2.\"driverId\")\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nWHERE T1.date = '2015-11-29'\n  AND T2.\"time\" IS NULL"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT d.\"driverId\") AS non_finishers\nFROM public.results r\nJOIN public.races ra ON r.\"raceId\" = ra.\"raceId\"\nJOIN public.drivers d ON r.\"driverId\" = d.\"driverId\"\nWHERE ra.\"date\" = '2015-11-29' AND r.\"statusId\" != 1;",
            "normalized": "SELECT COUNT(DISTINCT d.\"driverId\") AS non_finishers\nFROM public.results r\nJOIN public.races ra ON r.\"raceId\" = ra.\"raceId\"\nJOIN public.drivers d ON r.\"driverId\" = d.\"driverId\"\nWHERE ra.\"date\" = '2015-11-29'\n  AND r.\"statusId\" != 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "reference_sql_query": {
            "raw": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T2.\"raceId\" = 872 AND T2.\"time\" IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
            "normalized": "SELECT T1.forename,\n       T1.surname\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T2.\"raceId\" = 872\n  AND T2.\"time\" IS NOT NULL\nORDER BY T1.dob DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname, d.dob\nFROM public.results r\nJOIN public.drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 872\nORDER BY d.dob DESC\nLIMIT 1;",
            "normalized": "SELECT d.forename,\n       d.surname,\n       d.dob\nFROM public.results r\nJOIN public.drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 872\nORDER BY d.dob DESC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Who was the driver that got the best lap time in the race No. 348? Give his full name.",
        "reference_sql_query": {
            "raw": "SELECT T2.forename, T2.surname FROM \"lapTimes\" AS T1 INNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.\"raceId\" = 348 ORDER BY T1.\"time\" ASC LIMIT 1",
            "normalized": "SELECT T2.forename,\n       T2.surname\nFROM \"lapTimes\" AS T1\nINNER JOIN drivers AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.\"raceId\" = 348\nORDER BY T1.\"time\" ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname\nFROM public.\"lapTimes\" lt\nJOIN public.drivers d ON lt.\"driverId\" = d.\"driverId\"\nWHERE lt.\"raceId\" = 348\nORDER BY lt.milliseconds ASC\nLIMIT 1;",
            "normalized": "SELECT d.forename,\n       d.surname\nFROM public.\"lapTimes\" lt\nJOIN public.drivers d ON lt.\"driverId\" = d.\"driverId\"\nWHERE lt.\"raceId\" = 348\nORDER BY lt.milliseconds ASC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the driver who set the fastest lap speed, what is his nationality?",
        "reference_sql_query": {
            "raw": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\" ORDER BY T2.\"fastestLapSpeed\" DESC LIMIT 1",
            "normalized": "SELECT T1.nationality\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nORDER BY T2.\"fastestLapSpeed\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.nationality\nFROM public.results r\nJOIN public.drivers d ON r.driverId = d.driverId\nWHERE r.fastestLapSpeed = (\n    SELECT MAX(CAST(fastestLapSpeed AS FLOAT))\n    FROM public.results\n)\nLIMIT 1;",
            "normalized": "SELECT d.nationality\nFROM public.results r\nJOIN public.drivers d ON r.driverId = d.driverId\nWHERE r.fastestLapSpeed =\n    (SELECT MAX(CAST(fastestLapSpeed AS FLOAT))\n     FROM public.results)\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "reference_sql_query": {
            "raw": "SELECT (SUM(CASE WHEN T2.\"raceId\" = '853' THEN CAST(T2.\"fastestLapSpeed\" AS DOUBLE PRECISION) ELSE 0::DOUBLE PRECISION END) - SUM(CASE WHEN T2.\"raceId\" = '854' THEN CAST(T2.\"fastestLapSpeed\" AS DOUBLE PRECISION) ELSE 0::DOUBLE PRECISION END)) * 100 / SUM(CASE WHEN T2.\"raceId\" = '853' THEN CAST(T2.\"fastestLapSpeed\" AS DOUBLE PRECISION) ELSE 0::DOUBLE PRECISION END) AS percentage_difference FROM drivers AS T1 INNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\" WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta';",
            "normalized": "SELECT (SUM(CASE\n                WHEN T2.\"raceId\" = '853' THEN CAST(T2.\"fastestLapSpeed\" AS DOUBLE PRECISION)\n                ELSE 0::DOUBLE PRECISION\n            END) - SUM(CASE\n                           WHEN T2.\"raceId\" = '854' THEN CAST(T2.\"fastestLapSpeed\" AS DOUBLE PRECISION)\n                           ELSE 0::DOUBLE PRECISION\n                       END)) * 100 / SUM(CASE\n                                             WHEN T2.\"raceId\" = '853' THEN CAST(T2.\"fastestLapSpeed\" AS DOUBLE PRECISION)\n                                             ELSE 0::DOUBLE PRECISION\n                                         END) AS percentage_difference\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T2.\"driverId\" = T1.\"driverId\"\nWHERE T1.forename = 'Paul'\n  AND T1.surname = 'di Resta';"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query. The context does not provide information to directly link Paul di Resta's driverId or any specific details about the fastest lap speed for his races. Additionally, the context does not specify which columns or tables contain information about the fastest lap speed necessary to calculate the percentage difference.",
            "normalized": "The provided context IS insufficient TO generate the SQL query. The context does NOT provide information TO directly LINK Paul di Resta's driverId\nOR ANY SPECIFIC details about the fastest lap speed\nFOR his races. Additionally,\n    the context does NOT specify which columns\nOR TABLES contain information about the fastest lap speed necessary TO calculate the percentage difference."
        },
        "db_id": "formula_1"
    },
    {
        "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(CASE WHEN T2.\"time\" IS NOT NULL THEN T2.\"driverId\" END) AS DOUBLE PRECISION) * 100 / COUNT(T2.\"driverId\") FROM races AS T1 INNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\" WHERE T1.date = '1983-07-16'",
            "normalized": "SELECT CAST(COUNT(CASE\n                      WHEN T2.\"time\" IS NOT NULL THEN T2.\"driverId\"\n                  END) AS DOUBLE PRECISION) * 100 / COUNT(T2.\"driverId\")\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nWHERE T1.date = '1983-07-16'"
        },
        "generated_sql_query": {
            "raw": "SELECT d.driverId, d.forename, d.surname, \n       COUNT(CASE WHEN r.positionText = 'Finished' THEN 1 END)::FLOAT / COUNT(*) AS completion_rate\nFROM races ra\nJOIN results r ON ra.raceId = r.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.date = '1983-07-16'\nGROUP BY d.driverId, d.forename, d.surname;",
            "normalized": "SELECT d.driverId,\n       d.forename,\n       d.surname,\n       COUNT(CASE\n                 WHEN r.positionText = 'Finished' THEN 1\n             END)::FLOAT / COUNT(*) AS completion_rate\nFROM races ra\nJOIN results r ON ra.raceId = r.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.date = '1983-07-16'\nGROUP BY d.driverId,\n         d.forename,\n         d.surname;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Which year was the first Singapore Grand Prix?",
        "reference_sql_query": {
            "raw": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
            "normalized": "SELECT YEAR\nFROM races\nWHERE name = 'Singapore Grand Prix'\nORDER BY YEAR ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT MIN(year) AS first_singapore_gp_year\nFROM races\nWHERE name ILIKE '%Singapore Grand Prix%';",
            "normalized": "SELECT MIN(YEAR) AS first_singapore_gp_year\nFROM races\nWHERE name ILIKE '%Singapore Grand Prix%';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "reference_sql_query": {
            "raw": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
            "normalized": "SELECT name\nFROM races\nWHERE YEAR = 2005\nORDER BY name DESC"
        },
        "generated_sql_query": {
            "raw": "SELECT name \nFROM public.races \nWHERE year = 2005 \nORDER BY name DESC;",
            "normalized": "SELECT name\nFROM public.races\nWHERE YEAR = 2005\nORDER BY name DESC;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "List the names of all races that occurred in the earliest recorded year and month.",
        "reference_sql_query": {
            "raw": "SELECT name FROM races WHERE EXTRACT(YEAR FROM date) = ( SELECT EXTRACT(YEAR FROM date) FROM races ORDER BY date ASC LIMIT 1 ) AND EXTRACT(MONTH FROM date) = ( SELECT EXTRACT(MONTH FROM date) FROM races ORDER BY date ASC LIMIT 1 )",
            "normalized": "SELECT name\nFROM races\nWHERE EXTRACT(YEAR\n              FROM date) =\n    (SELECT EXTRACT(YEAR\n                    FROM date)\n     FROM races\n     ORDER BY date ASC\n     LIMIT 1)\n  AND EXTRACT(MONTH\n              FROM date) =\n    (SELECT EXTRACT(MONTH\n                    FROM date)\n     FROM races\n     ORDER BY date ASC\n     LIMIT 1)"
        },
        "generated_sql_query": {
            "raw": "WITH earliest_date AS (\n    SELECT MIN(date) AS min_date\n    FROM public.races\n),\nearliest_races AS (\n    SELECT name\n    FROM public.races\n    WHERE date = (SELECT min_date FROM earliest_date)\n)\nSELECT name\nFROM earliest_races;",
            "normalized": "WITH earliest_date AS\n  (SELECT MIN(date) AS min_date\n   FROM public.races),\n     earliest_races AS\n  (SELECT name\n   FROM public.races\n   WHERE date =\n       (SELECT min_date\n        FROM earliest_date))\nSELECT name\nFROM earliest_races;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "State the name and date of the last round of race in year 1999.",
        "reference_sql_query": {
            "raw": "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1",
            "normalized": "SELECT name, date\nFROM races\nWHERE YEAR = 1999\nORDER BY round DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT name, date\nFROM public.races\nWHERE year = 1999\nORDER BY round DESC\nLIMIT 1;",
            "normalized": "SELECT name, date\nFROM public.races\nWHERE YEAR = 1999\nORDER BY round DESC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Which year has the most number of races?",
        "reference_sql_query": {
            "raw": "SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1",
            "normalized": "SELECT YEAR\nFROM races\nGROUP BY YEAR\nORDER BY COUNT(round) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT year, COUNT(*) AS number_of_races\nFROM public.races\nGROUP BY year\nORDER BY number_of_races DESC\nLIMIT 1;",
            "normalized": "SELECT YEAR,\n       COUNT(*) AS number_of_races\nFROM public.races\nGROUP BY YEAR\nORDER BY number_of_races DESC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "reference_sql_query": {
            "raw": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
            "normalized": "SELECT name\nFROM races\nWHERE YEAR = 2017\n  AND name NOT IN\n    (SELECT name\n     FROM races\n     WHERE YEAR = 2000)"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT r1.name \nFROM public.races r1\nWHERE r1.year = 2017\nAND r1.name NOT IN (\n    SELECT r2.name \n    FROM public.races r2 \n    WHERE r2.year = 2000\n);",
            "normalized": "SELECT DISTINCT r1.name\nFROM public.races r1\nWHERE r1.year = 2017\n  AND r1.name NOT IN\n    (SELECT r2.name\n     FROM public.races r2\n     WHERE r2.year = 2000);"
        },
        "db_id": "formula_1"
    },
    {
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "reference_sql_query": {
            "raw": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
            "normalized": "SELECT T1.country,\n       T1.location\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.year ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.country, c.name AS circuit_name, c.location\nFROM races r\nJOIN circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE r.name = 'European Grand Prix'\nORDER BY r.year, r.round\nLIMIT 1;",
            "normalized": "SELECT c.country,\n       c.name AS circuit_name,\n       c.location\nFROM races r\nJOIN circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE r.name = 'European Grand Prix'\nORDER BY r.year,\n         r.round\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
        "reference_sql_query": {
            "raw": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
            "normalized": "SELECT T2.date\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.name = 'Brands Hatch'\n  AND T2.name = 'British Grand Prix'\nORDER BY T2.year DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the circuits, including circuit names like \"Brands Hatch,\" in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the circuits,\n                                                                                                     INCLUDING circuit NAMES like \"Brands Hatch,\" IN the given tables."
        },
        "db_id": "formula_1"
    },
    {
        "question": "How many seasons has Silverstone Circuit hosted the United Kindom grand prix?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.\"circuitId\") FROM circuits AS T1 INNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\" WHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix'",
            "normalized": "SELECT COUNT(T2.\"circuitId\")\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.\"circuitId\" = T1.\"circuitId\"\nWHERE T1.name = 'Silverstone Circuit'\n  AND T2.name = 'British Grand Prix'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT r.year) AS number_of_seasons\nFROM races r\nJOIN circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.name = 'Silverstone Circuit' AND r.name ILIKE '%United Kingdom Grand Prix%';",
            "normalized": "SELECT COUNT(DISTINCT r.year) AS number_of_seasons\nFROM races r\nJOIN circuits c ON r.\"circuitId\" = c.\"circuitId\"\nWHERE c.name = 'Silverstone Circuit'\n  AND r.name ILIKE '%United Kingdom Grand Prix%';"
        },
        "db_id": "formula_1"
    },
    {
        "question": "State the driver with the most points scored. Find his full name with that points.",
        "reference_sql_query": {
            "raw": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN \"driverStandings\" AS T2 ON T2.\"raceId\" = T1.\"raceId\" INNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\" ORDER BY T2.points DESC LIMIT 1",
            "normalized": "SELECT T3.forename,\n       T3.surname,\n       T2.points\nFROM races AS T1\nINNER JOIN \"driverStandings\" AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nINNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\"\nORDER BY T2.points DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname, MAX(ds.points) as max_points\nFROM public.\"driverStandings\" ds\nJOIN public.drivers d ON ds.driverId = d.driverId\nGROUP BY d.forename, d.surname\nORDER BY max_points DESC\nLIMIT 1;",
            "normalized": "SELECT d.forename,\n       d.surname,\n       MAX(ds.points) AS max_points\nFROM public.\"driverStandings\" ds\nJOIN public.drivers d ON ds.driverId = d.driverId\nGROUP BY d.forename,\n         d.surname\nORDER BY max_points DESC\nLIMIT 1;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "Name the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix.",
        "reference_sql_query": {
            "raw": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN \"driverStandings\" AS T2 ON T2.\"raceId\" = T1.\"raceId\" INNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\" WHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017 ORDER BY T2.points DESC LIMIT 3",
            "normalized": "SELECT T3.forename,\n       T3.surname,\n       T2.points\nFROM races AS T1\nINNER JOIN \"driverStandings\" AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nINNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\"\nWHERE T1.name = 'Chinese Grand Prix'\n  AND T1.year = 2017\nORDER BY T2.points DESC\nLIMIT 3"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname, ds.points\nFROM driverStandings ds\nJOIN races r ON ds.raceId = r.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE r.year = 2017 AND r.name = 'Chinese Grand Prix'\nORDER BY ds.points DESC\nLIMIT 3;",
            "normalized": "SELECT d.forename,\n       d.surname,\n       ds.points\nFROM driverStandings ds\nJOIN races r ON ds.raceId = r.raceId\nJOIN drivers d ON ds.driverId = d.driverId\nWHERE r.year = 2017\n  AND r.name = 'Chinese Grand Prix'\nORDER BY ds.points DESC\nLIMIT 3;"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "reference_sql_query": {
            "raw": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN \"lapTimes\" AS T2 ON T1.\"driverId\" = T2.\"driverId\" INNER JOIN races AS T3 ON T2.\"raceId\" = T3.\"raceId\" ORDER BY T2.milliseconds ASC LIMIT 1",
            "normalized": "SELECT T2.milliseconds,\n       T1.forename,\n       T1.surname,\n       T3.name\nFROM drivers AS T1\nINNER JOIN \"lapTimes\" AS T2 ON T1.\"driverId\" = T2.\"driverId\"\nINNER JOIN races AS T3 ON T2.\"raceId\" = T3.\"raceId\"\nORDER BY T2.milliseconds ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT d.forename, d.surname, r.name AS race_name, lt.time\nFROM public.\"lapTimes\" lt\nJOIN public.drivers d ON lt.driverId = d.driverId\nJOIN public.races r ON lt.raceId = r.raceId\nWHERE lt.milliseconds = (SELECT MIN(milliseconds) FROM public.\"lapTimes\");",
            "normalized": "SELECT d.forename,\n       d.surname,\n       r.name AS race_name,\n       lt.time\nFROM public.\"lapTimes\" lt\nJOIN public.drivers d ON lt.driverId = d.driverId\nJOIN public.races r ON lt.raceId = r.raceId\nWHERE lt.milliseconds =\n    (SELECT MIN(milliseconds)\n     FROM public.\"lapTimes\");"
        },
        "db_id": "formula_1"
    },
    {
        "question": "What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T2.milliseconds) FROM races AS T1 INNER JOIN \"lapTimes\" AS T2 ON T2.\"raceId\" = T1.\"raceId\" INNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\" WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.year = 2009 AND T1.name = 'Malaysian Grand Prix'",
            "normalized": "SELECT AVG(T2.milliseconds)\nFROM races AS T1\nINNER JOIN \"lapTimes\" AS T2 ON T2.\"raceId\" = T1.\"raceId\"\nINNER JOIN drivers AS T3 ON T3.\"driverId\" = T2.\"driverId\"\nWHERE T3.forename = 'Lewis'\n  AND T3.surname = 'Hamilton'\n  AND T1.year = 2009\n  AND T1.name = 'Malaysian Grand Prix'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because the tables given do not contain data about driver names or the specific race names. Therefore, it is not possible to directly generate a SQL query to get the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix without additional information linking driver names to `driverId` and race names to `raceId`.",
            "normalized": "The provided context IS insufficient because the TABLES given DO NOT contain DATA about driver NAMES\nOR the SPECIFIC race names. Therefore,\n                it IS NOT possible TO directly generate a SQL query TO GET the average lap TIME\nFOR Lewis Hamilton IN the 2009 Malaysian Grand Prix WITHOUT additional information linking driver NAMES TO `driverId`\nAND race NAMES TO `raceId`."
        },
        "db_id": "formula_1"
    },
    {
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "reference_sql_query": {
            "raw": "SELECT player_api_id FROM \"Player_Attributes\" ORDER BY overall_rating DESC LIMIT 1",
            "normalized": "SELECT player_api_id\nFROM \"Player_Attributes\"\nORDER BY overall_rating DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT player_api_id, MAX(overall_rating) AS highest_overall_rating\nFROM public.\"Player_Attributes\"\nGROUP BY player_api_id\nORDER BY highest_overall_rating DESC\nLIMIT 1;",
            "normalized": "SELECT player_api_id,\n       MAX(overall_rating) AS highest_overall_rating\nFROM public.\"Player_Attributes\"\nGROUP BY player_api_id\nORDER BY highest_overall_rating DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the height of the tallest player? Indicate his name.",
        "reference_sql_query": {
            "raw": "SELECT player_name FROM \"Player\" ORDER BY height DESC LIMIT 1",
            "normalized": "SELECT player_name\nFROM \"Player\"\nORDER BY height DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT player_name, height\nFROM public.\"Player\"\nORDER BY height DESC\nLIMIT 1;",
            "normalized": "SELECT player_name,\n       height\nFROM public.\"Player\"\nORDER BY height DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the preferred foot when attacking of the player with the lowest potential?",
        "reference_sql_query": {
            "raw": "SELECT preferred_foot FROM \"Player_Attributes\" WHERE potential IS NOT NULL ORDER BY potential ASC LIMIT 1",
            "normalized": "SELECT preferred_foot\nFROM \"Player_Attributes\"\nWHERE potential IS NOT NULL\nORDER BY potential ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT preferred_foot \nFROM public.\"Player_Attributes\" \nORDER BY potential ASC \nLIMIT 1;",
            "normalized": "SELECT preferred_foot\nFROM public.\"Player_Attributes\"\nORDER BY potential ASC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Among the players with an overall rating between 60 to 65, how many players whose going to be in all of your attack moves instead of defensing?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM \"Player_Attributes\" WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'",
            "normalized": "SELECT COUNT(id)\nFROM \"Player_Attributes\"\nWHERE overall_rating BETWEEN 60 AND 65\n  AND defensive_work_rate = 'low'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.\"Player_Attributes\" \nWHERE overall_rating BETWEEN 60 AND 65 \nAND preferred_foot = 'Right' \nAND attacking_work_rate = 'High' \nAND defensive_work_rate = 'Low';",
            "normalized": "SELECT COUNT(*)\nFROM public.\"Player_Attributes\"\nWHERE overall_rating BETWEEN 60 AND 65\n  AND preferred_foot = 'Right'\n  AND attacking_work_rate = 'High'\n  AND defensive_work_rate = 'Low';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
        "reference_sql_query": {
            "raw": "SELECT id FROM \"Player_Attributes\" ORDER BY crossing DESC LIMIT 5",
            "normalized": "SELECT id\nFROM \"Player_Attributes\"\nORDER BY crossing DESC\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "SELECT player_api_id \nFROM public.\"Player_Attributes\" \nORDER BY crossing DESC \nLIMIT 5;",
            "normalized": "SELECT player_api_id\nFROM public.\"Player_Attributes\"\nORDER BY crossing DESC\nLIMIT 5;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Give the name of the league had the most goals in the 2016 season?",
        "reference_sql_query": {
            "raw": "SELECT t2.name FROM \"Match\" AS t1 INNER JOIN \"League\" AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' GROUP BY t2.name ORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC LIMIT 1",
            "normalized": "SELECT t2.name\nFROM \"Match\" AS t1\nINNER JOIN \"League\" AS t2 ON t1.league_id = t2.id\nWHERE t1.season = '2015/2016'\nGROUP BY t2.name\nORDER BY SUM(t1.home_team_goal + t1.away_team_goal) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT l.name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM public.\"Match\" m\nJOIN public.\"League\" l ON m.league_id = l.id\nWHERE m.season = '2016'\nGROUP BY l.name\nORDER BY total_goals DESC\nLIMIT 1;",
            "normalized": "SELECT l.name,\n       SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM public.\"Match\" m\nJOIN public.\"League\" l ON m.league_id = l.id\nWHERE m.season = '2016'\nGROUP BY l.name\nORDER BY total_goals DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Which home team had lost the fewest matches in the 2016 season?",
        "reference_sql_query": {
            "raw": "SELECT teamDetails.\"team_long_name\" FROM \"Match\" AS matchData INNER JOIN \"Team\" AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0 GROUP BY matchData.home_team_api_id, teamDetails.\"team_long_name\" ORDER BY COUNT(*) ASC LIMIT 1",
            "normalized": "SELECT teamDetails.\"team_long_name\"\nFROM \"Match\" AS matchData\nINNER JOIN \"Team\" AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016'\n  AND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY matchData.home_team_api_id,\n         teamDetails.\"team_long_name\"\nORDER BY COUNT(*) ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT t.team_long_name AS home_team, COUNT(m.id) AS losses\nFROM public.\"Match\" m\nJOIN public.\"Team\" t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2016' AND m.home_team_goal < m.away_team_goal\nGROUP BY t.team_long_name\nORDER BY losses ASC\nLIMIT 1;",
            "normalized": "SELECT t.team_long_name AS home_team,\n       COUNT(m.id) AS losses\nFROM public.\"Match\" m\nJOIN public.\"Team\" t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2016'\n  AND m.home_team_goal < m.away_team_goal\nGROUP BY t.team_long_name\nORDER BY losses ASC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "reference_sql_query": {
            "raw": "SELECT t2.player_name FROM \"Player_Attributes\" AS t1 INNER JOIN \"Player\" AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
            "normalized": "SELECT t2.player_name\nFROM \"Player_Attributes\" AS t1\nINNER JOIN \"Player\" AS t2 ON t1.id = t2.id\nORDER BY t1.penalties DESC\nLIMIT 10"
        },
        "generated_sql_query": {
            "raw": "SELECT P.player_name, SUM(PA.penalties) AS total_penalties\nFROM public.\"Player\" P\nJOIN public.\"Player_Attributes\" PA ON P.player_api_id = PA.player_api_id\nGROUP BY P.player_name\nORDER BY total_penalties DESC\nLIMIT 10;",
            "normalized": "SELECT P.player_name,\n       SUM(PA.penalties) AS total_penalties\nFROM public.\"Player\" P\nJOIN public.\"Player_Attributes\" PA ON P.player_api_id = PA.player_api_id\nGROUP BY P.player_name\nORDER BY total_penalties DESC\nLIMIT 10;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "reference_sql_query": {
            "raw": "SELECT t1.\"buildUpPlaySpeed\" FROM \"Team_Attributes\" AS t1 INNER JOIN \"Team\" AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY t1.\"buildUpPlaySpeed\" ASC LIMIT 4",
            "normalized": "SELECT t1.\"buildUpPlaySpeed\"\nFROM \"Team_Attributes\" AS t1\nINNER JOIN \"Team\" AS t2 ON t1.team_api_id = t2.team_api_id\nORDER BY t1.\"buildUpPlaySpeed\" ASC\nLIMIT 4"
        },
        "generated_sql_query": {
            "raw": "SELECT t.team_long_name, ta.\"buildUpPlaySpeed\"\nFROM \"Team_Attributes\" ta\nJOIN \"Team\" t ON ta.team_api_id = t.team_api_id\nORDER BY ta.\"buildUpPlaySpeed\" DESC\nLIMIT 4;",
            "normalized": "SELECT t.team_long_name,\n       ta.\"buildUpPlaySpeed\"\nFROM \"Team_Attributes\" ta\nJOIN \"Team\" t ON ta.team_api_id = t.team_api_id\nORDER BY ta.\"buildUpPlaySpeed\" DESC\nLIMIT 4;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "reference_sql_query": {
            "raw": "SELECT t2.name FROM \"Match\" AS t1 INNER JOIN \"League\" AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
            "normalized": "SELECT t2.name\nFROM \"Match\" AS t1\nINNER JOIN \"League\" AS t2 ON t1.league_id = t2.id\nWHERE t1.season = '2015/2016'\n  AND t1.home_team_goal = t1.away_team_goal\nGROUP BY t2.name\nORDER BY COUNT(t1.id) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT l.name, COUNT(*) AS draw_count\nFROM public.\"Match\" m\nJOIN public.\"League\" l ON m.league_id = l.id\nWHERE m.season = '2016'\nAND m.home_team_goal = m.away_team_goal\nGROUP BY l.name\nORDER BY draw_count DESC\nLIMIT 1;",
            "normalized": "SELECT l.name,\n       COUNT(*) AS draw_count\nFROM public.\"Match\" m\nJOIN public.\"League\" l ON m.league_id = l.id\nWHERE m.season = '2016'\n  AND m.home_team_goal = m.away_team_goal\nGROUP BY l.name\nORDER BY draw_count DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT (CURRENT_DATE - T2.birthday::DATE) AS age FROM \"Player_Attributes\" AS T1 INNER JOIN \"Player\" AS T2 ON T1.player_api_id = T2.player_api_id WHERE EXTRACT(YEAR FROM T1.\"date\"::DATE) >= '2013' AND EXTRACT(YEAR FROM T1.\"date\"::DATE) <= '2015' AND T1.sprint_speed >= 97",
            "normalized": "SELECT DISTINCT (CURRENT_DATE - T2.birthday::DATE) AS age\nFROM \"Player_Attributes\" AS T1\nINNER JOIN \"Player\" AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE EXTRACT(YEAR\n              FROM T1.\"date\"::DATE) >= '2013'\n  AND EXTRACT(YEAR\n              FROM T1.\"date\"::DATE) <= '2015'\n  AND T1.sprint_speed >= 97"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    P.player_name,\n    EXTRACT(YEAR FROM AGE(PA.date::date, P.birthday::date)) AS age\nFROM \n    public.\"Player\" P\nJOIN \n    public.\"Player_Attributes\" PA ON P.player_api_id = PA.player_api_id\nWHERE \n    PA.sprint_speed >= 97\n    AND PA.date BETWEEN '2013-01-01' AND '2015-12-31';",
            "normalized": "SELECT P.player_name,\n       EXTRACT(YEAR\n               FROM AGE(PA.date::date, P.birthday::date)) AS age\nFROM public.\"Player\" P\nJOIN public.\"Player_Attributes\" PA ON P.player_api_id = PA.player_api_id\nWHERE PA.sprint_speed >= 97\n  AND PA.date BETWEEN '2013-01-01' AND '2015-12-31';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "reference_sql_query": {
            "raw": "SELECT t2.name, t1.max_count FROM \"League\" AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM \"Match\" GROUP BY league_id) AS subquery GROUP BY league_id) AS t1 ON t1.league_id = t2.id",
            "normalized": "SELECT t2.name,\n       t1.max_count\nFROM \"League\" AS t2\nJOIN\n  (SELECT league_id,\n          MAX(cnt) AS max_count\n   FROM\n     (SELECT league_id,\n             COUNT(id) AS cnt\n      FROM \"Match\"\n      GROUP BY league_id) AS subquery\n   GROUP BY league_id) AS t1 ON t1.league_id = t2.id"
        },
        "generated_sql_query": {
            "raw": "SELECT l.name AS league_name, COUNT(m.id) AS total_matches\nFROM public.\"League\" l\nJOIN public.\"Match\" m ON l.id = m.league_id\nGROUP BY l.name\nORDER BY total_matches DESC\nLIMIT 1;",
            "normalized": "SELECT l.name AS league_name,\n       COUNT(m.id) AS total_matches\nFROM public.\"League\" l\nJOIN public.\"Match\" m ON l.id = m.league_id\nGROUP BY l.name\nORDER BY total_matches DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the average height of players born between 1990 and 1995?",
        "reference_sql_query": {
            "raw": "SELECT SUM(height) / COUNT(id) FROM \"Player\" WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
            "normalized": "SELECT SUM(height) / COUNT(id)\nFROM \"Player\"\nWHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(height) AS average_height\nFROM public.\"Player\"\nWHERE birthday BETWEEN '1990-01-01' AND '1995-12-31';",
            "normalized": "SELECT AVG(height) AS average_height\nFROM public.\"Player\"\nWHERE birthday BETWEEN '1990-01-01' AND '1995-12-31';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the players' api id who had the highest above average overall ratings in 2010.",
        "reference_sql_query": {
            "raw": "SELECT player_api_id FROM \"Player_Attributes\" WHERE SUBSTR(\"date\", 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1",
            "normalized": "SELECT player_api_id\nFROM \"Player_Attributes\"\nWHERE SUBSTR(\"date\", 1, 4) = '2010'\nORDER BY overall_rating DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "WITH PlayerAverageRating AS (\n    SELECT \n        player_api_id,\n        AVG(overall_rating) AS avg_rating\n    FROM \n        public.\"Player_Attributes\"\n    WHERE \n        date LIKE '2010%'\n    GROUP BY \n        player_api_id\n),\nHighestAboveAverage AS (\n    SELECT \n        player_api_id,\n        overall_rating,\n        avg_rating\n    FROM \n        public.\"Player_Attributes\" pa\n    JOIN \n        PlayerAverageRating par ON pa.player_api_id = par.player_api_id\n    WHERE \n        pa.date LIKE '2010%' AND overall_rating > avg_rating\n)\nSELECT \n    player_api_id\nFROM \n    HighestAboveAverage\nORDER BY \n    overall_rating DESC\nLIMIT 1;",
            "normalized": "WITH PlayerAverageRating AS\n  (SELECT player_api_id,\n          AVG(overall_rating) AS avg_rating\n   FROM public.\"Player_Attributes\"\n   WHERE date LIKE '2010%'\n   GROUP BY player_api_id),\n     HighestAboveAverage AS\n  (SELECT player_api_id,\n          overall_rating,\n          avg_rating\n   FROM public.\"Player_Attributes\" pa\n   JOIN PlayerAverageRating par ON pa.player_api_id = par.player_api_id\n   WHERE pa.date LIKE '2010%'\n     AND overall_rating > avg_rating)\nSELECT player_api_id\nFROM HighestAboveAverage\nORDER BY overall_rating DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT team_fifa_api_id FROM \"Team_Attributes\" WHERE \"buildUpPlaySpeed\" > 50 AND \"buildUpPlaySpeed\" < 60",
            "normalized": "SELECT DISTINCT team_fifa_api_id\nFROM \"Team_Attributes\"\nWHERE \"buildUpPlaySpeed\" > 50\n  AND \"buildUpPlaySpeed\" < 60"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT team_fifa_api_id \nFROM public.\"Team_Attributes\"\nWHERE \"buildUpPlaySpeed\" > 50 AND \"buildUpPlaySpeed\" < 60;",
            "normalized": "SELECT DISTINCT team_fifa_api_id\nFROM public.\"Team_Attributes\"\nWHERE \"buildUpPlaySpeed\" > 50\n  AND \"buildUpPlaySpeed\" < 60;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t4.\"team_long_name\" FROM \"Team_Attributes\" AS t3 INNER JOIN \"Team\" AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.\"date\", 1, 4) = '2012' AND t3.\"buildUpPlayPassing\" > ( SELECT CAST(SUM(t2.\"buildUpPlayPassing\") AS DOUBLE PRECISION) / COUNT(t1.id) FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id WHERE EXTRACT(YEAR FROM t2.\"date\"::DATE) = '2012')",
            "normalized": "SELECT DISTINCT t4.\"team_long_name\"\nFROM \"Team_Attributes\" AS t3\nINNER JOIN \"Team\" AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE SUBSTR(t3.\"date\", 1, 4) = '2012'\n  AND t3.\"buildUpPlayPassing\" >\n    (SELECT CAST(SUM(t2.\"buildUpPlayPassing\") AS DOUBLE PRECISION) / COUNT(t1.id)\n     FROM \"Team\" AS t1\n     INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id\n     WHERE EXTRACT(YEAR\n                   FROM t2.\"date\"::DATE) = '2012')"
        },
        "generated_sql_query": {
            "raw": "SELECT t.team_long_name\nFROM public.\"Team_Attributes\" ta\nJOIN public.\"Team\" t ON ta.team_fifa_api_id = t.team_fifa_api_id\nWHERE ta.date LIKE '2012%' AND ta.\"buildUpPlayPassing\" > (\n    SELECT AVG(\"buildUpPlayPassing\")\n    FROM public.\"Team_Attributes\"\n    WHERE date LIKE '2012%'\n)",
            "normalized": "SELECT t.team_long_name\nFROM public.\"Team_Attributes\" ta\nJOIN public.\"Team\" t ON ta.team_fifa_api_id = t.team_fifa_api_id\nWHERE ta.date LIKE '2012%'\n  AND ta.\"buildUpPlayPassing\" >\n    (SELECT AVG(\"buildUpPlayPassing\")\n     FROM public.\"Team_Attributes\"\n     WHERE date LIKE '2012%')"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(CASE WHEN t2.preferred_foot = 'left' THEN t1.id ELSE NULL END) AS DOUBLE PRECISION) * 100 / COUNT(t1.id) percent FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'",
            "normalized": "SELECT CAST(COUNT(CASE\n                      WHEN t2.preferred_foot = 'left' THEN t1.id\n                      ELSE NULL\n                  END) AS DOUBLE PRECISION) * 100 / COUNT(t1.id) percent\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE SUBSTR(t1.birthday, 1, 4) BETWEEN '1987' AND '1992'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(CASE WHEN preferred_foot = 'left' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_left_foot\nFROM \n    public.\"Player_Attributes\" pa\nJOIN \n    public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE \n    SUBSTRING(p.birthday, 1, 4)::INT BETWEEN 1987 AND 1992;",
            "normalized": "SELECT (COUNT(CASE\n                  WHEN preferred_foot = 'left' THEN 1\n              END) * 100.0 / COUNT(*)) AS percentage_left_foot\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE SUBSTRING(p.birthday, 1, 4)::INT BETWEEN 1987 AND 1992;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "reference_sql_query": {
            "raw": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM \"League\" AS t1 INNER JOIN \"Match\" AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
            "normalized": "SELECT t1.name,\n       SUM(t2.home_team_goal) + SUM(t2.away_team_goal)\nFROM \"League\" AS t1\nINNER JOIN \"Match\" AS t2 ON t1.id = t2.league_id\nGROUP BY t1.name\nORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC\nLIMIT 5"
        },
        "generated_sql_query": {
            "raw": "SELECT l.name AS league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM public.\"League\" l\nJOIN public.\"Match\" m ON l.id = m.league_id\nGROUP BY l.name\nORDER BY total_goals ASC\nLIMIT 5;",
            "normalized": "SELECT l.name AS league_name,\n       SUM(m.home_team_goal + m.away_team_goal) AS total_goals\nFROM public.\"League\" l\nJOIN public.\"Match\" m ON l.id = m.league_id\nGROUP BY l.name\nORDER BY total_goals ASC\nLIMIT 5;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Find the average number of long-shot done by Ahmed Samir Farag.",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(t2.long_shots) AS DOUBLE PRECISION) / COUNT(t2.\"date\") FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ahmed Samir Farag'",
            "normalized": "SELECT CAST(SUM(t2.long_shots) AS DOUBLE PRECISION) / COUNT(t2.\"date\")\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Ahmed Samir Farag'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query as there is no table that contains information about a person named Ahmed Samir Farag or associates a person with long-shots.",
            "normalized": "The provided context IS insufficient TO generate the SQL query AS there IS NO TABLE that CONTAINS information about a person named Ahmed Samir Farag\nOR associates a person WITH long-shots."
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "reference_sql_query": {
            "raw": "SELECT t1.player_name FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id, t1.player_name ORDER BY CAST(SUM(t2.heading_accuracy) AS DOUBLE PRECISION) / COUNT(t2.\"player_fifa_api_id\") DESC LIMIT 10",
            "normalized": "SELECT t1.player_name\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180\nGROUP BY t1.id,\n         t1.player_name\nORDER BY CAST(SUM(t2.heading_accuracy) AS DOUBLE PRECISION) / COUNT(t2.\"player_fifa_api_id\") DESC\nLIMIT 10"
        },
        "generated_sql_query": {
            "raw": "SELECT p.player_name\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 180\nGROUP BY p.player_name\nORDER BY AVG(pa.heading_accuracy) DESC\nLIMIT 10;",
            "normalized": "SELECT p.player_name\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.height > 180\nGROUP BY p.player_name\nORDER BY AVG(pa.heading_accuracy) DESC\nLIMIT 10;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "reference_sql_query": {
            "raw": "SELECT t3.\"team_long_name\" FROM \"Team\" AS t3 INNER JOIN \"Team_Attributes\" AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.\"buildUpPlayDribblingClass\" = 'Normal' AND t4.\"chanceCreationPassing\" < ( SELECT CAST(SUM(t2.\"chanceCreationPassing\") AS DOUBLE PRECISION) / COUNT(t1.id) FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.\"buildUpPlayDribblingClass\" = 'Normal' AND SUBSTR(t2.\"date\", 1, 4) = '2014') ORDER BY t4.\"chanceCreationPassing\" DESC",
            "normalized": "SELECT t3.\"team_long_name\"\nFROM \"Team\" AS t3\nINNER JOIN \"Team_Attributes\" AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE t4.\"buildUpPlayDribblingClass\" = 'Normal'\n  AND t4.\"chanceCreationPassing\" <\n    (SELECT CAST(SUM(t2.\"chanceCreationPassing\") AS DOUBLE PRECISION) / COUNT(t1.id)\n     FROM \"Team\" AS t1\n     INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id\n     WHERE t2.\"buildUpPlayDribblingClass\" = 'Normal'\n       AND SUBSTR(t2.\"date\", 1, 4) = '2014')\nORDER BY t4.\"chanceCreationPassing\" DESC"
        },
        "generated_sql_query": {
            "raw": "SELECT T.team_long_name, TA.chanceCreationPassing\nFROM public.\"Team_Attributes\" TA\nJOIN public.\"Team\" T ON TA.team_api_id = T.team_api_id\nWHERE TA.\"buildUpPlayDribblingClass\" = 'Normal'\n  AND TA.\"date\" LIKE '2014%'\n  AND TA.\"chanceCreationPassing\" < (\n    SELECT AVG(\"chanceCreationPassing\")\n    FROM public.\"Team_Attributes\"\n    WHERE \"date\" LIKE '2014%'\n  )\nORDER BY TA.\"chanceCreationPassing\" DESC;",
            "normalized": "SELECT T.team_long_name,\n       TA.chanceCreationPassing\nFROM public.\"Team_Attributes\" TA\nJOIN public.\"Team\" T ON TA.team_api_id = T.team_api_id\nWHERE TA.\"buildUpPlayDribblingClass\" = 'Normal'\n  AND TA.\"date\" LIKE '2014%'\n  AND TA.\"chanceCreationPassing\" <\n    (SELECT AVG(\"chanceCreationPassing\")\n     FROM public.\"Team_Attributes\"\n     WHERE \"date\" LIKE '2014%')\nORDER BY TA.\"chanceCreationPassing\" DESC;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "reference_sql_query": {
            "raw": "SELECT t1.name FROM \"League\" AS t1 INNER JOIN \"Match\" AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS DOUBLE PRECISION) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS DOUBLE PRECISION) / COUNT(DISTINCT t2.id)) > 0",
            "normalized": "SELECT t1.name\nFROM \"League\" AS t1\nINNER JOIN \"Match\" AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2009/2010'\nGROUP BY t1.name\nHAVING (CAST(SUM(t2.home_team_goal) AS DOUBLE PRECISION) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS DOUBLE PRECISION) / COUNT(DISTINCT t2.id)) > 0"
        },
        "generated_sql_query": {
            "raw": "SELECT l.name\nFROM public.\"League\" l\nJOIN public.\"Match\" m ON l.id = m.league_id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);",
            "normalized": "SELECT l.name\nFROM public.\"League\" l\nJOIN public.\"Match\" m ON l.id = m.league_id\nWHERE m.season = '2009/2010'\nGROUP BY l.name\nHAVING AVG(m.home_team_goal) > AVG(m.away_team_goal);"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the short name of the football team Queens Park Rangers?",
        "reference_sql_query": {
            "raw": "SELECT team_short_name FROM \"Team\" WHERE \"team_long_name\" = 'Queens Park Rangers'",
            "normalized": "SELECT team_short_name\nFROM \"Team\"\nWHERE \"team_long_name\" = 'Queens Park Rangers'"
        },
        "generated_sql_query": {
            "raw": "SELECT team_short_name \nFROM public.\"Team\" \nWHERE team_long_name = 'Queens Park Rangers';",
            "normalized": "SELECT team_short_name\nFROM public.\"Team\"\nWHERE team_long_name = 'Queens Park Rangers';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "reference_sql_query": {
            "raw": "SELECT player_name FROM \"Player\" WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
            "normalized": "SELECT player_name\nFROM \"Player\"\nWHERE SUBSTR(birthday, 1, 7) = '1970-10'"
        },
        "generated_sql_query": {
            "raw": "SELECT player_name\nFROM public.\"Player\"\nWHERE birthday LIKE '1970-10-%';",
            "normalized": "SELECT player_name\nFROM public.\"Player\"\nWHERE birthday LIKE '1970-10-%';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the attacking work rate of the football playerr Franco Zennaro?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t2.attacking_work_rate FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Franco Zennaro'",
            "normalized": "SELECT DISTINCT t2.attacking_work_rate\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Franco Zennaro'"
        },
        "generated_sql_query": {
            "raw": "SELECT pa.attacking_work_rate\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Franco Zennaro';",
            "normalized": "SELECT pa.attacking_work_rate\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Franco Zennaro';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the ADO Den Haag team freedom of movement in the 1st two thirds of the pitch?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t2.\"buildUpPlayPositioningClass\" FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id WHERE t1.\"team_long_name\" = 'ADO Den Haag'",
            "normalized": "SELECT DISTINCT t2.\"buildUpPlayPositioningClass\"\nFROM \"Team\" AS t1\nINNER JOIN \"Team_Attributes\" AS t2 ON t1.team_fifa_api_id = t2.team_fifa_api_id\nWHERE t1.\"team_long_name\" = 'ADO Den Haag'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about \"freedom of movement\" specifically related to a team or any metric that can be directly mapped to it. Therefore, it is not possible to generate a SQL query to answer the question based on the given context.",
            "normalized": "The provided context does NOT contain information about \"freedom of movement\" specifically related TO a team\nOR ANY metric that can be directly mapped TO it. Therefore,\n                                             it IS NOT possible TO generate a SQL query TO answer the question based ON the given context."
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the football player Francois Affolter header's finishing rate on 18/09/2014?",
        "reference_sql_query": {
            "raw": "SELECT t2.heading_accuracy FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Francois Affolter' AND SUBSTR(t2.\"date\", 1, 10) = '2014-09-18'",
            "normalized": "SELECT t2.heading_accuracy\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Francois Affolter'\n  AND SUBSTR(t2.\"date\", 1, 10) = '2014-09-18'"
        },
        "generated_sql_query": {
            "raw": "SELECT pa.finishing \nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francois Affolter' AND pa.date = '2014-09-18';",
            "normalized": "SELECT pa.finishing\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Francois Affolter'\n  AND pa.date = '2014-09-18';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the overall rating of the football player Gabriel Tamas in year 2011?",
        "reference_sql_query": {
            "raw": "SELECT t2.overall_rating FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Gabriel Tamas' AND EXTRACT(YEAR FROM t2.date::DATE) = '2011'",
            "normalized": "SELECT t2.overall_rating\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Gabriel Tamas'\n  AND EXTRACT(YEAR\n              FROM t2.date::DATE) = '2011'"
        },
        "generated_sql_query": {
            "raw": "SELECT pa.overall_rating\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas' AND pa.date LIKE '2011%';",
            "normalized": "SELECT pa.overall_rating\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Gabriel Tamas'\n  AND pa.date LIKE '2011%';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the preferred foot when attacking of the youngest football player?",
        "reference_sql_query": {
            "raw": "SELECT t2.preferred_foot FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday DESC LIMIT 1",
            "normalized": "SELECT t2.preferred_foot\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t1.birthday DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT pa.preferred_foot \nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nORDER BY p.birthday DESC\nLIMIT 1;",
            "normalized": "SELECT pa.preferred_foot\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nORDER BY p.birthday DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List all the football player with the highest potential score.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT(t1.player_name) FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM \"Player_Attributes\")",
            "normalized": "SELECT DISTINCT(t1.player_name)\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.potential =\n    (SELECT MAX(potential)\n     FROM \"Player_Attributes\")"
        },
        "generated_sql_query": {
            "raw": "SELECT player_name\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM public.\"Player_Attributes\");",
            "normalized": "SELECT player_name\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential =\n    (SELECT MAX(potential)\n     FROM public.\"Player_Attributes\");"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT t1.id) FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
            "normalized": "SELECT COUNT(DISTINCT t1.id)\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.weight < 130\n  AND t2.preferred_foot = 'left'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT pa.player_api_id) AS left_footed_players_under_130\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE p.weight < 130 AND pa.preferred_foot = 'left';",
            "normalized": "SELECT COUNT(DISTINCT pa.player_api_id) AS left_footed_players_under_130\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE p.weight < 130\n  AND pa.preferred_foot = 'left';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t1.team_short_name FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.\"chanceCreationPassingClass\" = 'Risky'",
            "normalized": "SELECT DISTINCT t1.team_short_name\nFROM \"Team\" AS t1\nINNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.\"chanceCreationPassingClass\" = 'Risky'"
        },
        "generated_sql_query": {
            "raw": "SELECT T.team_short_name\nFROM public.\"Team\" T\nJOIN public.\"Team_Attributes\" TA ON T.team_api_id = TA.team_api_id\nWHERE TA.\"chanceCreationPassingClass\" = 'Risky';",
            "normalized": "SELECT T.team_short_name\nFROM public.\"Team\" T\nJOIN public.\"Team_Attributes\" TA ON T.team_api_id = TA.team_api_id\nWHERE TA.\"chanceCreationPassingClass\" = 'Risky';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the defensive work rate of the football player David Wilson\n?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t2.defensive_work_rate FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'David Wilson'",
            "normalized": "SELECT DISTINCT t2.defensive_work_rate\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'David Wilson'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the player \"David Wilson\" in the given tables. To retrieve the defensive work rate, we need to know the `player_api_id` or `player_fifa_api_id` of David Wilson, which would allow us to join the `Player` and `Player_Attributes` tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the player \"David Wilson\" IN the given tables. TO retrieve the defensive\nWORK rate,\n     we need TO know the `player_api_id`\nOR `player_fifa_api_id` OF David Wilson,\n                           which would allow us TO\nJOIN the `Player`\nAND `Player_Attributes` tables."
        },
        "db_id": "european_football_2"
    },
    {
        "question": "When is the birthday of the football player who has the highest overall rating?",
        "reference_sql_query": {
            "raw": "SELECT t1.birthday FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
            "normalized": "SELECT t1.birthday\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.overall_rating DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT p.birthday\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;",
            "normalized": "SELECT p.birthday\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the name of the football league in the country of Netherlands?",
        "reference_sql_query": {
            "raw": "SELECT t2.name FROM \"Country\" AS t1 INNER JOIN \"League\" AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
            "normalized": "SELECT t2.name\nFROM \"Country\" AS t1\nINNER JOIN \"League\" AS t2 ON t1.id = t2.country_id\nWHERE t1.name = 'Netherlands'"
        },
        "generated_sql_query": {
            "raw": "SELECT l.name \nFROM public.\"League\" l\nJOIN public.\"Country\" c ON l.country_id = c.id\nWHERE c.name = 'Netherlands';",
            "normalized": "SELECT l.name\nFROM public.\"League\" l\nJOIN public.\"Country\" c ON l.country_id = c.id\nWHERE c.name = 'Netherlands';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Calculate the average home team goal in the 2010/2011 season in the country of Poland.",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(t2.home_team_goal) AS DOUBLE PRECISION) / COUNT(t2.id) FROM \"Country\" AS t1 INNER JOIN \"Match\" AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'",
            "normalized": "SELECT CAST(SUM(t2.home_team_goal) AS DOUBLE PRECISION) / COUNT(t2.id)\nFROM \"Country\" AS t1\nINNER JOIN \"Match\" AS t2 ON t1.id = t2.country_id\nWHERE t1.name = 'Poland'\n  AND t2.season = '2010/2011'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(home_team_goal) AS average_home_team_goal\nFROM public.\"Match\" m\nJOIN public.\"League\" l ON m.league_id = l.id\nWHERE m.season = '2010/2011'\nAND l.name = 'Poland';",
            "normalized": "SELECT AVG(home_team_goal) AS average_home_team_goal\nFROM public.\"Match\" m\nJOIN public.\"League\" l ON m.league_id = l.id\nWHERE m.season = '2010/2011'\n  AND l.name = 'Poland';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Who has the highest average finishing rate between the highest and shortest football player?",
        "reference_sql_query": {
            "raw": "SELECT A FROM ( SELECT AVG(finishing) result, 'Max' A FROM \"Player\" AS T1 INNER JOIN \"Player_Attributes\" AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MAX(height) FROM \"Player\" ) UNION SELECT AVG(finishing) result, 'Min' A FROM \"Player\" AS T1 INNER JOIN \"Player_Attributes\" AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height = ( SELECT MIN(height) FROM \"Player\" ) ) ORDER BY result DESC LIMIT 1",
            "normalized": "SELECT A\nFROM\n  (SELECT AVG(finishing) RESULT,\n                         'Max' A\n   FROM \"Player\" AS T1\n   INNER JOIN \"Player_Attributes\" AS T2 ON T1.player_api_id = T2.player_api_id\n   WHERE T1.height =\n       (SELECT MAX(height)\n        FROM \"Player\")\n   UNION SELECT AVG(finishing) RESULT,\n                               'Min' A\n   FROM \"Player\" AS T1\n   INNER JOIN \"Player_Attributes\" AS T2 ON T1.player_api_id = T2.player_api_id\n   WHERE T1.height =\n       (SELECT MIN(height)\n        FROM \"Player\"))\nORDER BY RESULT DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query to answer this question. The context does not include instructions or data to calculate the height of each player and compare it. Additionally, it lacks details on how to link the player attributes to the player for calculating the average finishing rate based on the height.",
            "normalized": "The provided context IS insufficient TO generate the SQL query TO answer this question. The context does NOT INCLUDE instructions\nOR DATA TO calculate the height OF EACH player\nAND compare it. Additionally,\n    it lacks details ON how TO LINK the player attributes TO the player\nFOR calculating the average finishing rate based ON the height."
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Please list player names which are higher than 180.",
        "reference_sql_query": {
            "raw": "SELECT player_name FROM \"Player\" WHERE height > 180",
            "normalized": "SELECT player_name\nFROM \"Player\"\nWHERE height > 180"
        },
        "generated_sql_query": {
            "raw": "SELECT player_name \nFROM public.\"Player\" \nWHERE height > 180;",
            "normalized": "SELECT player_name\nFROM public.\"Player\"\nWHERE height > 180;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "How many players were born after 1990?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM \"Player\" WHERE EXTRACT(YEAR FROM birthday::DATE) > '1990'",
            "normalized": "SELECT COUNT(id)\nFROM \"Player\"\nWHERE EXTRACT(YEAR\n              FROM birthday::DATE) > '1990'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.\"Player\" \nWHERE birthday > '1990-12-31';",
            "normalized": "SELECT COUNT(*)\nFROM public.\"Player\"\nWHERE birthday > '1990-12-31';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "How many players whose first names are Adam and weigh more than 170?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(id) FROM \"Player\" WHERE weight > 170 AND player_name LIKE 'Adam%'",
            "normalized": "SELECT COUNT(id)\nFROM \"Player\"\nWHERE weight > 170\n  AND player_name LIKE 'Adam%'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.\"Player\"\nWHERE player_name LIKE 'Adam%' AND weight > 170;",
            "normalized": "SELECT COUNT(*)\nFROM public.\"Player\"\nWHERE player_name LIKE 'Adam%'\n  AND weight > 170;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t1.player_name FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.\"date\", 1, 4) BETWEEN '2008' AND '2010'",
            "normalized": "SELECT DISTINCT t1.player_name\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating > 80\n  AND SUBSTR(t2.\"date\", 1, 4) BETWEEN '2008' AND '2010'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT p.player_name\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating > 80\nAND pa.date BETWEEN '2008-01-01' AND '2010-12-31';",
            "normalized": "SELECT DISTINCT p.player_name\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE pa.overall_rating > 80\n  AND pa.date BETWEEN '2008-01-01' AND '2010-12-31';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is Aaron Doran's potential score?",
        "reference_sql_query": {
            "raw": "SELECT t2.potential FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
            "normalized": "SELECT t2.potential\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Aaron Doran'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about specific players like Aaron Doran. Therefore, it is not possible to generate a SQL query to find Aaron Doran's potential score. The context lacks specific data on player names and their corresponding scores.",
            "normalized": "The provided context does NOT contain information about SPECIFIC players like Aaron Doran. Therefore,\n                                                                 it IS NOT possible TO generate a SQL query TO find Aaron Doran's potential score. The context lacks SPECIFIC DATA ON player NAMES\nAND their\nCORRESPONDING scores."
        },
        "db_id": "european_football_2"
    },
    {
        "question": "List out of players whose preferred foot is left.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t1.id, t1.player_name FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
            "normalized": "SELECT DISTINCT t1.id,\n                t1.player_name\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left'"
        },
        "generated_sql_query": {
            "raw": "SELECT player_name \nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left';",
            "normalized": "SELECT player_name\nFROM public.\"Player\" p\nJOIN public.\"Player_Attributes\" pa ON p.player_api_id = pa.player_api_id\nWHERE pa.preferred_foot = 'left';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Please list all team names which the speed class is fast.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t1.\"team_long_name\" FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.\"buildUpPlaySpeedClass\" = 'Fast'",
            "normalized": "SELECT DISTINCT t1.\"team_long_name\"\nFROM \"Team\" AS t1\nINNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.\"buildUpPlaySpeedClass\" = 'Fast'"
        },
        "generated_sql_query": {
            "raw": "SELECT t.team_long_name\nFROM public.\"Team\" t\nJOIN public.\"Team_Attributes\" ta ON t.team_api_id = ta.team_api_id\nWHERE ta.\"buildUpPlaySpeedClass\" = 'fast';",
            "normalized": "SELECT t.team_long_name\nFROM public.\"Team\" t\nJOIN public.\"Team_Attributes\" ta ON t.team_api_id = ta.team_api_id\nWHERE ta.\"buildUpPlaySpeedClass\" = 'fast';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "What is the passing class of CLB team?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t2.\"buildUpPlayPassingClass\" FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
            "normalized": "SELECT DISTINCT t2.\"buildUpPlayPassingClass\"\nFROM \"Team\" AS t1\nINNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t1.team_short_name = 'CLB'"
        },
        "generated_sql_query": {
            "raw": "SELECT t.team_long_name, ta.\"buildUpPlayPassingClass\"\nFROM public.\"Team\" t\nJOIN public.\"Team_Attributes\" ta ON t.team_fifa_api_id = ta.team_fifa_api_id\nWHERE t.team_short_name = 'CLB';",
            "normalized": "SELECT t.team_long_name,\n       ta.\"buildUpPlayPassingClass\"\nFROM public.\"Team\" t\nJOIN public.\"Team_Attributes\" ta ON t.team_fifa_api_id = ta.team_fifa_api_id\nWHERE t.team_short_name = 'CLB';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Which teams have build up play passing more than 70? Please list their short names.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT t1.team_short_name FROM \"Team\" AS t1 INNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.\"buildUpPlayPassing\" > 70",
            "normalized": "SELECT DISTINCT t1.team_short_name\nFROM \"Team\" AS t1\nINNER JOIN \"Team_Attributes\" AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.\"buildUpPlayPassing\" > 70"
        },
        "generated_sql_query": {
            "raw": "SELECT T.team_short_name \nFROM public.\"Team_Attributes\" TA\nJOIN public.\"Team\" T ON TA.team_api_id = T.team_api_id\nWHERE TA.\"buildUpPlayPassing\" > 70;",
            "normalized": "SELECT T.team_short_name\nFROM public.\"Team_Attributes\" TA\nJOIN public.\"Team\" T ON TA.team_api_id = T.team_api_id\nWHERE TA.\"buildUpPlayPassing\" > 70;"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(t2.overall_rating) AS DOUBLE PRECISION) / COUNT(t2.id) FROM \"Player\" AS t1 INNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND EXTRACT(YEAR FROM t2.\"date\"::DATE) >= '2010' AND EXTRACT(YEAR FROM t2.\"date\"::DATE) <= '2015'",
            "normalized": "SELECT CAST(SUM(t2.overall_rating) AS DOUBLE PRECISION) / COUNT(t2.id)\nFROM \"Player\" AS t1\nINNER JOIN \"Player_Attributes\" AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\n  AND EXTRACT(YEAR\n              FROM t2.\"date\"::DATE) >= '2010'\n  AND EXTRACT(YEAR\n              FROM t2.\"date\"::DATE) <= '2015'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(overall_rating) AS average_overall_rating\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE p.height > 170\nAND pa.date BETWEEN '2010-01-01' AND '2015-12-31';",
            "normalized": "SELECT AVG(overall_rating) AS average_overall_rating\nFROM public.\"Player_Attributes\" pa\nJOIN public.\"Player\" p ON pa.player_api_id = p.player_api_id\nWHERE p.height > 170\n  AND pa.date BETWEEN '2010-01-01' AND '2015-12-31';"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Which football player has the shortest height?",
        "reference_sql_query": {
            "raw": "SELECT player_name FROM \"Player\" ORDER BY height ASC LIMIT 1",
            "normalized": "SELECT player_name\nFROM \"Player\"\nORDER BY height ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT player_name, height \nFROM public.\"Player\" \nWHERE height = (SELECT MIN(height) FROM public.\"Player\");",
            "normalized": "SELECT player_name,\n       height\nFROM public.\"Player\"\nWHERE height =\n    (SELECT MIN(height)\n     FROM public.\"Player\");"
        },
        "db_id": "european_football_2"
    },
    {
        "question": "Are there more in-patient or outpatient who were male? What is the deviation in percentage?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Admission\" = '+' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / SUM(CASE WHEN \"Admission\" = '-' THEN 1 ELSE 0 END) FROM \"Patient\" WHERE \"SEX\" = 'M'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Admission\" = '+' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / SUM(CASE\n                                                          WHEN \"Admission\" = '-' THEN 1\n                                                          ELSE 0\n                                                      END)\nFROM \"Patient\"\nWHERE \"SEX\" = 'M'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate a SQL query because it does not provide information on distinguishing between in-patient and outpatient records. The \"Patient\" table does not have a column that specifies whether a patient is in-patient or outpatient, and no other table in the provided schema contains this information.",
            "normalized": "The provided context IS insufficient TO generate a SQL query because it does NOT provide information ON distinguishing BETWEEN IN-patient AND outpatient records. The \"Patient\" TABLE does NOT have a COLUMN that specifies whether a patient IS IN-patient\nOR outpatient,\nAND NO other TABLE IN the provided SCHEMA CONTAINS this information."
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the percentage of female patient were born after 1930?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN EXTRACT(YEAR FROM \"Birthday\") > '1930' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(*) FROM \"Patient\" WHERE \"SEX\" = 'F'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN EXTRACT(YEAR\n                                 FROM \"Birthday\") > '1930' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(*)\nFROM \"Patient\"\nWHERE \"SEX\" = 'F'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(*) FILTER (WHERE \"SEX\" = 'female' AND \"Birthday\" > '1930-12-31')::FLOAT / COUNT(*)) * 100 AS percentage_female_born_after_1930\nFROM \n    public.\"Patient\";",
            "normalized": "SELECT (COUNT(*) FILTER (\n                         WHERE \"SEX\" = 'female'\n                           AND \"Birthday\" > '1930-12-31')::FLOAT / COUNT(*)) * 100 AS percentage_female_born_after_1930\nFROM public.\"Patient\";"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For patient born between Year 1930 to 1940, how many percent of them were inpatient?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Admission\" = '+' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(*) FROM \"Patient\" WHERE EXTRACT(YEAR FROM \"Birthday\") BETWEEN '1930' AND '1940'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Admission\" = '+' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(*)\nFROM \"Patient\"\nWHERE EXTRACT(YEAR\n              FROM \"Birthday\") BETWEEN '1930' AND '1940'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(CASE WHEN \"Admission\" = 'inpatient' THEN 1 END)::FLOAT / COUNT(*)) * 100 AS percent_inpatient\nFROM \n    public.\"Patient\"\nWHERE \n    EXTRACT(YEAR FROM \"Birthday\") BETWEEN 1930 AND 1940;",
            "normalized": "SELECT (COUNT(CASE\n                  WHEN \"Admission\" = 'inpatient' THEN 1\n              END)::FLOAT / COUNT(*)) * 100 AS percent_inpatient\nFROM public.\"Patient\"\nWHERE EXTRACT(YEAR\n              FROM \"Birthday\") BETWEEN 1930 AND 1940;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN \"Admission\" = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN \"Admission\" = '-' THEN 1 ELSE 0 END) FROM \"Patient\" WHERE \"Diagnosis\" = 'SLE'",
            "normalized": "SELECT SUM(CASE\n               WHEN \"Admission\" = '+' THEN 1.0\n               ELSE 0\n           END) / SUM(CASE\n                          WHEN \"Admission\" = '-' THEN 1\n                          ELSE 0\n                      END)\nFROM \"Patient\"\nWHERE \"Diagnosis\" = 'SLE'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    SUM(CASE WHEN \"Admission\" = 'outpatient' THEN 1 ELSE 0 END) * 1.0 /\n    NULLIF(SUM(CASE WHEN \"Admission\" = 'inpatient' THEN 1 ELSE 0 END), 0) AS outpatient_to_inpatient_ratio\nFROM \n    public.\"Patient\" \nWHERE \n    \"Diagnosis\" = 'SLE';",
            "normalized": "SELECT SUM(CASE\n               WHEN \"Admission\" = 'outpatient' THEN 1\n               ELSE 0\n           END) * 1.0 / NULLIF(SUM(CASE\n                                       WHEN \"Admission\" = 'inpatient' THEN 1\n                                       ELSE 0\n                                   END), 0) AS outpatient_to_inpatient_ratio\nFROM public.\"Patient\"\nWHERE \"Diagnosis\" = 'SLE';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Diagnosis\", T2.\"Date\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"ID\" = 30609",
            "normalized": "SELECT T1.\"Diagnosis\",\n       T2.\"Date\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"ID\" = 30609"
        },
        "generated_sql_query": {
            "raw": "SELECT p.Diagnosis, l.Date\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE p.\"ID\" = 30609;",
            "normalized": "SELECT p.Diagnosis,\n       l.Date\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE p.\"ID\" = 30609;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "State the sex and birthday of patient ID '163109'. When was the examination taken and what symptom does the patient had.",
        "reference_sql_query": {
            "raw": "SELECT T1.\"SEX\", T1.\"Birthday\", T2.\"Examination Date\", T2.\"Symptoms\" FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"ID\" = 163109",
            "normalized": "SELECT T1.\"SEX\",\n       T1.\"Birthday\",\n       T2.\"Examination Date\",\n       T2.\"Symptoms\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"ID\" = 163109"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    p.SEX, \n    p.Birthday, \n    e.\"Examination Date\", \n    e.Symptoms\nFROM \n    public.\"Patient\" p\nJOIN \n    public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nWHERE \n    p.\"ID\" = 163109;",
            "normalized": "SELECT p.SEX,\n       p.Birthday,\n       e.\"Examination Date\",\n       e.Symptoms\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nWHERE p.\"ID\" = 163109;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ID\", T1.\"SEX\", T1.\"Birthday\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"LDH\" > 500",
            "normalized": "SELECT DISTINCT T1.\"ID\",\n                T1.\"SEX\",\n                T1.\"Birthday\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"LDH\" > 500"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"ID\", p.\"SEX\", p.\"Birthday\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"LDH\" > 250 OR l.\"LDH\" < 140;",
            "normalized": "SELECT p.\"ID\",\n       p.\"SEX\",\n       p.\"Birthday\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"LDH\" > 250\n  OR l.\"LDH\" < 140;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "State the ID and age of patient with positive degree of coagulation.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ID\", EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM T1.\"Birthday\") FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"RVVT\" = '+'",
            "normalized": "SELECT DISTINCT T1.\"ID\",\n                EXTRACT(YEAR\n                        FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR\n                                                          FROM T1.\"Birthday\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"RVVT\" = '+'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about how the \"degree of coagulation\" is represented in the tables. There are columns related to examinations and laboratory tests, but it's unclear which one indicates a positive degree of coagulation.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about how the \"degree of coagulation\" IS represented IN the tables. There ARE columns related TO examinations\nAND laboratory tests,\n    but it's unclear which one indicates a positive degree OF coagulation."
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ID\", T1.\"SEX\", T1.\"Diagnosis\" FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"Thrombosis\" = 2",
            "normalized": "SELECT DISTINCT T1.\"ID\",\n                T1.\"SEX\",\n                T1.\"Diagnosis\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"Thrombosis\" = 2"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"ID\", p.\"SEX\", p.\"Diagnosis\"\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nWHERE e.\"Thrombosis\" = 3;",
            "normalized": "SELECT p.\"ID\",\n       p.\"SEX\",\n       p.\"Diagnosis\"\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nWHERE e.\"Thrombosis\" = 3;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ID\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE EXTRACT(YEAR FROM T1.\"Birthday\") = '1937' AND T2.\"T-CHO\">= 250",
            "normalized": "SELECT DISTINCT T1.\"ID\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE EXTRACT(YEAR\n              FROM T1.\"Birthday\") = '1937'\n  AND T2.\"T-CHO\">= 250"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"ID\", p.\"SEX\", p.\"Birthday\", l.\"T-CHO\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE EXTRACT(YEAR FROM p.\"Birthday\") = 1937\nAND (l.\"T-CHO\" < 125 OR l.\"T-CHO\" > 200);",
            "normalized": "SELECT p.\"ID\",\n       p.\"SEX\",\n       p.\"Birthday\",\n       l.\"T-CHO\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE EXTRACT(YEAR\n              FROM p.\"Birthday\") = 1937\n  AND (l.\"T-CHO\" < 125\n       OR l.\"T-CHO\" > 200);"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ID\", T1.\"SEX\", T1.\"Diagnosis\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"ALB\" < 3.5",
            "normalized": "SELECT DISTINCT T1.\"ID\",\n                T1.\"SEX\",\n                T1.\"Diagnosis\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"ALB\" < 3.5"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"ID\", p.\"SEX\", p.\"Diagnosis\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"ALB\" < 3.5;",
            "normalized": "SELECT p.\"ID\",\n       p.\"SEX\",\n       p.\"Diagnosis\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"ALB\" < 3.5;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the percentage of female patient had total protein not within the normal range?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T1.\"SEX\" = 'F' AND (T2.\"TP\" < 6.0 OR T2.\"TP\" > 8.5) THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(*) FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"SEX\" = 'F'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T1.\"SEX\" = 'F'\n                         AND (T2.\"TP\" < 6.0\n                              OR T2.\"TP\" > 8.5) THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(*)\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"SEX\" = 'F'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM public.\"Patient\" p WHERE p.\"SEX\" = 'Female')) AS percentage_of_female_patients_out_of_range\nFROM \n    public.\"Patient\" p\nJOIN \n    public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE \n    p.\"SEX\" = 'Female' AND (l.\"TP\" < 6.4 OR l.\"TP\" > 8.3);",
            "normalized": "SELECT (COUNT(*) * 100.0 /\n          (SELECT COUNT(*)\n           FROM public.\"Patient\" p\n           WHERE p.\"SEX\" = 'Female')) AS percentage_of_female_patients_out_of_range\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE p.\"SEX\" = 'Female'\n  AND (l.\"TP\" < 6.4\n       OR l.\"TP\" > 8.3);"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T2.\"aCL IgG\") FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE EXTRACT(YEAR FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR FROM T1.\"Birthday\") >= 50 AND T1.\"Admission\" = '+'",
            "normalized": "SELECT AVG(T2.\"aCL IgG\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE EXTRACT(YEAR\n              FROM CURRENT_TIMESTAMP) - EXTRACT(YEAR\n                                                FROM T1.\"Birthday\") >= 50\n  AND T1.\"Admission\" = '+'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(e.\"aCL IgG\") AS average_aCL_IgG\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nWHERE p.\"Admission\" = 'In-Patient' \nAND EXTRACT(YEAR FROM AGE(p.\"Birthday\")) >= 50;",
            "normalized": "SELECT AVG(e.\"aCL IgG\") AS average_aCL_IgG\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nWHERE p.\"Admission\" = 'In-Patient'\n  AND EXTRACT(YEAR\n              FROM AGE(p.\"Birthday\")) >= 50;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(*) FROM \"Patient\" WHERE EXTRACT(YEAR FROM \"Description\") = '1997' AND \"SEX\" = 'F' AND \"Admission\" = '-'",
            "normalized": "SELECT COUNT(*)\nFROM \"Patient\"\nWHERE EXTRACT(YEAR\n              FROM \"Description\") = '1997'\n  AND \"SEX\" = 'F'\n  AND \"Admission\" = '-'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.\"Patient\"\nWHERE SEX = 'Female' \nAND \"First Date\" BETWEEN '1997-01-01' AND '1997-12-31'\nAND \"Admission\" = 'Outpatient Clinic Immediately Followed'",
            "normalized": "SELECT COUNT(*)\nFROM public.\"Patient\"\nWHERE SEX = 'Female'\n  AND \"First Date\" BETWEEN '1997-01-01' AND '1997-12-31'\n  AND \"Admission\" = 'Outpatient Clinic Immediately Followed'"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "reference_sql_query": {
            "raw": "SELECT MIN(EXTRACT(YEAR FROM\"First Date\") - EXTRACT(YEAR FROM \"Birthday\")) FROM \"Patient\"",
            "normalized": "SELECT MIN(EXTRACT(YEAR\n                   FROM\"First Date\") - EXTRACT(YEAR\n                                               FROM \"Birthday\"))\nFROM \"Patient\""
        },
        "generated_sql_query": {
            "raw": "SELECT MIN(EXTRACT(YEAR FROM AGE(\"First Date\", \"Birthday\"))) AS youngest_age\nFROM public.\"Patient\";",
            "normalized": "SELECT MIN(EXTRACT(YEAR\n                   FROM AGE(\"First Date\", \"Birthday\"))) AS youngest_age\nFROM public.\"Patient\";"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many of the patients with the most serious thrombosis cases examined in 1997 are women?",
        "reference_sql_query": {
            "raw": "SELECT  COUNT(*) FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"SEX\" = 'F' AND EXTRACT(YEAR FROM T2.\"Examination Date\") = '1997' AND T2.\"Thrombosis\" = 1",
            "normalized": "SELECT COUNT(*)\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"SEX\" = 'F'\n  AND EXTRACT(YEAR\n              FROM T2.\"Examination Date\") = '1997'\n  AND T2.\"Thrombosis\" = 1"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT p.\"ID\") AS female_patients_with_serious_thrombosis\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nWHERE e.\"Thrombosis\" = (SELECT MAX(\"Thrombosis\") FROM public.\"Examination\" WHERE EXTRACT(YEAR FROM \"Examination Date\") = 1997)\nAND EXTRACT(YEAR FROM e.\"Examination Date\") = 1997\nAND p.\"SEX\" = 'Female';",
            "normalized": "SELECT COUNT(DISTINCT p.\"ID\") AS female_patients_with_serious_thrombosis\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nWHERE e.\"Thrombosis\" =\n    (SELECT MAX(\"Thrombosis\")\n     FROM public.\"Examination\"\n     WHERE EXTRACT(YEAR\n                   FROM \"Examination Date\") = 1997)\n  AND EXTRACT(YEAR\n              FROM e.\"Examination Date\") = 1997\n  AND p.\"SEX\" = 'Female';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the age gap between the youngest and oldest patient with a normal triglyceride recorded?",
        "reference_sql_query": {
            "raw": "SELECT EXTRACT(YEAR FROM MAX(T1.\"Birthday\")) - EXTRACT(YEAR FROM MIN(T1.\"Birthday\")) FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"TG\" >= 200",
            "normalized": "SELECT EXTRACT(YEAR\n               FROM MAX(T1.\"Birthday\")) - EXTRACT(YEAR\n                                                  FROM MIN(T1.\"Birthday\"))\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"TG\" >= 200"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(age) - MIN(age) AS age_gap\nFROM (\n    SELECT EXTRACT(YEAR FROM AGE(l.\"Date\", p.\"Birthday\")) AS age\n    FROM public.\"Laboratory\" l\n    JOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\n    WHERE l.\"TG\" BETWEEN 150 AND 199\n) AS patient_ages;",
            "normalized": "SELECT MAX(age) - MIN(age) AS age_gap\nFROM\n  (SELECT EXTRACT(YEAR\n                  FROM AGE(l.\"Date\", p.\"Birthday\")) AS age\n   FROM public.\"Laboratory\" l\n   JOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\n   WHERE l.\"TG\" BETWEEN 150 AND 199) AS patient_ages;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Symptoms\", T1.\"Diagnosis\" FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"Symptoms\" IS NOT NULL ORDER BY T1.\"Birthday\" DESC LIMIT 1",
            "normalized": "SELECT T2.\"Symptoms\",\n       T1.\"Diagnosis\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"Symptoms\" IS NOT NULL\nORDER BY T1.\"Birthday\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT e.\"Symptoms\", e.\"Diagnosis\"\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nORDER BY p.\"Birthday\" DESC\nLIMIT 1;",
            "normalized": "SELECT e.\"Symptoms\",\n       e.\"Diagnosis\"\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nORDER BY p.\"Birthday\" DESC\nLIMIT 1;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For the year that concluded on December 31, 1998, how many male patients on average were tested in the lab each month?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(T1.\"ID\") AS DOUBLE PRECISION) / 12 FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE EXTRACT(YEAR FROM T2.\"Date\") = '1998' AND T1.\"SEX\" = 'M'",
            "normalized": "SELECT CAST(COUNT(T1.\"ID\") AS DOUBLE PRECISION) / 12\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE EXTRACT(YEAR\n              FROM T2.\"Date\") = '1998'\n  AND T1.\"SEX\" = 'M'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(monthly_count) AS average_male_patients_per_month\nFROM (\n    SELECT EXTRACT(MONTH FROM l.\"Date\") AS month, COUNT(DISTINCT l.\"ID\") AS monthly_count\n    FROM public.\"Laboratory\" l\n    JOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\n    WHERE p.\"SEX\" = 'Male' AND l.\"Date\" BETWEEN '1998-01-01' AND '1998-12-31'\n    GROUP BY EXTRACT(MONTH FROM l.\"Date\")\n) AS monthly_counts;",
            "normalized": "SELECT AVG(monthly_count) AS average_male_patients_per_month\nFROM\n  (SELECT EXTRACT(MONTH\n                  FROM l.\"Date\") AS MONTH,\n          COUNT(DISTINCT l.\"ID\") AS monthly_count\n   FROM public.\"Laboratory\" l\n   JOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\n   WHERE p.\"SEX\" = 'Male'\n     AND l.\"Date\" BETWEEN '1998-01-01' AND '1998-12-31'\n   GROUP BY EXTRACT(MONTH\n                    FROM l.\"Date\")) AS monthly_counts;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Date\", EXTRACT(YEAR FROM T2.\"First Date\") - EXTRACT(YEAR FROM T2.\"Birthday\"),T2.\"Birthday\" FROM \"Laboratory\" AS T1 INNER JOIN \"Patient\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"Diagnosis\" = 'SJS' AND T2.\"Birthday\" IS NOT NULL ORDER BY T2.\"Birthday\" ASC LIMIT 1",
            "normalized": "SELECT T1.\"Date\",\n       EXTRACT(YEAR\n               FROM T2.\"First Date\") - EXTRACT(YEAR\n                                               FROM T2.\"Birthday\"),\n       T2.\"Birthday\"\nFROM \"Laboratory\" AS T1\nINNER JOIN \"Patient\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"Diagnosis\" = 'SJS'\n  AND T2.\"Birthday\" IS NOT NULL\nORDER BY T2.\"Birthday\" ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    p.\"ID\",\n    l.\"Date\" AS \"Laboratory Work Date\",\n    EXTRACT(YEAR FROM AGE(p.\"First Date\", p.\"Birthday\")) AS \"Age at First Date\"\nFROM \n    public.\"Patient\" p\nJOIN \n    public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE \n    p.\"Diagnosis\" = 'SJS'\nORDER BY \n    p.\"Birthday\" ASC, l.\"Date\" DESC\nLIMIT 1;",
            "normalized": "SELECT p.\"ID\",\n       l.\"Date\" AS \"Laboratory Work Date\",\n       EXTRACT(YEAR\n               FROM AGE(p.\"First Date\", p.\"Birthday\")) AS \"Age at First Date\"\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE p.\"Diagnosis\" = 'SJS'\nORDER BY p.\"Birthday\" ASC,\n         l.\"Date\" DESC\nLIMIT 1;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T2.\"UA\" <= 8.0 AND T1.\"SEX\" = 'M' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) / SUM(CASE WHEN T2.\"UA\" <= 6.5 AND T1.\"SEX\" = 'F' THEN 1 ELSE 0 END) FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T2.\"UA\" <= 8.0\n                         AND T1.\"SEX\" = 'M' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) / SUM(CASE\n                                                    WHEN T2.\"UA\" <= 6.5\n                                                         AND T1.\"SEX\" = 'F' THEN 1\n                                                    ELSE 0\n                                                END)\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\""
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SELECT COUNT(*) FROM public.\"Patient\" p\n     JOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\n     WHERE p.\"SEX\" = 'Male' AND (l.\"UA\" < 3.5 OR l.\"UA\" > 7.2))::FLOAT /\n    NULLIF((SELECT COUNT(*) FROM public.\"Patient\" p\n     JOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\n     WHERE p.\"SEX\" = 'Female' AND (l.\"UA\" < 2.6 OR l.\"UA\" > 6.0)), 0) AS male_to_female_ratio",
            "normalized": "SELECT\n  (SELECT COUNT(*)\n   FROM public.\"Patient\" p\n   JOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\n   WHERE p.\"SEX\" = 'Male'\n     AND (l.\"UA\" < 3.5\n          OR l.\"UA\" > 7.2))::FLOAT / NULLIF(\n                                              (SELECT COUNT(*)\n                                               FROM public.\"Patient\" p\n                                               JOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\n                                               WHERE p.\"SEX\" = 'Female'\n                                                 AND (l.\"UA\" < 2.6\n                                                      OR l.\"UA\" > 6.0)), 0) AS male_to_female_ratio"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T1.\"ID\") FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"Admission\" = '+' AND EXTRACT(YEAR FROM T2.\"Examination Date\") - EXTRACT(YEAR FROM T1.\"First Date\") >= 1",
            "normalized": "SELECT COUNT(DISTINCT T1.\"ID\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"Admission\" = '+'\n  AND EXTRACT(YEAR\n              FROM T2.\"Examination Date\") - EXTRACT(YEAR\n                                                    FROM T1.\"First Date\") >= 1"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT p.\"ID\") AS num_patients\nFROM public.\"Patient\" p\nLEFT JOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\" AND e.\"Examination Date\" <= p.\"First Date\" + INTERVAL '1 year'\nWHERE e.\"ID\" IS NULL;",
            "normalized": "SELECT COUNT(DISTINCT p.\"ID\") AS num_patients\nFROM public.\"Patient\" p\nLEFT JOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nAND e.\"Examination Date\" <= p.\"First Date\" + INTERVAL '1 year'\nWHERE e.\"ID\" IS NULL;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"ID\") FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE EXTRACT(YEAR FROM T2.\"Examination Date\") BETWEEN '1990' AND '1993' AND EXTRACT(YEAR FROM T2.\"Examination Date\") - EXTRACT(YEAR FROM T1.\"Birthday\") < 18",
            "normalized": "SELECT COUNT(T1.\"ID\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE EXTRACT(YEAR\n              FROM T2.\"Examination Date\") BETWEEN '1990' AND '1993'\n  AND EXTRACT(YEAR\n              FROM T2.\"Examination Date\") - EXTRACT(YEAR\n                                                    FROM T1.\"Birthday\") < 18"
        },
        "generated_sql_query": {
            "raw": "The provided context does not include the necessary information to determine the age of the patients at the time of their examination. Specifically, we need the birth date of the patients and the examination date to calculate if they were underage (typically under 18). Therefore, it is not possible to generate the SQL query without additional context on how to define \"underage\" based on the given tables.",
            "normalized": "The provided context does NOT INCLUDE the necessary information TO determine the age OF the patients AT the TIME OF their examination. Specifically,\n                                                                                                                    we need the birth date OF the patients\nAND the examination date TO calculate IF they were underage (typically UNDER 18). Therefore,\n                                                                                  it IS NOT possible TO generate the SQL query WITHOUT additional context ON how TO DEFINE \"underage\" based ON the given tables."
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many male patients have elevated total bilirubin count?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(DISTINCT T1.\"ID\") FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"T-BIL\">= 2.0 AND T1.\"SEX\" = 'M'",
            "normalized": "SELECT COUNT(DISTINCT T1.\"ID\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"T-BIL\">= 2.0\n  AND T1.\"SEX\" = 'M'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT p.\"ID\") AS male_patients_with_elevated_bilirubin\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE p.\"SEX\" = 'Male' AND l.\"T-BIL\" > 1.2;",
            "normalized": "SELECT COUNT(DISTINCT p.\"ID\") AS male_patients_with_elevated_bilirubin\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE p.\"SEX\" = 'Male'\n  AND l.\"T-BIL\" > 1.2;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Diagnosis\" FROM \"Examination\" AS T1 INNER JOIN \"Patient\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"Examination Date\"BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.\"Diagnosis\" ORDER BY COUNT(T2.\"Diagnosis\") DESC LIMIT 1",
            "normalized": "SELECT T2.\"Diagnosis\"\nFROM \"Examination\" AS T1\nINNER JOIN \"Patient\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"Examination Date\"BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.\"Diagnosis\"\nORDER BY COUNT(T2.\"Diagnosis\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"Diagnosis\", COUNT(*) AS diagnosis_count\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY p.\"Diagnosis\"\nORDER BY diagnosis_count DESC\nLIMIT 1;",
            "normalized": "SELECT p.\"Diagnosis\",\n       COUNT(*) AS diagnosis_count\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY p.\"Diagnosis\"\nORDER BY diagnosis_count DESC\nLIMIT 1;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
        "reference_sql_query": {
            "raw": "SELECT AVG('1999'  - EXTRACT(YEAR FROM T2.\"Birthday\")) FROM \"Laboratory\" AS T1 INNER JOIN \"Patient\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"Date\" BETWEEN '1991-10-01' AND '1991-10-30'",
            "normalized": "SELECT AVG('1999' - EXTRACT(YEAR\n                            FROM T2.\"Birthday\"))\nFROM \"Laboratory\" AS T1\nINNER JOIN \"Patient\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"Date\" BETWEEN '1991-10-01' AND '1991-10-30'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(EXTRACT(YEAR FROM AGE('1999-01-01', p.\"Birthday\"))) AS average_age\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"Date\" BETWEEN '1991-10-01' AND '1991-10-31';",
            "normalized": "SELECT AVG(EXTRACT(YEAR\n                   FROM AGE('1999-01-01', p.\"Birthday\"))) AS average_age\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nWHERE l.\"Date\" BETWEEN '1991-10-01' AND '1991-10-31';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
        "reference_sql_query": {
            "raw": "SELECT EXTRACT(YEAR FROM T2.\"Date\") - EXTRACT(YEAR FROM T1.\"Birthday\"), T1.\"Diagnosis\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" ORDER BY T2.\"HGB\" DESC LIMIT 1",
            "normalized": "SELECT EXTRACT(YEAR\n               FROM T2.\"Date\") - EXTRACT(YEAR\n                                         FROM T1.\"Birthday\"),\n       T1.\"Diagnosis\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nORDER BY T2.\"HGB\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    EXTRACT(YEAR FROM AGE(e.\"Examination Date\", p.\"Birthday\")) AS age_at_examination,\n    l.\"HGB\" AS hemoglobin_count,\n    e.\"Diagnosis\"\nFROM \n    public.\"Patient\" p\nJOIN \n    public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nJOIN \n    public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\" AND e.\"Examination Date\" = l.\"Date\"\nORDER BY \n    l.\"HGB\" DESC\nLIMIT 1;",
            "normalized": "SELECT EXTRACT(YEAR\n               FROM AGE(e.\"Examination Date\", p.\"Birthday\")) AS age_at_examination,\n       l.\"HGB\" AS hemoglobin_count,\n       e.\"Diagnosis\"\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nJOIN public.\"Laboratory\" l ON p.\"ID\" = l.\"ID\"\nAND e.\"Examination Date\" = l.\"Date\"\nORDER BY l.\"HGB\" DESC\nLIMIT 1;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
        "reference_sql_query": {
            "raw": "SELECT \"ANA\" FROM \"Examination\" WHERE \"ID\" = '3605340' AND\"Examination Date\"= '1996-12-02'",
            "normalized": "SELECT \"ANA\"\nFROM \"Examination\"\nWHERE \"ID\" = '3605340'\n  AND\"Examination Date\"= '1996-12-02'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"ANA\" \nFROM public.\"Examination\" \nWHERE \"ID\" = 3605340 AND \"Examination Date\" = '1996-12-02';",
            "normalized": "SELECT \"ANA\"\nFROM public.\"Examination\"\nWHERE \"ID\" = 3605340\n  AND \"Examination Date\" = '1996-12-02';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "Was the total cholesterol status for the patient id 2927464 on 1995-9-4 at the normal level?",
        "reference_sql_query": {
            "raw": "SELECT CASE WHEN\"T-CHO\"< 250 THEN 'Normal' ELSE 'Abnormal' END FROM \"Laboratory\" WHERE \"ID\" = '2927464' AND \"Date\" = '1995-09-04'",
            "normalized": "SELECT CASE\n           WHEN\"T-CHO\"< 250 THEN 'Normal'\n           ELSE 'Abnormal'\n       END\nFROM \"Laboratory\"\nWHERE \"ID\" = '2927464'\n  AND \"Date\" = '1995-09-04'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"T-CHO\"\nFROM public.\"Laboratory\"\nWHERE \"ID\" = 2927464 AND \"Date\" = '1995-09-04';",
            "normalized": "SELECT \"T-CHO\"\nFROM public.\"Laboratory\"\nWHERE \"ID\" = 2927464\n  AND \"Date\" = '1995-09-04';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What was the gender of the first AORTITIS diagnosed patient?",
        "reference_sql_query": {
            "raw": "SELECT \"SEX\" FROM \"Patient\" WHERE \"Diagnosis\" = 'AORTITIS' AND\"First Date\"IS NOT NULL ORDER BY\"First Date\"ASC LIMIT 1",
            "normalized": "SELECT \"SEX\"\nFROM \"Patient\"\nWHERE \"Diagnosis\" = 'AORTITIS'\n  AND\"First Date\"IS NOT NULL\nORDER BY\"First Date\"ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT p.\"SEX\"\nFROM public.\"Patient\" p\nWHERE p.\"Diagnosis\" = 'AORTITIS'\nORDER BY p.\"First Date\" ASC\nLIMIT 1;",
            "normalized": "SELECT p.\"SEX\"\nFROM public.\"Patient\" p\nWHERE p.\"Diagnosis\" = 'AORTITIS'\nORDER BY p.\"First Date\" ASC\nLIMIT 1;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "reference_sql_query": {
            "raw": "SELECT\"aCL IgA\",\"aCL IgG\",\"aCL IgM\"FROM \"Examination\" WHERE \"ID\" IN ( SELECT \"ID\"  FROM \"Patient\" WHERE \"Diagnosis\" = 'SLE' AND \"Description\" = '1994-02-19' ) AND\"Examination Date\"= '1993-11-12'",
            "normalized": "SELECT\"aCL IgA\",\n      \"aCL IgG\",\n      \"aCL IgM\"\nFROM \"Examination\"\nWHERE \"ID\" IN\n    (SELECT \"ID\"\n     FROM \"Patient\"\n     WHERE \"Diagnosis\" = 'SLE'\n       AND \"Description\" = '1994-02-19')\n  AND\"Examination Date\"= '1993-11-12'"
        },
        "generated_sql_query": {
            "raw": "SELECT e.\"aCL IgG\", e.\"aCL IgM\", e.\"aCL IgA\"\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nWHERE p.\"Diagnosis\" = 'SLE' AND p.\"First Date\" = '1994-02-19' AND e.\"Examination Date\" = '1993-11-12';",
            "normalized": "SELECT e.\"aCL IgG\",\n       e.\"aCL IgM\",\n       e.\"aCL IgA\"\nFROM public.\"Examination\" e\nJOIN public.\"Patient\" p ON e.\"ID\" = p.\"ID\"\nWHERE p.\"Diagnosis\" = 'SLE'\n  AND p.\"First Date\" = '1994-02-19'\n  AND e.\"Examination Date\" = '1993-11-12';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "Was the patient a man or a women whose ALT glutamic pylvic transaminase status got 9 on 1992-6-12?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"SEX\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"GPT\" = 9.0 AND T2.\"Date\" = '1992-06-12'",
            "normalized": "SELECT T1.\"SEX\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"GPT\" = 9.0\n  AND T2.\"Date\" = '1992-06-12'"
        },
        "generated_sql_query": {
            "raw": "SELECT p.SEX\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.ID = l.ID\nWHERE l.\"GPT\" = 9 AND l.\"Date\" = '1992-06-12';",
            "normalized": "SELECT p.SEX\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.ID = l.ID\nWHERE l.\"GPT\" = 9\n  AND l.\"Date\" = '1992-06-12';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For the patient who got the laboratory test of uric acid level as 8.4 on 1991-10-21, how old was he/she at that time?",
        "reference_sql_query": {
            "raw": "SELECT EXTRACT(YEAR FROM T2.\"Date\") - EXTRACT(YEAR FROM T1.\"Birthday\") FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"UA\" = 8.4 AND T2.\"Date\" = '1991-10-21'",
            "normalized": "SELECT EXTRACT(YEAR\n               FROM T2.\"Date\") - EXTRACT(YEAR\n                                         FROM T1.\"Birthday\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"UA\" = 8.4\n  AND T2.\"Date\" = '1991-10-21'"
        },
        "generated_sql_query": {
            "raw": "SELECT EXTRACT(YEAR FROM AGE(l.\"Date\", p.\"Birthday\")) AS age_at_test\nFROM public.\"Laboratory\" l\nJOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\nWHERE l.\"UA\" = 8.4 AND l.\"Date\" = '1991-10-21';",
            "normalized": "SELECT EXTRACT(YEAR\n               FROM AGE(l.\"Date\", p.\"Birthday\")) AS age_at_test\nFROM public.\"Laboratory\" l\nJOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\nWHERE l.\"UA\" = 8.4\n  AND l.\"Date\" = '1991-10-21';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For the patient who was diagnosed SLE on 1997/1/27, what was his/her original diagnose when he/she came to the hospital for the first time?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Diagnosis\" FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"ID\" = ( SELECT \"ID\"  FROM \"Examination\" WHERE\"Examination Date\"= '1997-01-27' AND \"Diagnosis\" = 'SLE' ) AND T2.\"Examination Date\"= T1.\"First Date\"",
            "normalized": "SELECT T1.\"Diagnosis\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"ID\" =\n    (SELECT \"ID\"\n     FROM \"Examination\"\n     WHERE\"Examination Date\"= '1997-01-27'\n       AND \"Diagnosis\" = 'SLE')\n  AND T2.\"Examination Date\"= T1.\"First Date\""
        },
        "generated_sql_query": {
            "raw": "SELECT \"Description\" \nFROM public.\"Patient\" \nWHERE \"ID\" = (\n    SELECT \"ID\" \n    FROM public.\"Examination\" \n    WHERE \"Diagnosis\" = 'SLE' \n    AND \"Examination Date\" = '1997-01-27'\n)",
            "normalized": "SELECT \"Description\"\nFROM public.\"Patient\"\nWHERE \"ID\" =\n    (SELECT \"ID\"\n     FROM public.\"Examination\"\n     WHERE \"Diagnosis\" = 'SLE'\n       AND \"Examination Date\" = '1997-01-27')"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For the patient whose birthday was 1959/3/1, what symptoms did he/she have during the examination on 1993/9/27?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Symptoms\" FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"Birthday\" = '1959-03-01' AND T2.\"Examination Date\"= '1993-09-27'",
            "normalized": "SELECT T2.\"Symptoms\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"Birthday\" = '1959-03-01'\n  AND T2.\"Examination Date\"= '1993-09-27'"
        },
        "generated_sql_query": {
            "raw": "SELECT e.Symptoms\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.ID = e.ID\nWHERE p.Birthday = '1959-03-01' AND e.\"Examination Date\" = '1993-09-27';",
            "normalized": "SELECT e.Symptoms\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.ID = e.ID\nWHERE p.Birthday = '1959-03-01'\n  AND e.\"Examination Date\" = '1993-09-27';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "reference_sql_query": {
            "raw": "SELECT CAST((SUM(CASE WHEN T2.\"Date\"::TEXT LIKE '1981-11-%' THEN T2.\"T-CHO\"ELSE 0 END) - SUM(CASE WHEN T2.\"Date\"::TEXT LIKE '1981-12-%' THEN T2.\"T-CHO\"ELSE 0 END)) AS DOUBLE PRECISION) / SUM(CASE WHEN T2.\"Date\"::TEXT LIKE '1981-12-%' THEN T2.\"T-CHO\"ELSE 0 END) FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"Birthday\" = '1959-02-18'",
            "normalized": "SELECT CAST((SUM(CASE\n                     WHEN T2.\"Date\"::TEXT LIKE '1981-11-%' THEN T2.\"T-CHO\"\n                     ELSE 0\n                 END) - SUM(CASE\n                                WHEN T2.\"Date\"::TEXT LIKE '1981-12-%' THEN T2.\"T-CHO\"\n                                ELSE 0\n                            END)) AS DOUBLE PRECISION) / SUM(CASE\n                                                                 WHEN T2.\"Date\"::TEXT LIKE '1981-12-%' THEN T2.\"T-CHO\"\n                                                                 ELSE 0\n                                                             END)\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"Birthday\" = '1959-02-18'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    ((MAX(\"T-CHO\") FILTER (WHERE EXTRACT(MONTH FROM \"Date\") = 11) - MAX(\"T-CHO\") FILTER (WHERE EXTRACT(MONTH FROM \"Date\") = 12))::FLOAT / NULLIF(MAX(\"T-CHO\") FILTER (WHERE EXTRACT(MONTH FROM \"Date\") = 11), 0)) * 100 AS decrease_rate\nFROM \n    public.\"Laboratory\" \nWHERE \n    \"ID\" = (SELECT \"ID\" FROM public.\"Patient\" WHERE \"Birthday\" = '1959-02-18')\n    AND EXTRACT(YEAR FROM \"Date\") = 1981;",
            "normalized": "SELECT ((MAX(\"T-CHO\") FILTER (\n                              WHERE EXTRACT(MONTH\n                                            FROM \"Date\") = 11) - MAX(\"T-CHO\") FILTER (\n                                                                                      WHERE EXTRACT(MONTH\n                                                                                                    FROM \"Date\") = 12))::FLOAT / NULLIF(MAX(\"T-CHO\") FILTER (\n                                                                                                                                                             WHERE EXTRACT(MONTH\n                                                                                                                                                                           FROM \"Date\") = 11), 0)) * 100 AS decrease_rate\nFROM public.\"Laboratory\"\nWHERE \"ID\" =\n    (SELECT \"ID\"\n     FROM public.\"Patient\"\n     WHERE \"Birthday\" = '1959-02-18')\n  AND EXTRACT(YEAR\n              FROM \"Date\") = 1981;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "Lists all patients by ID who were diagnosed with Behcet's and had their exams between 01/01/197 and 12/31/1997.",
        "reference_sql_query": {
            "raw": "SELECT \"ID\"  FROM \"Examination\" WHERE\"Examination Date\"BETWEEN '1997-01-01' AND '1997-12-31' AND \"Diagnosis\" = 'Behcet'",
            "normalized": "SELECT \"ID\"\nFROM \"Examination\"\nWHERE\"Examination Date\"BETWEEN '1997-01-01' AND '1997-12-31'\n  AND \"Diagnosis\" = 'Behcet'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT p.\"ID\"\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nWHERE p.\"Diagnosis\" = 'Behcet''s'\nAND e.\"Examination Date\" BETWEEN '1970-01-01' AND '1997-12-31';",
            "normalized": "SELECT DISTINCT p.\"ID\"\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.\"ID\" = e.\"ID\"\nWHERE p.\"Diagnosis\" = 'Behcet''s'\n  AND e.\"Examination Date\" BETWEEN '1970-01-01' AND '1997-12-31';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT \"ID\" FROM \"Laboratory\" WHERE \"Date\" BETWEEN '1987-07-06' AND '1996-01-31' AND \"GPT\" > 30 AND \"ALB\"  < 4",
            "normalized": "SELECT DISTINCT \"ID\"\nFROM \"Laboratory\"\nWHERE \"Date\" BETWEEN '1987-07-06' AND '1996-01-31'\n  AND \"GPT\" > 30\n  AND \"ALB\" < 4"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT e.\"ID\"\nFROM public.\"Examination\" e\nJOIN public.\"Laboratory\" l ON e.\"ID\" = l.\"ID\"\nWHERE e.\"Examination Date\" BETWEEN '1987-07-06' AND '1996-01-31'\nAND l.\"GPT\" > 30\nAND l.\"ALB\" < 4;",
            "normalized": "SELECT DISTINCT e.\"ID\"\nFROM public.\"Examination\" e\nJOIN public.\"Laboratory\" l ON e.\"ID\" = l.\"ID\"\nWHERE e.\"Examination Date\" BETWEEN '1987-07-06' AND '1996-01-31'\n  AND l.\"GPT\" > 30\n  AND l.\"ALB\" < 4;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many female patients born in 1964 were admitted to the hospital? List them by ID.",
        "reference_sql_query": {
            "raw": "SELECT \"ID\"  FROM \"Patient\" WHERE EXTRACT(YEAR FROM \"Birthday\") = '1964' AND \"SEX\" = 'F' AND \"Admission\" = '+'",
            "normalized": "SELECT \"ID\"\nFROM \"Patient\"\nWHERE EXTRACT(YEAR\n              FROM \"Birthday\") = '1964'\n  AND \"SEX\" = 'F'\n  AND \"Admission\" = '+'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"ID\"\nFROM public.\"Patient\"\nWHERE \"SEX\" = 'female' AND EXTRACT(YEAR FROM \"Birthday\") = 1964 AND \"Admission\" IS NOT NULL;",
            "normalized": "SELECT \"ID\"\nFROM public.\"Patient\"\nWHERE \"SEX\" = 'female'\n  AND EXTRACT(YEAR\n              FROM \"Birthday\") = 1964\n  AND \"Admission\" IS NOT NULL;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"UA\" <= 6.5 THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(\"ID\") FROM \"Laboratory\" WHERE \"U-PRO\" ~ '^[-]?[0-9]+(\\.[0-9]+)?$' AND \"U-PRO\"::DOUBLE PRECISION > 0 AND \"U-PRO\"::DOUBLE PRECISION < 30",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"UA\" <= 6.5 THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(\"ID\")\nFROM \"Laboratory\"\nWHERE \"U-PRO\" ~ '^[-]?[0-9]+(\\.[0-9]+)?$'\n  AND \"U-PRO\"::DOUBLE PRECISION > 0\n  AND \"U-PRO\"::DOUBLE PRECISION < 30"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the normal range for proteinuria and uric acid levels.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the\nNORMAL RANGE\nFOR proteinuria\nAND uric acid levels."
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Diagnosis\" = 'BEHCET' THEN 1 ELSE 0 END) AS DOUBLE PRECISION) * 100 / COUNT(\"ID\")  FROM \"Patient\" WHERE EXTRACT(YEAR FROM\"First Date\") = '1981' AND \"SEX\" = 'M'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Diagnosis\" = 'BEHCET' THEN 1\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / COUNT(\"ID\")\nFROM \"Patient\"\nWHERE EXTRACT(YEAR\n              FROM\"First Date\") = '1981'\n  AND \"SEX\" = 'M'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(CASE WHEN Diagnosis = 'BEHCET' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_of_male_patients\nFROM \n    public.\"Patient\"\nWHERE \n    SEX = 'Male' \n    AND EXTRACT(YEAR FROM \"First Date\") = 1981;",
            "normalized": "SELECT (COUNT(CASE\n                  WHEN Diagnosis = 'BEHCET' THEN 1\n              END) * 100.0 / COUNT(*)) AS percentage_of_male_patients\nFROM public.\"Patient\"\nWHERE SEX = 'Male'\n  AND EXTRACT(YEAR\n              FROM \"First Date\") = 1981;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ID\" FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T1.\"Admission\" = '-' AND T2.\"T-BIL\"< 2.0 AND T2.\"Date\"::TEXT LIKE '1991-10-%'",
            "normalized": "SELECT DISTINCT T1.\"ID\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T1.\"Admission\" = '-'\n  AND T2.\"T-BIL\"< 2.0\n  AND T2.\"Date\"::TEXT LIKE '1991-10-%'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT p.ID\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.ID = l.ID\nWHERE p.Description IS NOT NULL\nAND l.Date BETWEEN '1991-10-01' AND '1991-10-31'\nAND l.\"T-BIL\" BETWEEN 0.1 AND 1.2;",
            "normalized": "SELECT DISTINCT p.ID\nFROM public.\"Patient\" p\nJOIN public.\"Laboratory\" l ON p.ID = l.ID\nWHERE p.Description IS NOT NULL\n  AND l.Date BETWEEN '1991-10-01' AND '1991-10-31'\n  AND l.\"T-BIL\" BETWEEN 0.1 AND 1.2;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"SEX\" FROM \"Patient\" AS T1 INNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\" INNER JOIN \"Laboratory\" AS T3 ON T3.\"ID\" = T2.\"ID\" WHERE T2.\"Diagnosis\" = 'PSS' AND T3.\"CRP\" = '2+' AND T3.\"CRE\" = 1.0 AND T3.\"LDH\" = 123",
            "normalized": "SELECT T1.\"SEX\"\nFROM \"Patient\" AS T1\nINNER JOIN \"Examination\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nINNER JOIN \"Laboratory\" AS T3 ON T3.\"ID\" = T2.\"ID\"\nWHERE T2.\"Diagnosis\" = 'PSS'\n  AND T3.\"CRP\" = '2+'\n  AND T3.\"CRE\" = 1.0\n  AND T3.\"LDH\" = 123"
        },
        "generated_sql_query": {
            "raw": "SELECT p.SEX\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.ID = e.ID\nJOIN public.\"Laboratory\" l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\n  AND l.\"CRP\" = '2+'\n  AND l.\"CRE\" = 1\n  AND l.\"LDH\" = 123;",
            "normalized": "SELECT p.SEX\nFROM public.\"Patient\" p\nJOIN public.\"Examination\" e ON p.ID = e.ID\nJOIN public.\"Laboratory\" l ON p.ID = l.ID\nWHERE e.Diagnosis = 'PSS'\n  AND l.\"CRP\" = '2+'\n  AND l.\"CRE\" = 1\n  AND l.\"LDH\" = 123;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T2.\"ALB\") FROM \"Patient\" AS T1 INNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\" WHERE T2.\"PLT\" > 400 AND T1.\"Diagnosis\" = 'SLE' AND T1.\"SEX\" = 'F'",
            "normalized": "SELECT AVG(T2.\"ALB\")\nFROM \"Patient\" AS T1\nINNER JOIN \"Laboratory\" AS T2 ON T1.\"ID\" = T2.\"ID\"\nWHERE T2.\"PLT\" > 400\n  AND T1.\"Diagnosis\" = 'SLE'\n  AND T1.\"SEX\" = 'F'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(l.\"ALB\") AS average_albumin_level\nFROM public.\"Laboratory\" l\nJOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\nWHERE p.\"SEX\" = 'Female' AND l.\"PLT\" > 400 AND p.\"Diagnosis\" = 'SLE';",
            "normalized": "SELECT AVG(l.\"ALB\") AS average_albumin_level\nFROM public.\"Laboratory\" l\nJOIN public.\"Patient\" p ON l.\"ID\" = p.\"ID\"\nWHERE p.\"SEX\" = 'Female'\n  AND l.\"PLT\" > 400\n  AND p.\"Diagnosis\" = 'SLE';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What is the most common sign of patients with SLE disease?",
        "reference_sql_query": {
            "raw": "SELECT \"Symptoms\" FROM \"Examination\" WHERE \"Diagnosis\" = 'SLE' GROUP BY \"Symptoms\" ORDER BY COUNT(\"Symptoms\") DESC LIMIT 1",
            "normalized": "SELECT \"Symptoms\"\nFROM \"Examination\"\nWHERE \"Diagnosis\" = 'SLE'\nGROUP BY \"Symptoms\"\nORDER BY COUNT(\"Symptoms\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate a SQL query for the question because there is no information about SLE disease or specific signs/symptoms associated with it in the given tables.",
            "normalized": "The provided context IS insufficient TO generate a SQL query\nFOR the question because there IS NO information about SLE disease\nOR SPECIFIC signs/symptoms associated WITH it IN the given tables."
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "reference_sql_query": {
            "raw": "SELECT\"First Date\", \"Diagnosis\" FROM \"Patient\"  WHERE \"ID\" = '48473'",
            "normalized": "SELECT\"First Date\",\n      \"Diagnosis\"\nFROM \"Patient\"\nWHERE \"ID\" = '48473'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"First Date\", \"Diagnosis\"\nFROM public.\"Patient\"\nWHERE \"ID\" = 48473;",
            "normalized": "SELECT \"First Date\",\n       \"Diagnosis\"\nFROM public.\"Patient\"\nWHERE \"ID\" = 48473;"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "How many female patients were given an APS diagnosis?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"ID\")  FROM \"Patient\" WHERE \"SEX\" = 'F' AND \"Diagnosis\" = 'APS'",
            "normalized": "SELECT COUNT(\"ID\")\nFROM \"Patient\"\nWHERE \"SEX\" = 'F'\n  AND \"Diagnosis\" = 'APS'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS Female_APS_Patients_Count\nFROM public.\"Patient\"\nWHERE \"SEX\" = 'Female' AND \"Diagnosis\" = 'APS';",
            "normalized": "SELECT COUNT(*) AS Female_APS_Patients_Count\nFROM public.\"Patient\"\nWHERE \"SEX\" = 'Female'\n  AND \"Diagnosis\" = 'APS';"
        },
        "db_id": "thrombosis_prediction"
    },
    {
        "question": "What's Angela Sanders's major?",
        "reference_sql_query": {
            "raw": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Angela' AND T1.last_name = 'Sanders'",
            "normalized": "SELECT T2.major_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.first_name = 'Angela'\n  AND T1.last_name = 'Sanders'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no direct information available about Angela Sanders or her major in the given tables. The context does not include any reference to a table or columns that would store members' names alongside their majors.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO direct information available about Angela Sanders\nOR her major IN the given tables. The context does NOT INCLUDE ANY reference TO a TABLE\nOR columns that would store members' NAMES alongside their majors."
        },
        "db_id": "student_club"
    },
    {
        "question": "How many students in the Student_Club are from the College of Engineering?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Engineering'",
            "normalized": "SELECT COUNT(T1.member_id)\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.college = 'College of Engineering'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no table named `Student_Club` and no table that directly associates students with their colleges or majors. The `major` table contains information about majors and colleges, but there is no clear link between students and the College of Engineering. Additional context or tables linking students to their majors or colleges would be needed.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO TABLE named `Student_Club`\nAND NO TABLE that directly associates students WITH their colleges\nOR majors. The `major` TABLE CONTAINS information about majors\nAND colleges,\n    but there IS NO clear LINK BETWEEN students AND the College OF Engineering. Additional context\nOR TABLES linking students TO their majors\nOR colleges would be needed."
        },
        "db_id": "student_club"
    },
    {
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "reference_sql_query": {
            "raw": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
            "normalized": "SELECT T1.first_name,\n       T1.last_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'Art and Design Department'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no table named `Student_Club` or any direct reference to student club membership or the Art and Design Department. The `major` and `member` tables could potentially be relevant, but without specific information linking members to the Art and Design Department, a query cannot be generated.",
            "normalized": "The provided context IS insufficient because there IS NO TABLE named `Student_Club`\nOR ANY direct reference TO student club membership\nOR the Art\nAND Design Department. The `major`\nAND `member` TABLES could potentially be relevant,\n                                      but WITHOUT SPECIFIC information linking members TO the Art\nAND Design Department,\n    a query cannot be generated."
        },
        "db_id": "student_club"
    },
    {
        "question": "How many students of the Student_Club have attended the event \"Women's Soccer\"?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
            "normalized": "SELECT COUNT(T1.event_id)\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'Women''s Soccer'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because there is no table named \"Student_Club\" in the provided context. Additionally, the \"attendance\" and \"event\" tables do not have a direct connection to identify students belonging to a specific club, nor is there a specific event name \"Women's Soccer\" mentioned in the context.",
            "normalized": "It can't be generated because there is no table named \"Student_Club\" in the provided context. Additionally, the \"attendance\" and \"event\" tables do not have a direct connection to identify students belonging to a specific club, nor is there a specific event name \"Women's Soccer\" mentioned IN the context."
        },
        "db_id": "student_club"
    },
    {
        "question": "Among the students from the Student_Club who attended the event \"Women's Soccer\", how many of them want a T-shirt that's in medium size?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer' AND T3.t_shirt_size = 'Medium'",
            "normalized": "SELECT COUNT(T1.event_id)\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T1.event_name = 'Women''s Soccer'\n  AND T3.t_shirt_size = 'Medium'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM member \nJOIN attendance ON member.member_id = attendance.link_to_member\nJOIN event ON attendance.link_to_event = event.event_id\nWHERE event.event_name = 'Women''s Soccer' AND member.t_shirt_size = 'M';",
            "normalized": "SELECT COUNT(*)\nFROM member\nJOIN attendance ON member.member_id = attendance.link_to_member\nJOIN event ON attendance.link_to_event = event.event_id\nWHERE event.event_name = 'Women''s Soccer'\n  AND member.t_shirt_size = 'M';"
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the event that has the highest attendance of the students from the Student_Club?",
        "reference_sql_query": {
            "raw": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
            "normalized": "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_name\nORDER BY COUNT(T2.link_to_event) DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "It is not possible to generate the SQL query because the provided context does not include a table named \"Student_Club\" or any information about identifying students or members in the \"attendance\" or \"event\" tables. Additionally, there is no direct link between attendance records and event details that would specify which events are attended by students or members of a \"Student_Club.\"",
            "normalized": "It IS NOT possible TO generate the SQL query because the provided context does NOT INCLUDE a TABLE named \"Student_Club\"\nOR ANY information about identifying students\nOR members IN the \"attendance\"\nOR \"event\" tables. Additionally,\n   there IS NO direct LINK BETWEEN attendance records AND event details that would specify which EVENTS ARE attended BY students\nOR members OF a \"Student_Club.\""
        },
        "db_id": "student_club"
    },
    {
        "question": "Which college is the vice president of the Student_Club from?",
        "reference_sql_query": {
            "raw": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.\"position\" LIKE 'vice president'",
            "normalized": "SELECT T2.college\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.\"position\" LIKE 'vice president'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information on the structure or data of a \"Student_Club\" table or any table that contains a record of positions such as \"vice president\" associated with a college.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information ON the STRUCTURE\nOR DATA OF a \"Student_Club\" TABLE\nOR ANY TABLE that CONTAINS a record OF positions such AS \"vice president\" associated WITH a college."
        },
        "db_id": "student_club"
    },
    {
        "question": "Please list the event names of all the events attended by Maya Mclean.",
        "reference_sql_query": {
            "raw": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'",
            "normalized": "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T3.first_name = 'Maya'\n  AND T3.last_name = 'Mclean'"
        },
        "generated_sql_query": {
            "raw": "SELECT e.event_name\nFROM public.event e\nJOIN public.attendance a ON e.event_id = a.link_to_event\nJOIN public.member m ON a.link_to_member = m.member_id\nWHERE m.first_name = 'Maya' AND m.last_name = 'Mclean';",
            "normalized": "SELECT e.event_name\nFROM public.event e\nJOIN public.attendance a ON e.event_id = a.link_to_event\nJOIN public.member m ON a.link_to_member = m.member_id\nWHERE m.first_name = 'Maya'\n  AND m.last_name = 'Mclean';"
        },
        "db_id": "student_club"
    },
    {
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
            "normalized": "SELECT COUNT(T1.event_id)\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T3.first_name = 'Sacha'\n  AND T3.last_name = 'Harrison'\n  AND SUBSTR(T1.event_date, 1, 4) = '2019'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no information about the \"Student_Club\" or the specific attendance records related to \"Sacha Harrison\" in the available tables. The tables do not contain information linking members to events with their names or specific club details.",
            "normalized": "The provided context IS insufficient because there IS NO information about the \"Student_Club\"\nOR the SPECIFIC attendance records related TO \"Sacha Harrison\" IN the available tables. The TABLES DO NOT contain information linking members TO EVENTS WITH their NAMES\nOR SPECIFIC club details."
        },
        "db_id": "student_club"
    },
    {
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "reference_sql_query": {
            "raw": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id, T1.event_name  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
            "normalized": "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_id,\n         T1.event_name\nHAVING COUNT(T2.link_to_event) > 10\nEXCEPT\nSELECT T1.event_name\nFROM event AS T1\nWHERE T1.type = 'Meeting'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT e.event_id) AS meeting_count\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_id, e.type\nHAVING COUNT(DISTINCT a.link_to_member) > 10 AND e.type = 'meeting';",
            "normalized": "SELECT COUNT(DISTINCT e.event_id) AS meeting_count\nFROM event e\nJOIN attendance a ON e.event_id = a.link_to_event\nGROUP BY e.event_id,\n         e.type\nHAVING COUNT(DISTINCT a.link_to_member) > 10\nAND e.type = 'meeting';"
        },
        "db_id": "student_club"
    },
    {
        "question": "List all the names of events that had an attendance of over 20 students but were not fundraisers.",
        "reference_sql_query": {
            "raw": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id, T1.event_name HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1  WHERE T1.type = 'Fundraiser'",
            "normalized": "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_id,\n         T1.event_name\nHAVING COUNT(T2.link_to_event) > 20\nEXCEPT\nSELECT T1.event_name\nFROM event AS T1\nWHERE T1.type = 'Fundraiser'"
        },
        "generated_sql_query": {
            "raw": "SELECT e.event_name \nFROM public.event e\nJOIN public.attendance a ON e.event_id = a.link_to_event\nWHERE e.type != 'Fundraiser'\nGROUP BY e.event_name\nHAVING COUNT(a.link_to_member) > 20;",
            "normalized": "SELECT e.event_name\nFROM public.event e\nJOIN public.attendance a ON e.event_id = a.link_to_event\nWHERE e.type != 'Fundraiser'\nGROUP BY e.event_name\nHAVING COUNT(a.link_to_member) > 20;"
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the average attendance of meetings in 2020?",
        "reference_sql_query": {
            "raw": "SELECT CAST(COUNT(T2.link_to_event) AS DOUBLE PRECISION) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
            "normalized": "SELECT CAST(COUNT(T2.link_to_event) AS DOUBLE PRECISION) / COUNT(DISTINCT T2.link_to_event)\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nWHERE SUBSTR(T1.event_date, 1, 4) = '2020'\n  AND T1.type = 'Meeting'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information on how attendance is recorded in relation to events, such as the number of attendees per event or how to filter events held in 2020. Additional information or tables are needed to compute the average attendance of meetings in 2020.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information ON how attendance IS recorded IN relation TO EVENTS,\n                                                                                                                                            such AS the number OF attendees per event\nOR how TO filter EVENTS held IN 2020. Additional information\nOR TABLES ARE needed TO compute the average attendance OF meetings IN 2020."
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the most expensive item that was spent in support of club events?",
        "reference_sql_query": {
            "raw": "SELECT expense_description FROM expense ORDER BY cost DESC LIMIT 1",
            "normalized": "SELECT expense_description\nFROM expense\nORDER BY cost DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT expense_description, MAX(cost) as max_cost\nFROM public.expense\nJOIN public.budget ON public.expense.link_to_budget = public.budget.budget_id\nWHERE public.budget.category = 'club events'\nGROUP BY expense_description\nORDER BY max_cost DESC\nLIMIT 1;",
            "normalized": "SELECT expense_description,\n       MAX(cost) AS max_cost\nFROM public.expense\nJOIN public.budget ON public.expense.link_to_budget = public.budget.budget_id\nWHERE public.budget.category = 'club events'\nGROUP BY expense_description\nORDER BY max_cost DESC\nLIMIT 1;"
        },
        "db_id": "student_club"
    },
    {
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
            "normalized": "SELECT COUNT(T1.member_id)\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.major_name = 'Environmental Engineering'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no information available about the Student_Club or its members' association with the major of Environmental Engineering. The `member` table does not contain a clear relationship with the `major` table that would allow us to determine the major of each member.",
            "normalized": "The provided context IS insufficient because there IS NO information available about the Student_Club\nOR its members' association WITH the major OF Environmental Engineering. The `member` TABLE does NOT contain a clear relationship WITH the `major` TABLE that would allow us TO determine the major OF EACH member."
        },
        "db_id": "student_club"
    },
    {
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "reference_sql_query": {
            "raw": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
            "normalized": "SELECT T1.first_name,\n       T1.last_name\nFROM member AS T1\nINNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member\nINNER JOIN event AS T3 ON T2.link_to_event = T3.event_id\nWHERE T3.event_name = 'Laugh Out Loud'"
        },
        "generated_sql_query": {
            "raw": "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nJOIN member m ON a.link_to_member = m.member_id\nWHERE e.event_name = 'Laugh Out Loud';",
            "normalized": "SELECT m.first_name || ' ' || m.last_name AS full_name\nFROM attendance a\nJOIN event e ON a.link_to_event = e.event_id\nJOIN member m ON a.link_to_member = m.member_id\nWHERE e.event_name = 'Laugh Out Loud';"
        },
        "db_id": "student_club"
    },
    {
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "reference_sql_query": {
            "raw": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
            "normalized": "SELECT T1.last_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.major_name = 'Law and Constitutional Studies'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no information available regarding the majors of students or a direct link between the \"major\" table and the \"member\" table that indicates what major a student is pursuing.",
            "normalized": "The provided context IS insufficient because there IS NO information available regarding the majors OF students\nOR a direct LINK BETWEEN the \"major\" TABLE AND the \"member\" TABLE that indicates what major a student IS pursuing."
        },
        "db_id": "student_club"
    },
    {
        "question": "What county did Sherri Ramsey grew up?",
        "reference_sql_query": {
            "raw": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'",
            "normalized": "SELECT T2.county\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Sherri'\n  AND T1.last_name = 'Ramsey'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about Sherri Ramsey or any related data in the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about Sherri Ramsey\nOR ANY related DATA IN the given tables."
        },
        "db_id": "student_club"
    },
    {
        "question": "What college offers the major that Tyler Hewitt took?",
        "reference_sql_query": {
            "raw": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
            "normalized": "SELECT T2.college\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.first_name = 'Tyler'\n  AND T1.last_name = 'Hewitt'"
        },
        "generated_sql_query": {
            "raw": "SELECT m.college\nFROM public.member mem\nJOIN public.major m ON mem.link_to_major = m.major_id\nWHERE mem.first_name = 'Tyler' AND mem.last_name = 'Hewitt';",
            "normalized": "SELECT m.college\nFROM public.member mem\nJOIN public.major m ON mem.link_to_major = m.major_id\nWHERE mem.first_name = 'Tyler'\n  AND mem.last_name = 'Hewitt';"
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the amount of the funds that the Vice President received?",
        "reference_sql_query": {
            "raw": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.\"position\" = 'Vice President'",
            "normalized": "SELECT T2.amount\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T1.\"position\" = 'Vice President'"
        },
        "generated_sql_query": {
            "raw": "SELECT SUM(amount) AS total_amount_received\nFROM public.income\nWHERE source = 'Vice President';",
            "normalized": "SELECT SUM(amount) AS total_amount_received\nFROM public.income\nWHERE SOURCE = 'Vice President';"
        },
        "db_id": "student_club"
    },
    {
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "reference_sql_query": {
            "raw": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
            "normalized": "SELECT T2.spent\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'September Meeting'\n  AND T2.category = 'Food'\n  AND SUBSTR(T1.event_date, 6, 2) = '09'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because the provided context does not specify which table or column contains information about the \"Student_Club,\" \"food,\" or \"September Meeting.\" Additional details are needed to create an accurate query.",
            "normalized": "It can't be GENERATED because the provided context does NOT specify which TABLE\nOR COLUMN CONTAINS information about the \"Student_Club,\" \"food,\"\nOR \"September Meeting.\" Additional details ARE needed TO\nCREATE an accurate query."
        },
        "db_id": "student_club"
    },
    {
        "question": "What city and state did the President of the Student_Club grow up?",
        "reference_sql_query": {
            "raw": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.\"position\" = 'President'",
            "normalized": "SELECT T2.city,\n       T2.state\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.\"position\" = 'President'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the \"President of the Student_Club\" or any related details that can link to their city and state. The available tables do not contain relevant information about the Student_Club or any position related to a president.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the \"President of the Student_Club\"\nOR ANY related details that can LINK TO their city\nAND state. The available TABLES DO NOT contain relevant information about the Student_Club\nOR ANY POSITION related TO a president."
        },
        "db_id": "student_club"
    },
    {
        "question": "List the full name of the Student_Club members that grew up in Illinois state.",
        "reference_sql_query": {
            "raw": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'",
            "normalized": "SELECT T1.first_name,\n       T1.last_name\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T2.state = 'Illinois'"
        },
        "generated_sql_query": {
            "raw": "SELECT first_name || ' ' || last_name AS full_name\nFROM public.member\nJOIN public.zip_code ON public.member.zip = public.zip_code.zip_code\nWHERE public.zip_code.state = 'Illinois';",
            "normalized": "SELECT first_name || ' ' || last_name AS full_name\nFROM public.member\nJOIN public.zip_code ON public.member.zip = public.zip_code.zip_code\nWHERE public.zip_code.state = 'Illinois';"
        },
        "db_id": "student_club"
    },
    {
        "question": "How much did the Student_Club members spend on advertisement in September Meeting?",
        "reference_sql_query": {
            "raw": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
            "normalized": "SELECT T2.spent\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'September Meeting'\n  AND T2.category = 'Advertisement'\n  AND SUBSTR(T1.event_date, 6, 2) = '09'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated because the provided context does not include information on the \"Student_Club,\" \"advertisement,\" or \"September Meeting.\" Additionally, there is no direct relationship between expenses and specific events or categories such as advertisement or meetings.",
            "normalized": "It can't be GENERATED because the provided context does NOT INCLUDE information ON the \"Student_Club,\" \"advertisement,\"\nOR \"September Meeting.\" Additionally,\n   there IS NO direct relationship BETWEEN expenses AND SPECIFIC EVENTS\nOR categories such AS advertisement\nOR meetings."
        },
        "db_id": "student_club"
    },
    {
        "question": "What department offers the major that Pierce and Guidi took?",
        "reference_sql_query": {
            "raw": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'",
            "normalized": "SELECT T2.department\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.last_name = 'Pierce'\n  OR T1.last_name = 'Guidi'"
        },
        "generated_sql_query": {
            "raw": "SELECT m.first_name, m.last_name, maj.department\nFROM public.member m\nJOIN public.major maj ON m.link_to_major = maj.major_id\nWHERE (m.first_name = 'Pierce' AND m.last_name = 'Guidi');",
            "normalized": "SELECT m.first_name,\n       m.last_name,\n       maj.department\nFROM public.member m\nJOIN public.major maj ON m.link_to_major = maj.major_id\nWHERE (m.first_name = 'Pierce'\n       AND m.last_name = 'Guidi');"
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the total budgeted amount for all category in \"October Speaker\" event?",
        "reference_sql_query": {
            "raw": "SELECT SUM(T2.amount) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Speaker'",
            "normalized": "SELECT SUM(T2.amount)\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'October Speaker'"
        },
        "generated_sql_query": {
            "raw": "SELECT SUM(amount) AS total_budgeted_amount\nFROM public.budget\nWHERE link_to_event = (\n    SELECT event_id\n    FROM public.event\n    WHERE event_name = 'October Speaker'\n);",
            "normalized": "SELECT SUM(amount) AS total_budgeted_amount\nFROM public.budget\nWHERE link_to_event =\n    (SELECT event_id\n     FROM public.event\n     WHERE event_name = 'October Speaker');"
        },
        "db_id": "student_club"
    },
    {
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "reference_sql_query": {
            "raw": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
            "normalized": "SELECT T3.approved\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting'\n  AND T1.event_date LIKE '2019-10-08%'"
        },
        "generated_sql_query": {
            "raw": "SELECT expense_id, expense_description, approved\nFROM public.expense\nWHERE expense_date = '2019-10-08' AND expense_description = 'October Meeting';",
            "normalized": "SELECT expense_id,\n       expense_description,\n       approved\nFROM public.expense\nWHERE expense_date = '2019-10-08'\n  AND expense_description = 'October Meeting';"
        },
        "db_id": "student_club"
    },
    {
        "question": "Calculate the total average cost that Elijah Allen spent in the events on September and October.",
        "reference_sql_query": {
            "raw": "SELECT AVG(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.last_name = 'Allen' AND T1.first_name = 'Elijah' AND (SUBSTR(T2.expense_date, 6, 2) = '09' OR SUBSTR(T2.expense_date, 6, 2) = '10')",
            "normalized": "SELECT AVG(T2.cost)\nFROM member AS T1\nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member\nWHERE T1.last_name = 'Allen'\n  AND T1.first_name = 'Elijah'\n  AND (SUBSTR(T2.expense_date, 6, 2) = '09'\n       OR SUBSTR(T2.expense_date, 6, 2) = '10')"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the query because it does not contain information about the specific member names linked to expenses, nor does it provide a way to filter expenses by month. Additional details about member names and date filtering are needed to accurately calculate the total average cost for Elijah Allen.",
            "normalized": "The provided context IS insufficient TO generate the query because it does NOT contain information about the SPECIFIC member NAMES linked TO expenses,\n                                                                                                                                             nor does it provide a way TO filter expenses BY month. Additional details about member NAMES\nAND date filtering ARE needed TO accurately calculate the total average cost\nFOR Elijah Allen."
        },
        "db_id": "student_club"
    },
    {
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
            "normalized": "SELECT SUM(CASE\n               WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent\n               ELSE 0\n           END) - SUM(CASE\n                          WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent\n                          ELSE 0\n                      END) AS num\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the year associated with the events in the `budget` table, nor a direct link between the `event` table and the `budget` table that specifies the year or the organization (e.g., \"Student_Club\") responsible for the events.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the YEAR associated WITH the EVENTS IN the `budget` TABLE,\n                                                                                                                                                         nor a direct LINK BETWEEN the `event` TABLE AND the `budget` TABLE that specifies the YEAR\nOR the\nORGANIZATION (e.g.,\n              \"Student_Club\") responsible\nFOR the events."
        },
        "db_id": "student_club"
    },
    {
        "question": "Give the location for \"Spring Budget Review\".",
        "reference_sql_query": {
            "raw": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
            "normalized": "SELECT LOCATION\nFROM event\nWHERE event_name = 'Spring Budget Review'"
        },
        "generated_sql_query": {
            "raw": "SELECT location \nFROM public.event \nWHERE event_name = 'Spring Budget Review';",
            "normalized": "SELECT LOCATION\nFROM public.event\nWHERE event_name = 'Spring Budget Review';"
        },
        "db_id": "student_club"
    },
    {
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "reference_sql_query": {
            "raw": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
            "normalized": "SELECT cost\nFROM expense\nWHERE expense_description = 'Posters'\n  AND expense_date = '2019-09-04'"
        },
        "generated_sql_query": {
            "raw": "SELECT cost \nFROM public.expense \nWHERE expense_description = 'Posters' AND expense_date = '2019/9/4';",
            "normalized": "SELECT cost\nFROM public.expense\nWHERE expense_description = 'Posters'\n  AND expense_date = '2019/9/4';"
        },
        "db_id": "student_club"
    },
    {
        "question": "With the biggest budget for the \"Food\", what was the remaining of it?",
        "reference_sql_query": {
            "raw": "SELECT remaining FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget WHERE category = 'Food' )",
            "normalized": "SELECT remaining\nFROM budget\nWHERE category = 'Food'\n  AND amount =\n    (SELECT MAX(amount)\n     FROM budget\n     WHERE category = 'Food')"
        },
        "generated_sql_query": {
            "raw": "SELECT remaining \nFROM public.budget \nWHERE category = 'Food' \nORDER BY amount DESC \nLIMIT 1;",
            "normalized": "SELECT remaining\nFROM public.budget\nWHERE category = 'Food'\nORDER BY amount DESC\nLIMIT 1;"
        },
        "db_id": "student_club"
    },
    {
        "question": "What was the notes of the fundraising on 2019/9/14?",
        "reference_sql_query": {
            "raw": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
            "normalized": "SELECT notes\nFROM income\nWHERE SOURCE = 'Fundraising'\n  AND date_received = '2019-09-14'"
        },
        "generated_sql_query": {
            "raw": "SELECT notes \nFROM public.event \nWHERE event_name = 'fundraising' AND event_date = '2019/9/14';",
            "normalized": "SELECT notes\nFROM public.event\nWHERE event_name = 'fundraising'\n  AND event_date = '2019/9/14';"
        },
        "db_id": "student_club"
    },
    {
        "question": "How many majors are there in \"College of Humanities and Social Sciences\"?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences'",
            "normalized": "SELECT COUNT(major_name)\nFROM major\nWHERE college = 'College of Humanities and Social Sciences'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS total_majors\nFROM public.major\nWHERE college = 'College of Humanities and Social Sciences';",
            "normalized": "SELECT COUNT(*) AS total_majors\nFROM public.major\nWHERE college = 'College of Humanities and Social Sciences';"
        },
        "db_id": "student_club"
    },
    {
        "question": "Tell the hometown county for \"Adela O'Gallagher\".",
        "reference_sql_query": {
            "raw": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'",
            "normalized": "SELECT T2.county\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Adela'\n  AND T1.last_name = 'O''Gallagher'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient because there is no direct link between the \"superhero\" table, which contains the name \"Adela O'Gallagher\", and the \"zip_code\" table, which contains county information. There is no information about which table or column links a person's name to their hometown or county.",
            "normalized": "The provided context IS insufficient because there IS NO direct LINK BETWEEN the \"superhero\" TABLE,\n                                                                                             which CONTAINS the name \"Adela O'Gallagher\",\nAND the \"zip_code\" TABLE,\n                   which CONTAINS county information. There IS NO information about which TABLE\nOR COLUMN links a person's name TO their hometown\nOR county."
        },
        "db_id": "student_club"
    },
    {
        "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
            "normalized": "SELECT COUNT(T2.event_id)\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T2.event_name = 'November Meeting'\n  AND T1.remaining < 0"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) AS exceeded_budget_count\nFROM budget\nWHERE link_to_event = 'November Meeting' AND spent > amount;",
            "normalized": "SELECT COUNT(*) AS exceeded_budget_count\nFROM budget\nWHERE link_to_event = 'November Meeting'\n  AND spent > amount;"
        },
        "db_id": "student_club"
    },
    {
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "reference_sql_query": {
            "raw": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
            "normalized": "SELECT SUM(T1.amount)\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T2.event_name = 'September Speaker'"
        },
        "generated_sql_query": {
            "raw": "SELECT SUM(amount) AS total_budget_amount\nFROM public.budget\nWHERE link_to_event = (\n    SELECT event_id\n    FROM public.event\n    WHERE event_name = 'September Speaker'\n);",
            "normalized": "SELECT SUM(amount) AS total_budget_amount\nFROM public.budget\nWHERE link_to_event =\n    (SELECT event_id\n     FROM public.event\n     WHERE event_name = 'September Speaker');"
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "reference_sql_query": {
            "raw": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
            "normalized": "SELECT T1.event_status\nFROM budget AS T1\nINNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget\nWHERE T2.expense_description = 'Post Cards, Posters'\n  AND T2.expense_date = '2019-08-20'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no direct relationship established between the `event` table and any table containing information about purchases or products related to \"Post Cards, Posters\" on the specified date.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO direct relationship established BETWEEN the `event` TABLE AND ANY TABLE containing information about purchases\nOR products related TO \"Post Cards, Posters\" ON the specified date."
        },
        "db_id": "student_club"
    },
    {
        "question": "What was Brent Thomason's major?",
        "reference_sql_query": {
            "raw": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'",
            "normalized": "SELECT T2.major_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.first_name = 'Brent'\n  AND T1.last_name = 'Thomason'"
        },
        "generated_sql_query": {
            "raw": "SELECT m.major_name \nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Brent' AND mb.last_name = 'Thomason';",
            "normalized": "SELECT m.major_name\nFROM member mb\nJOIN major m ON mb.link_to_major = m.major_id\nWHERE mb.first_name = 'Brent'\n  AND mb.last_name = 'Thomason';"
        },
        "db_id": "student_club"
    },
    {
        "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
            "normalized": "SELECT COUNT(T1.member_id)\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.major_name = 'Business'\n  AND T1.t_shirt_size = 'Medium'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.member m\nJOIN public.major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' AND m.t_shirt_size = 'Medium';",
            "normalized": "SELECT COUNT(*)\nFROM public.member m\nJOIN public.major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business'\n  AND m.t_shirt_size = 'Medium';"
        },
        "db_id": "student_club"
    },
    {
        "question": "What's Christof Nielson's zip code type?",
        "reference_sql_query": {
            "raw": "SELECT T2.type FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'",
            "normalized": "SELECT T2.type\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Christof'\n  AND T1.last_name = 'Nielson'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information about Christof Nielson or an association between individuals and the zip_code table. Therefore, it is insufficient to generate the SQL query.",
            "normalized": "The provided context does NOT contain information about Christof Nielson\nOR an association BETWEEN individuals AND the zip_code table. Therefore,\n                                                       it IS insufficient TO generate the SQL query."
        },
        "db_id": "student_club"
    },
    {
        "question": "State the major name for the Vice President of the club.",
        "reference_sql_query": {
            "raw": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.\"position\" = 'Vice President'",
            "normalized": "SELECT T2.major_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.\"position\" = 'Vice President'"
        },
        "generated_sql_query": {
            "raw": "SELECT major.major_name\nFROM member\nJOIN major ON member.link_to_major = major.major_id\nWHERE member.position = 'Vice President';",
            "normalized": "SELECT major.major_name\nFROM member\nJOIN major ON member.link_to_major = major.major_id\nWHERE member.position = 'Vice President';"
        },
        "db_id": "student_club"
    },
    {
        "question": "Where is the hometown state for \"Sacha Harrison\"?",
        "reference_sql_query": {
            "raw": "SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'",
            "normalized": "SELECT T2.state\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Sacha'\n  AND T1.last_name = 'Harrison'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to determine the hometown state for \"Sacha Harrison\" as there is no information or table related to individuals and their hometown states.",
            "normalized": "The provided context IS insufficient TO determine the hometown state\nFOR \"Sacha Harrison\" AS there IS NO information\nOR TABLE related TO individuals\nAND their hometown states."
        },
        "db_id": "student_club"
    },
    {
        "question": "Which department was the President of the club in?",
        "reference_sql_query": {
            "raw": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.\"position\" = 'President'",
            "normalized": "SELECT T2.department\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.\"position\" = 'President'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain sufficient information to determine which department the President of the club was in. The `member` table contains a \"position\" column, but there is no information linking a \"President\" position to a specific department. Additional data would be needed to answer this question.",
            "normalized": "The provided context does NOT contain sufficient information TO determine which department the President OF the club was IN. The `member` TABLE CONTAINS a \"position\" COLUMN,\n                                                                                                                                                                      but there IS NO information linking a \"President\" POSITION TO a SPECIFIC department. Additional DATA would be needed TO answer this question."
        },
        "db_id": "student_club"
    },
    {
        "question": "State the date Connor Hilton paid his/her dues.",
        "reference_sql_query": {
            "raw": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'",
            "normalized": "SELECT T2.date_received\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T1.first_name = 'Connor'\n  AND T1.last_name = 'Hilton'\n  AND T2.source = 'Dues'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no direct information linking a member's name (e.g., Connor Hilton) to the payment of dues. We would need a table that associates members with their payments or dues, which is not available in the current context.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO direct information linking a member's name (e.g., Connor Hilton) TO the payment OF dues. We would need a TABLE that associates members WITH their payments\nOR dues,\n   which IS NOT available IN the CURRENT context."
        },
        "db_id": "student_club"
    },
    {
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "reference_sql_query": {
            "raw": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
            "normalized": "SELECT T1.first_name,\n       T1.last_name\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T2.source = 'Dues'\nORDER BY T2.date_received\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT m.first_name, m.last_name\nFROM public.income i\nJOIN public.member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;",
            "normalized": "SELECT m.first_name,\n       m.last_name\nFROM public.income i\nJOIN public.member m ON i.link_to_member = m.member_id\nORDER BY i.date_received ASC\nLIMIT 1;"
        },
        "db_id": "student_club"
    },
    {
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS DOUBLE PRECISION) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount\n                    ELSE 0\n                END) AS DOUBLE PRECISION) / SUM(CASE\n                                                    WHEN T2.event_name = 'October Meeting' THEN T1.amount\n                                                    ELSE 0\n                                                END)\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Advertisement'\n  AND T2.type = 'Meeting'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query. The context does not include information about the events named \"Yearly Kickoff\" meeting and \"October Meeting\" within the `budget` table or any related table that could help identify these specific events and their associated budgets.",
            "normalized": "The provided context IS insufficient TO generate the SQL query. The context does NOT INCLUDE information about the EVENTS named \"Yearly Kickoff\" meeting\nAND \"October Meeting\" within the `budget` TABLE\nOR ANY related TABLE that could help identify these SPECIFIC EVENTS\nAND their associated budgets."
        },
        "db_id": "student_club"
    },
    {
        "question": "What percentage was the budget for Parking to the total budget for the \"November Speaker\"?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) AS DOUBLE PRECISION) * 100 / SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Speaker'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T1.category = 'Parking' THEN T1.amount\n                    ELSE 0\n                END) AS DOUBLE PRECISION) * 100 / SUM(T1.amount)\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T2.event_name = 'November Speaker'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SUM(CASE WHEN category = 'Parking' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_parking_budget\nFROM \n    public.budget\nWHERE \n    event_status = 'November Speaker';",
            "normalized": "SELECT (SUM(CASE\n                WHEN category = 'Parking' THEN amount\n                ELSE 0\n            END) * 100.0 / SUM(amount)) AS percentage_parking_budget\nFROM public.budget\nWHERE event_status = 'November Speaker';"
        },
        "db_id": "student_club"
    },
    {
        "question": "What is the total cost of the pizzas for all the events?",
        "reference_sql_query": {
            "raw": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
            "normalized": "SELECT SUM(cost)\nFROM expense\nWHERE expense_description = 'Pizza'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about pizzas or a related product category in the given table schemas.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about pizzas\nOR a related product category IN the given TABLE schemas."
        },
        "db_id": "student_club"
    },
    {
        "question": "How many gas stations in CZE has Premium gas?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(\"GasStationID\") FROM gasstations WHERE \"Country\" = 'CZE' AND \"Segment\" = 'Premium'",
            "normalized": "SELECT COUNT(\"GasStationID\")\nFROM gasstations\nWHERE \"Country\" = 'CZE'\n  AND \"Segment\" = 'Premium'"
        },
        "generated_sql_query": {
            "raw": "It can't be generated. The provided context does not contain information about the types of gas (such as \"Premium\") available at each gas station. The context only includes tables related to gas stations and transactions, but no details about gas types.",
            "normalized": "It can't be generated. The provided context does NOT contain information about the types OF gas (such AS \"Premium\") available AT EACH gas station. The context ONLY includes TABLES related TO gas stations\nAND transactions,\n    but NO details about gas types."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Currency\" = 'EUR' THEN 1 ELSE 0 END) AS FLOAT) / SUM(CASE WHEN \"Currency\" = 'CZK' THEN 1 ELSE 0 END) AS ratio FROM customers",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Currency\" = 'EUR' THEN 1\n                    ELSE 0\n                END) AS FLOAT) / SUM(CASE\n                                         WHEN \"Currency\" = 'CZK' THEN 1\n                                         ELSE 0\n                                     END) AS ratio\nFROM customers"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SELECT COUNT(*) FROM public.customers WHERE \"Currency\" = 'EUR')::FLOAT /\n    (SELECT COUNT(*) FROM public.customers WHERE \"Currency\" = 'CZK')::FLOAT AS eur_to_czk_ratio;",
            "normalized": "SELECT\n  (SELECT COUNT(*)\n   FROM public.customers\n   WHERE \"Currency\" = 'EUR')::FLOAT /\n  (SELECT COUNT(*)\n   FROM public.customers\n   WHERE \"Currency\" = 'CZK')::FLOAT AS eur_to_czk_ratio;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "In 2012, who had the least consumption in LAM?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"CustomerID\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Segment\" = 'LAM' AND SUBSTR(T2.\"Date\", 1, 4) = '2012' GROUP BY T1.\"CustomerID\" ORDER BY SUM(T2.\"Consumption\") ASC LIMIT 1",
            "normalized": "SELECT T1.\"CustomerID\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Segment\" = 'LAM'\n  AND SUBSTR(T2.\"Date\", 1, 4) = '2012'\nGROUP BY T1.\"CustomerID\"\nORDER BY SUM(T2.\"Consumption\") ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "It can't be generated. The provided context does not include information about regions or specific consumption data that can be linked to \"LAM\" for the year 2012. The `yearmonth` table includes \"CustomerID,\" \"Date,\" and \"Consumption,\" but there is no explicit mention of \"LAM\" or a method to filter by region or location.",
            "normalized": "It can't be generated. The provided context does NOT INCLUDE information about regions\nOR SPECIFIC consumption DATA that can be linked TO \"LAM\"\nFOR the YEAR 2012. The `yearmonth` TABLE includes \"CustomerID,\" \"Date,\"\nAND \"Consumption,\" but there IS NO explicit mention OF \"LAM\"\nOR a METHOD TO filter BY region\nOR location."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T2.\"Consumption\") / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE SUBSTR(T2.\"Date\", 1, 4) = '2013' AND T1.\"Segment\" = 'SME'",
            "normalized": "SELECT AVG(T2.\"Consumption\") / 12\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE SUBSTR(T2.\"Date\", 1, 4) = '2013'\n  AND T1.\"Segment\" = 'SME'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(y.Consumption) AS Average_Monthly_Consumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME' AND y.Date LIKE '2013%'",
            "normalized": "SELECT AVG(y.Consumption) AS Average_Monthly_Consumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'SME'\n  AND y.Date LIKE '2013%'"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which customers, paying in CZK, consumed the most gas in 2011?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"CustomerID\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Currency\" = 'CZK' AND CAST(T2.\"Date\" AS INTEGER) BETWEEN 201101 AND 201112 GROUP BY T1.\"CustomerID\" ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT T1.\"CustomerID\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Currency\" = 'CZK'\n  AND CAST(T2.\"Date\" AS INTEGER) BETWEEN 201101 AND 201112\nGROUP BY T1.\"CustomerID\"\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT y.CustomerID, SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Currency = 'CZK' AND y.Date LIKE '2011%'\nGROUP BY y.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "normalized": "SELECT y.CustomerID,\n       SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Currency = 'CZK'\n  AND y.Date LIKE '2011%'\nGROUP BY y.CustomerID\nORDER BY TotalConsumption DESC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(*) FROM ( SELECT T2.\"CustomerID\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Segment\" = 'KAM' AND SUBSTRING(T2.\"Date\", 1, 4) = '2012' GROUP BY T2.\"CustomerID\" HAVING SUM(T2.\"Consumption\") < 30000 ) AS t1",
            "normalized": "SELECT COUNT(*)\nFROM\n  (SELECT T2.\"CustomerID\"\n   FROM customers AS T1\n   INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\n   WHERE T1.\"Segment\" = 'KAM'\n     AND SUBSTRING(T2.\"Date\", 1, 4) = '2012'\n   GROUP BY T2.\"CustomerID\"\n   HAVING SUM(T2.\"Consumption\") < 30000) AS t1"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT y.CustomerID) AS CustomerCount\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'KAM' \n  AND y.Date LIKE '2012%' \n  AND y.Consumption < 30000;",
            "normalized": "SELECT COUNT(DISTINCT y.CustomerID) AS CustomerCount\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'KAM'\n  AND y.Date LIKE '2012%'\n  AND y.Consumption < 30000;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN T1.\"Currency\" = 'CZK' THEN T2.\"Consumption\" ELSE 0 END) - SUM(CASE WHEN T1.\"Currency\" = 'EUR' THEN T2.\"Consumption\" ELSE 0 END) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE SUBSTR(T2.\"Date\", 1, 4) = '2012'",
            "normalized": "SELECT SUM(CASE\n               WHEN T1.\"Currency\" = 'CZK' THEN T2.\"Consumption\"\n               ELSE 0\n           END) - SUM(CASE\n                          WHEN T1.\"Currency\" = 'EUR' THEN T2.\"Consumption\"\n                          ELSE 0\n                      END)\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE SUBSTR(T2.\"Date\", 1, 4) = '2012'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    c.Currency, \n    SUM(y.Consumption) AS TotalConsumption\nFROM \n    public.yearmonth y\nJOIN \n    public.customers c ON y.CustomerID = c.CustomerID\nWHERE \n    y.Date LIKE '2012%'\nGROUP BY \n    c.Currency;",
            "normalized": "SELECT c.Currency,\n       SUM(y.Consumption) AS TotalConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.CustomerID = c.CustomerID\nWHERE y.Date LIKE '2012%'\nGROUP BY c.Currency;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which year recorded the most gas use paid in EUR?",
        "reference_sql_query": {
            "raw": "SELECT SUBSTRING(T2.\"Date\", 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Currency\" = 'EUR' GROUP BY SUBSTRING(T2.\"Date\", 1, 4) ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT SUBSTRING(T2.\"Date\", 1, 4)\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Currency\" = 'EUR'\nGROUP BY SUBSTRING(T2.\"Date\", 1, 4)\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the currency used in transactions or any indication of whether the amounts in the \"transactions_1k\" table are in EUR. Additional context or a specific column indicating the currency is required to answer this question.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the currency used IN transactions\nOR ANY indication OF whether the amounts IN the \"transactions_1k\" TABLE ARE IN EUR. Additional context\nOR a SPECIFIC COLUMN indicating the currency IS required TO answer this question."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which segment had the least consumption?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Segment\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" GROUP BY T1.\"Segment\" ORDER BY SUM(T2.\"Consumption\") ASC LIMIT 1",
            "normalized": "SELECT T1.\"Segment\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nGROUP BY T1.\"Segment\"\nORDER BY SUM(T2.\"Consumption\") ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.Segment, SUM(y.Consumption) AS TotalConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.CustomerID = c.CustomerID\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;",
            "normalized": "SELECT c.Segment,\n       SUM(y.Consumption) AS TotalConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.CustomerID = c.CustomerID\nGROUP BY c.Segment\nORDER BY TotalConsumption ASC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which year recorded the most consumption of gas paid in CZK?",
        "reference_sql_query": {
            "raw": "SELECT SUBSTR(T2.\"Date\", 1, 4) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Currency\" = 'CZK' GROUP BY SUBSTR(T2.\"Date\", 1, 4) ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT SUBSTR(T2.\"Date\", 1, 4)\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Currency\" = 'CZK'\nGROUP BY SUBSTR(T2.\"Date\", 1, 4)\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query. There is no information regarding the currency in which the gas was paid (e.g., CZK) in the available tables. Additionally, the context does not specify how to associate transactions with currency types.",
            "normalized": "The provided context IS insufficient TO generate the SQL query. There IS NO information regarding the currency IN which the gas was paid (e.g., CZK) IN the available tables. Additionally,\n                                                                                                                                                                      the context does NOT specify how TO associate transactions WITH currency types."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What was the gas consumption peak month for SME customers in 2013?",
        "reference_sql_query": {
            "raw": "SELECT SUBSTR(T2.\"Date\", 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE SUBSTR(T2.\"Date\", 1, 4) = '2013' AND T1.\"Segment\" = 'SME' GROUP BY SUBSTR(T2.\"Date\", 5, 2) ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT SUBSTR(T2.\"Date\", 5, 2)\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE SUBSTR(T2.\"Date\", 1, 4) = '2013'\n  AND T1.\"Segment\" = 'SME'\nGROUP BY SUBSTR(T2.\"Date\", 5, 2)\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT SUBSTRING(y.\"Date\", 1, 7) AS YearMonth, SUM(y.\"Consumption\") AS TotalConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'SME' AND SUBSTRING(y.\"Date\", 1, 4) = '2013'\nGROUP BY YearMonth\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "normalized": "SELECT SUBSTRING(y.\"Date\", 1, 7) AS YearMonth,\n       SUM(y.\"Consumption\") AS TotalConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'SME'\n  AND SUBSTRING(y.\"Date\", 1, 4) = '2013'\nGROUP BY YearMonth\nORDER BY TotalConsumption DESC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T1.\"Segment\" = 'SME' THEN T2.\"Consumption\" ELSE 0 END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") - CAST(SUM(CASE WHEN T1.\"Segment\" = 'LAM' THEN T2.\"Consumption\" ELSE 0 END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") , CAST(SUM(CASE WHEN T1.\"Segment\" = 'LAM' THEN T2.\"Consumption\" ELSE 0 END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") - CAST(SUM(CASE WHEN T1.\"Segment\" = 'KAM' THEN T2.\"Consumption\" ELSE 0 END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") , CAST(SUM(CASE WHEN T1.\"Segment\" = 'KAM' THEN T2.\"Consumption\" ELSE 0 END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") - CAST(SUM(CASE WHEN T1.\"Segment\" = 'SME' THEN T2.\"Consumption\" ELSE 0 END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Currency\" = 'CZK' AND T2.\"Consumption\" = ( SELECT MIN(\"Consumption\") FROM yearmonth ) AND CAST(T2.\"Date\" AS INTEGER) BETWEEN 201301 AND 201312",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T1.\"Segment\" = 'SME' THEN T2.\"Consumption\"\n                    ELSE 0\n                END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") - CAST(SUM(CASE\n                                                                                  WHEN T1.\"Segment\" = 'LAM' THEN T2.\"Consumption\"\n                                                                                  ELSE 0\n                                                                              END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\"),\n       CAST(SUM(CASE\n                    WHEN T1.\"Segment\" = 'LAM' THEN T2.\"Consumption\"\n                    ELSE 0\n                END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") - CAST(SUM(CASE\n                                                                                  WHEN T1.\"Segment\" = 'KAM' THEN T2.\"Consumption\"\n                                                                                  ELSE 0\n                                                                              END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\"),\n       CAST(SUM(CASE\n                    WHEN T1.\"Segment\" = 'KAM' THEN T2.\"Consumption\"\n                    ELSE 0\n                END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\") - CAST(SUM(CASE\n                                                                                  WHEN T1.\"Segment\" = 'SME' THEN T2.\"Consumption\"\n                                                                                  ELSE 0\n                                                                              END) AS DOUBLE PRECISION) / COUNT(T1.\"CustomerID\")\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Currency\" = 'CZK'\n  AND T2.\"Consumption\" =\n    (SELECT MIN(\"Consumption\")\n     FROM yearmonth)\n  AND CAST(T2.\"Date\" AS INTEGER) BETWEEN 201301 AND 201312"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because the necessary information about the currency used for consumption payments, the segmentation of customers, and the specific consumption data for the year 2013 is not available in the given tables. The context does not include any details about currency conversion or consumption payments in CZK, nor does it specify how to identify the least amount of consumption.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because the necessary information about the currency used\nFOR consumption payments,\n    the segmentation OF customers,\nAND the SPECIFIC consumption DATA\nFOR the YEAR 2013 IS NOT available IN the given tables. The context does NOT INCLUDE ANY details about currency CONVERSION\nOR consumption payments IN CZK,\n                           nor does it specify how TO identify the least amount OF consumption."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which of the three segments\u00e2\u20ac\u201dSME, LAM and KAM\u00e2\u20ac\u201dhas the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "reference_sql_query": {
            "raw": "SELECT CAST((SUM(CASE WHEN T1.\"Segment\" = 'SME' AND T2.\"Date\"::TEXT LIKE '2013%' THEN T2.\"Consumption\" ELSE 0 END) - SUM(CASE WHEN T1.\"Segment\" = 'SME' AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\" ELSE 0 END)) AS FLOAT) * 100 / SUM(CASE WHEN T1.\"Segment\" = 'SME' AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\" ELSE 0 END), CAST(SUM(CASE WHEN T1.\"Segment\" = 'LAM' AND T2.\"Date\"::TEXT LIKE '2013%' THEN T2.\"Consumption\" ELSE 0 END) - SUM(CASE WHEN T1.\"Segment\" = 'LAM' AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\" ELSE 0 END) AS FLOAT) * 100 / SUM(CASE WHEN T1.\"Segment\" = 'LAM' AND T2.\"Date\"::TEXT LIKE'2012%' THEN T2.\"Consumption\" ELSE 0 END) , CAST(SUM(CASE WHEN T1.\"Segment\" = 'KAM' AND T2.\"Date\"::TEXT LIKE '2013%' THEN T2.\"Consumption\" ELSE 0 END) - SUM(CASE WHEN T1.\"Segment\" = 'KAM' AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\" ELSE 0 END) AS FLOAT) * 100 / SUM(CASE WHEN T1.\"Segment\" = 'KAM' AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\" ELSE 0 END) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"",
            "normalized": "SELECT CAST((SUM(CASE\n                     WHEN T1.\"Segment\" = 'SME'\n                          AND T2.\"Date\"::TEXT LIKE '2013%' THEN T2.\"Consumption\"\n                     ELSE 0\n                 END) - SUM(CASE\n                                WHEN T1.\"Segment\" = 'SME'\n                                     AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\"\n                                ELSE 0\n                            END)) AS FLOAT) * 100 / SUM(CASE\n                                                            WHEN T1.\"Segment\" = 'SME'\n                                                                 AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\"\n                                                            ELSE 0\n                                                        END),\n       CAST(SUM(CASE\n                    WHEN T1.\"Segment\" = 'LAM'\n                         AND T2.\"Date\"::TEXT LIKE '2013%' THEN T2.\"Consumption\"\n                    ELSE 0\n                END) - SUM(CASE\n                               WHEN T1.\"Segment\" = 'LAM'\n                                    AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\"\n                               ELSE 0\n                           END) AS FLOAT) * 100 / SUM(CASE\n                                                          WHEN T1.\"Segment\" = 'LAM'\n                                                               AND T2.\"Date\"::TEXT LIKE'2012%' THEN T2.\"Consumption\"\n                                                          ELSE 0\n                                                      END),\n       CAST(SUM(CASE\n                    WHEN T1.\"Segment\" = 'KAM'\n                         AND T2.\"Date\"::TEXT LIKE '2013%' THEN T2.\"Consumption\"\n                    ELSE 0\n                END) - SUM(CASE\n                               WHEN T1.\"Segment\" = 'KAM'\n                                    AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\"\n                               ELSE 0\n                           END) AS FLOAT) * 100 / SUM(CASE\n                                                          WHEN T1.\"Segment\" = 'KAM'\n                                                               AND T2.\"Date\"::TEXT LIKE '2012%' THEN T2.\"Consumption\"\n                                                          ELSE 0\n                                                      END)\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\""
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information about the \"Year\" or segment types such as \"SME, LAM, and KAM\" in the tables. Additionally, there's no indication of currency in the \"yearmonth\" table to filter payments made in EUR. Therefore, I cannot generate the query based on the given context.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information about the \"Year\"\nOR SEGMENT types such AS \"SME, LAM, and KAM\" IN the tables. Additionally,\n                                                there's NO indication OF currency IN the \"yearmonth\" TABLE TO filter payments made IN EUR. Therefore,\n                                                                                                                                      I cannot generate the query based ON the given context."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How much did customer 6 consume in total between August and November 2013?",
        "reference_sql_query": {
            "raw": "SELECT SUM(\"Consumption\") FROM yearmonth WHERE \"CustomerID\" = 6 AND \"Date\" BETWEEN '201308' AND '201311'",
            "normalized": "SELECT SUM(\"Consumption\")\nFROM yearmonth\nWHERE \"CustomerID\" = 6\n  AND \"Date\" BETWEEN '201308' AND '201311'"
        },
        "generated_sql_query": {
            "raw": "SELECT SUM(\"Consumption\") AS total_consumption\nFROM public.yearmonth\nWHERE \"CustomerID\" = 6 \n  AND \"Date\" BETWEEN '2013-08' AND '2013-11'",
            "normalized": "SELECT SUM(\"Consumption\") AS total_consumption\nFROM public.yearmonth\nWHERE \"CustomerID\" = 6\n  AND \"Date\" BETWEEN '2013-08' AND '2013-11'"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN \"Country\" = 'CZE' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"Country\" = 'SVK' THEN 1 ELSE 0 END) FROM gasstations WHERE \"Segment\" = 'Discount'",
            "normalized": "SELECT SUM(CASE\n               WHEN \"Country\" = 'CZE' THEN 1\n               ELSE 0\n           END) - SUM(CASE\n                          WHEN \"Country\" = 'SVK' THEN 1\n                          ELSE 0\n                      END)\nFROM gasstations\nWHERE \"Segment\" = 'Discount'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    c1.name AS country, \n    COUNT(gs.GasStationID) AS discount_gas_stations\nFROM \n    public.gasstations gs\nJOIN \n    public.\"Country\" c1 ON gs.Country = c1.name\nWHERE \n    gs.Segment = 'discount'\n    AND (c1.name = 'Czech Republic' OR c1.name = 'Slovakia')\nGROUP BY \n    c1.name;",
            "normalized": "SELECT c1.name AS country,\n       COUNT(gs.GasStationID) AS discount_gas_stations\nFROM public.gasstations gs\nJOIN public.\"Country\" c1 ON gs.Country = c1.name\nWHERE gs.Segment = 'discount'\n  AND (c1.name = 'Czech Republic'\n       OR c1.name = 'Slovakia')\nGROUP BY c1.name;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How much more was customer 7 consuming in April 2013 than customer 5?",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN \"CustomerID\" = 7 THEN \"Consumption\" ELSE 0 END) - SUM(CASE WHEN \"CustomerID\" = 5 THEN \"Consumption\" ELSE 0 END) FROM yearmonth WHERE \"Date\" = '201304'",
            "normalized": "SELECT SUM(CASE\n               WHEN \"CustomerID\" = 7 THEN \"Consumption\"\n               ELSE 0\n           END) - SUM(CASE\n                          WHEN \"CustomerID\" = 5 THEN \"Consumption\"\n                          ELSE 0\n                      END)\nFROM yearmonth\nWHERE \"Date\" = '201304'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (SELECT SUM(Consumption) FROM public.yearmonth WHERE CustomerID = 7 AND Date LIKE '2013-04%') -\n    (SELECT SUM(Consumption) FROM public.yearmonth WHERE CustomerID = 5 AND Date LIKE '2013-04%') AS Consumption_Difference",
            "normalized": "SELECT\n  (SELECT SUM(Consumption)\n   FROM public.yearmonth\n   WHERE CustomerID = 7\n     AND Date LIKE '2013-04%') -\n  (SELECT SUM(Consumption)\n   FROM public.yearmonth\n   WHERE CustomerID = 5\n     AND Date LIKE '2013-04%') AS Consumption_Difference"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
        "reference_sql_query": {
            "raw": "SELECT SUM(CASE WHEN \"Currency\" = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN \"Currency\" = 'EUR' THEN 1 ELSE 0 END) FROM customers WHERE \"Segment\" = 'SME'",
            "normalized": "SELECT SUM(CASE\n               WHEN \"Currency\" = 'CZK' THEN 1\n               ELSE 0\n           END) - SUM(CASE\n                          WHEN \"Currency\" = 'EUR' THEN 1\n                          ELSE 0\n                      END)\nFROM customers\nWHERE \"Segment\" = 'SME'"
        },
        "generated_sql_query": {
            "raw": "The provided context does not contain information on the currency used by SMEs (Small and Medium Enterprises) for payments. The \"customers\" table contains a \"Currency\" column, but there is no information linking SMEs specifically to their payment currencies. Therefore, the query cannot be generated with the given context.",
            "normalized": "The provided context does NOT contain information ON the currency used BY SMEs (Small\n                                                                                AND Medium Enterprises)\nFOR payments. The \"customers\" TABLE CONTAINS a \"Currency\" COLUMN,\n                                                          but there IS NO information linking SMEs specifically TO their payment currencies. Therefore,\n                                                                                                                                 the query cannot be GENERATED WITH the given context."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which LAM customer used the Euro as their currency and had the highest consumption in October 2013?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"CustomerID\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Segment\" = 'LAM' AND T2.\"Date\" = '201310' AND T1.\"Currency\" = 'EUR' GROUP BY T1.\"CustomerID\" ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT T1.\"CustomerID\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Segment\" = 'LAM'\n  AND T2.\"Date\" = '201310'\n  AND T1.\"Currency\" = 'EUR'\nGROUP BY T1.\"CustomerID\"\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT y.CustomerID, MAX(y.Consumption) AS MaxConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'LAM'\nAND c.Currency = 'Euro'\nAND y.Date BETWEEN '2013-10-01' AND '2013-10-31'\nGROUP BY y.CustomerID\nORDER BY MaxConsumption DESC\nLIMIT 1;",
            "normalized": "SELECT y.CustomerID,\n       MAX(y.Consumption) AS MaxConsumption\nFROM yearmonth y\nJOIN customers c ON y.CustomerID = c.CustomerID\nWHERE c.Segment = 'LAM'\n  AND c.Currency = 'Euro'\n  AND y.Date BETWEEN '2013-10-01' AND '2013-10-31'\nGROUP BY y.CustomerID\nORDER BY MaxConsumption DESC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Who among KAM's customers consumed the most? How much did it consume?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"CustomerID\", SUM(T2.\"Consumption\") FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Segment\" = 'KAM' GROUP BY T2.\"CustomerID\" ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT T2.\"CustomerID\",\n       SUM(T2.\"Consumption\")\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Segment\" = 'KAM'\nGROUP BY T2.\"CustomerID\"\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information linking a specific customer or entity named \"KAM\" to the tables, and there is no direct relationship between customers and the \"yearmonth\" table where consumption is recorded.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information linking a SPECIFIC customer\nOR entity named \"KAM\" TO the TABLES,\nAND there IS NO direct relationship BETWEEN customers AND the \"yearmonth\" TABLE\nWHERE consumption IS recorded."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How much did the KAM customers consume in total in May 2013?",
        "reference_sql_query": {
            "raw": "SELECT SUM(T2.\"Consumption\") FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T2.\"Date\" = '201305' AND T1.\"Segment\" = 'KAM'",
            "normalized": "SELECT SUM(T2.\"Consumption\")\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T2.\"Date\" = '201305'\n  AND T1.\"Segment\" = 'KAM'"
        },
        "generated_sql_query": {
            "raw": "SELECT SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'KAM' AND y.\"Date\" LIKE '2013-05%'",
            "normalized": "SELECT SUM(y.Consumption) AS TotalConsumption\nFROM yearmonth y\nJOIN customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'KAM'\n  AND y.\"Date\" LIKE '2013-05%'"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN T2.\"Consumption\" > 46.73 THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(T1.\"CustomerID\") FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Segment\" = 'LAM'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN T2.\"Consumption\" > 46.73 THEN 1\n                    ELSE 0\n                END) AS FLOAT) * 100 / COUNT(T1.\"CustomerID\")\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Segment\" = 'LAM'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM public.yearmonth ym JOIN public.customers c ON ym.\"CustomerID\" = c.\"CustomerID\" WHERE c.\"Segment\" = 'LAM')) AS percentage\nFROM \n    public.yearmonth ym\nJOIN \n    public.customers c ON ym.\"CustomerID\" = c.\"CustomerID\"\nWHERE \n    c.\"Segment\" = 'LAM' AND ym.\"Consumption\" > 46.73;",
            "normalized": "SELECT (COUNT(*) * 100.0 /\n          (SELECT COUNT(*)\n           FROM public.yearmonth ym\n           JOIN public.customers c ON ym.\"CustomerID\" = c.\"CustomerID\"\n           WHERE c.\"Segment\" = 'LAM')) AS percentage\nFROM public.yearmonth ym\nJOIN public.customers c ON ym.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'LAM'\n  AND ym.\"Consumption\" > 46.73;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
        "reference_sql_query": {
            "raw": "SELECT \"Country\" , ( SELECT COUNT(\"GasStationID\") FROM gasstations WHERE \"Segment\" = 'Value for money' ) FROM gasstations WHERE \"Segment\" = 'Value for money' GROUP BY \"Country\" ORDER BY COUNT(\"GasStationID\") DESC LIMIT 1",
            "normalized": "SELECT \"Country\" ,\n  (SELECT COUNT(\"GasStationID\")\n   FROM gasstations\n   WHERE \"Segment\" = 'Value for money')\nFROM gasstations\nWHERE \"Segment\" = 'Value for money'\nGROUP BY \"Country\"\nORDER BY COUNT(\"GasStationID\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT g.Country, COUNT(*) AS total_value_for_money_gas_stations\nFROM public.gasstations g\nWHERE g.Segment = 'value for money'\nGROUP BY g.Country;",
            "normalized": "SELECT g.Country,\n       COUNT(*) AS total_value_for_money_gas_stations\nFROM public.gasstations g\nWHERE g.Segment = 'value for money'\nGROUP BY g.Country;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What percentage of KAM customers pay in euros?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Currency\" = 'EUR' THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(\"CustomerID\") FROM customers WHERE \"Segment\" = 'KAM'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Currency\" = 'EUR' THEN 1\n                    ELSE 0\n                END) AS FLOAT) * 100 / COUNT(\"CustomerID\")\nFROM customers\nWHERE \"Segment\" = 'KAM'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no information available about what \"KAM customers\" refers to, nor is there any connection between customer segments and the currency they pay in within the given tables.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO information available about what \"KAM customers\" refers TO,\n                                                                                                                                           nor IS there ANY CONNECTION BETWEEN customer segments AND the currency they pay IN within the given tables."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "In February 2012, what percentage of customers consumed more than 528.3?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Consumption\" > 528.3 THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(\"CustomerID\") FROM yearmonth WHERE \"Date\" = '201202'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Consumption\" > 528.3 THEN 1\n                    ELSE 0\n                END) AS FLOAT) * 100 / COUNT(\"CustomerID\")\nFROM yearmonth\nWHERE \"Date\" = '201202'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(CASE WHEN \"Consumption\" > 528.3 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_consumed_more_than_528_3\nFROM \n    public.yearmonth\nWHERE \n    \"Date\" LIKE '2012-02%';",
            "normalized": "SELECT (COUNT(CASE\n                  WHEN \"Consumption\" > 528.3 THEN 1\n              END) * 100.0 / COUNT(*)) AS percentage_consumed_more_than_528_3\nFROM public.yearmonth\nWHERE \"Date\" LIKE '2012-02%';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What percentage of Slovakian gas stations are premium?",
        "reference_sql_query": {
            "raw": "SELECT CAST(SUM(CASE WHEN \"Segment\" = 'Premium' THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(\"GasStationID\") FROM gasstations WHERE \"Country\" = 'SVK'",
            "normalized": "SELECT CAST(SUM(CASE\n                    WHEN \"Segment\" = 'Premium' THEN 1\n                    ELSE 0\n                END) AS FLOAT) * 100 / COUNT(\"GasStationID\")\nFROM gasstations\nWHERE \"Country\" = 'SVK'"
        },
        "generated_sql_query": {
            "raw": "SELECT \n    (COUNT(CASE WHEN Segment = 'Premium' THEN 1 END)::DECIMAL / COUNT(*)) * 100 AS percentage_premium\nFROM \n    public.gasstations\nWHERE \n    Country = 'Slovakian';",
            "normalized": "SELECT (COUNT(CASE\n                  WHEN SEGMENT = 'Premium' THEN 1\n              END)::DECIMAL / COUNT(*)) * 100 AS percentage_premium\nFROM public.gasstations\nWHERE Country = 'Slovakian';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which client ID consumed the most in September 2013?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"CustomerID\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T2.\"Date\" = '201309' GROUP BY T1.\"CustomerID\" ORDER BY SUM(T2.\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT T1.\"CustomerID\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T2.\"Date\" = '201309'\nGROUP BY T1.\"CustomerID\"\nORDER BY SUM(T2.\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT \"CustomerID\", SUM(\"Consumption\") as TotalConsumption\nFROM public.yearmonth\nWHERE \"Date\" LIKE '2013-09%'\nGROUP BY \"CustomerID\"\nORDER BY TotalConsumption DESC\nLIMIT 1;",
            "normalized": "SELECT \"CustomerID\",\n       SUM(\"Consumption\") AS TotalConsumption\nFROM public.yearmonth\nWHERE \"Date\" LIKE '2013-09%'\nGROUP BY \"CustomerID\"\nORDER BY TotalConsumption DESC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which client segment consumed the least in September 2013?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"Segment\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T2.\"Date\" = '201309' GROUP BY T1.\"CustomerID\", T1.\"Segment\" ORDER BY SUM(T2.\"Consumption\") ASC LIMIT 1",
            "normalized": "SELECT T1.\"Segment\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T2.\"Date\" = '201309'\nGROUP BY T1.\"CustomerID\",\n         T1.\"Segment\"\nORDER BY SUM(T2.\"Consumption\") ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.\"Segment\", SUM(y.\"Consumption\") AS total_consumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE y.\"Date\" LIKE '2013-09%'\nGROUP BY c.\"Segment\"\nORDER BY total_consumption ASC\nLIMIT 1;",
            "normalized": "SELECT c.\"Segment\",\n       SUM(y.\"Consumption\") AS total_consumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE y.\"Date\" LIKE '2013-09%'\nGROUP BY c.\"Segment\"\nORDER BY total_consumption ASC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which SME customer consumed the least in June 2012?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"CustomerID\" FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T2.\"Date\" = '201206' AND T1.\"Segment\" = 'SME' GROUP BY T1.\"CustomerID\" ORDER BY SUM(T2.\"Consumption\") ASC LIMIT 1",
            "normalized": "SELECT T1.\"CustomerID\"\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T2.\"Date\" = '201206'\n  AND T1.\"Segment\" = 'SME'\nGROUP BY T1.\"CustomerID\"\nORDER BY SUM(T2.\"Consumption\") ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.\"CustomerID\", MIN(y.\"Consumption\") AS MinConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'SME' AND y.\"Date\" LIKE '2012-06%'\nGROUP BY c.\"CustomerID\"\nORDER BY MinConsumption ASC\nLIMIT 1;",
            "normalized": "SELECT c.\"CustomerID\",\n       MIN(y.\"Consumption\") AS MinConsumption\nFROM public.yearmonth y\nJOIN public.customers c ON y.\"CustomerID\" = c.\"CustomerID\"\nWHERE c.\"Segment\" = 'SME'\n  AND y.\"Date\" LIKE '2012-06%'\nGROUP BY c.\"CustomerID\"\nORDER BY MinConsumption ASC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What is the highest monthly consumption in the year 2012?",
        "reference_sql_query": {
            "raw": "SELECT SUM(\"Consumption\") FROM yearmonth WHERE SUBSTR(\"Date\", 1, 4) = '2012' GROUP BY SUBSTR(\"Date\", 5, 2) ORDER BY SUM(\"Consumption\") DESC LIMIT 1",
            "normalized": "SELECT SUM(\"Consumption\")\nFROM yearmonth\nWHERE SUBSTR(\"Date\", 1, 4) = '2012'\nGROUP BY SUBSTR(\"Date\", 5, 2)\nORDER BY SUM(\"Consumption\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(Consumption) AS highest_monthly_consumption\nFROM public.yearmonth\nWHERE Date LIKE '2012%';",
            "normalized": "SELECT MAX(Consumption) AS highest_monthly_consumption\nFROM public.yearmonth\nWHERE Date LIKE '2012%';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What is the biggest monthly consumption of the customers who use euro as their currency?",
        "reference_sql_query": {
            "raw": "SELECT SUM(T2.\"Consumption\") / 12 AS MonthlyConsumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Currency\" = 'EUR' GROUP BY T1.\"CustomerID\" ORDER BY MonthlyConsumption DESC LIMIT 1",
            "normalized": "SELECT SUM(T2.\"Consumption\") / 12 AS MonthlyConsumption\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Currency\" = 'EUR'\nGROUP BY T1.\"CustomerID\"\nORDER BY MonthlyConsumption DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT MAX(ym.Consumption) AS BiggestMonthlyConsumption\nFROM public.yearmonth ym\nJOIN public.customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Currency = 'euro';",
            "normalized": "SELECT MAX(ym.Consumption) AS BiggestMonthlyConsumption\nFROM public.yearmonth ym\nJOIN public.customers c ON ym.CustomerID = c.CustomerID\nWHERE c.Currency = 'euro';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Please list the product description of the products consumed in September, 2013.",
        "reference_sql_query": {
            "raw": "SELECT T3.\"Description\" FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" INNER JOIN products AS T3 ON T1.\"ProductID\" = T3.\"ProductID\" WHERE T2.\"Date\" = '201309'",
            "normalized": "SELECT T3.\"Description\"\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nINNER JOIN products AS T3 ON T1.\"ProductID\" = T3.\"ProductID\"\nWHERE T2.\"Date\" = '201309'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT p.Description\nFROM public.transactions_1k t\nJOIN public.products p ON t.ProductID = p.ProductID\nWHERE t.Date >= '2013-09-01' AND t.Date <= '2013-09-30';",
            "normalized": "SELECT DISTINCT p.Description\nFROM public.transactions_1k t\nJOIN public.products p ON t.ProductID = p.ProductID\nWHERE t.Date >= '2013-09-01'\n  AND t.Date <= '2013-09-30';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T2.\"Country\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" INNER JOIN yearmonth AS T3 ON T1.\"CustomerID\" = T3.\"CustomerID\" WHERE T3.\"Date\" = '201306'",
            "normalized": "SELECT DISTINCT T2.\"Country\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nINNER JOIN yearmonth AS T3 ON T1.\"CustomerID\" = T3.\"CustomerID\"\nWHERE T3.\"Date\" = '201306'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT g.Country\nFROM public.gasstations g\nJOIN public.transactions_1k t ON g.GasStationID = t.GasStationID\nWHERE t.Date BETWEEN '2013-06-01' AND '2013-06-30';",
            "normalized": "SELECT DISTINCT g.Country\nFROM public.gasstations g\nJOIN public.transactions_1k t ON g.GasStationID = t.GasStationID\nWHERE t.Date BETWEEN '2013-06-01' AND '2013-06-30';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Please list the chains of the gas stations with transactions in euro.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T3.\"ChainID\" FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" INNER JOIN gasstations AS T3 ON T1.\"GasStationID\" = T3.\"GasStationID\" WHERE T2.\"Currency\" = 'EUR'",
            "normalized": "SELECT DISTINCT T3.\"ChainID\"\nFROM transactions_1k AS T1\nINNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nINNER JOIN gasstations AS T3 ON T1.\"GasStationID\" = T3.\"GasStationID\"\nWHERE T2.\"Currency\" = 'EUR'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT gasstations.ChainID\nFROM gasstations\nJOIN transactions_1k ON gasstations.GasStationID = transactions_1k.GasStationID\nWHERE transactions_1k.Price = 'euro';",
            "normalized": "SELECT DISTINCT gasstations.ChainID\nFROM gasstations\nJOIN transactions_1k ON gasstations.GasStationID = transactions_1k.GasStationID\nWHERE transactions_1k.Price = 'euro';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Please list the product description of the products bought in transactions in euro.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"ProductID\", T3.\"Description\" FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" INNER JOIN products AS T3 ON T1.\"ProductID\" = T3.\"ProductID\" WHERE T2.\"Currency\" = 'EUR'",
            "normalized": "SELECT DISTINCT T1.\"ProductID\",\n                T3.\"Description\"\nFROM transactions_1k AS T1\nINNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nINNER JOIN products AS T3 ON T1.\"ProductID\" = T3.\"ProductID\"\nWHERE T2.\"Currency\" = 'EUR'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT p.Description\nFROM public.transactions_1k t\nJOIN public.products p ON t.ProductID = p.ProductID\nJOIN public.customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'Euro';",
            "normalized": "SELECT DISTINCT p.Description\nFROM public.transactions_1k t\nJOIN public.products p ON t.ProductID = p.ProductID\nJOIN public.customers c ON t.CustomerID = c.CustomerID\nWHERE c.Currency = 'Euro';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What is the average total price of the transactions taken place in January, 2012?",
        "reference_sql_query": {
            "raw": "SELECT AVG(\"Amount\") FROM transactions_1k WHERE \"Date\"::TEXT LIKE '2012-01%'",
            "normalized": "SELECT AVG(\"Amount\")\nFROM transactions_1k\nWHERE \"Date\"::TEXT LIKE '2012-01%'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(Price) AS AveragePrice\nFROM public.transactions_1k\nWHERE Date BETWEEN '2012-01-01' AND '2012-01-31';",
            "normalized": "SELECT AVG(Price) AS AveragePrice\nFROM public.transactions_1k\nWHERE Date BETWEEN '2012-01-01' AND '2012-01-31';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T2.\"Currency\" = 'EUR' AND T1.\"Consumption\" > 1000.00",
            "normalized": "SELECT COUNT(*)\nFROM yearmonth AS T1\nINNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T2.\"Currency\" = 'EUR'\n  AND T1.\"Consumption\" > 1000.00"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(DISTINCT y.CustomerID) AS CustomerCount\nFROM public.yearmonth y\nJOIN public.customers c ON y.CustomerID = c.CustomerID\nWHERE c.Currency = 'euro' AND y.Consumption > 1000;",
            "normalized": "SELECT COUNT(DISTINCT y.CustomerID) AS CustomerCount\nFROM public.yearmonth y\nJOIN public.customers c ON y.CustomerID = c.CustomerID\nWHERE c.Currency = 'euro'\n  AND y.Consumption > 1000;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T3.\"Description\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" INNER JOIN products AS T3 ON T1.\"ProductID\" = T3.\"ProductID\" WHERE T2.\"Country\" = 'CZE'",
            "normalized": "SELECT DISTINCT T3.\"Description\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nINNER JOIN products AS T3 ON T1.\"ProductID\" = T3.\"ProductID\"\nWHERE T2.\"Country\" = 'CZE'"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT p.Description\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nJOIN public.products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'Czech Republic';",
            "normalized": "SELECT DISTINCT p.Description\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nJOIN public.products p ON t.ProductID = p.ProductID\nWHERE g.Country = 'Czech Republic';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T1.\"Time\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T2.\"ChainID\" = 11",
            "normalized": "SELECT DISTINCT T1.\"Time\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T2.\"ChainID\" = 11"
        },
        "generated_sql_query": {
            "raw": "SELECT DISTINCT t.Time\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.ChainID = 11;",
            "normalized": "SELECT DISTINCT t.Time\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.ChainID = 11;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How many transactions taken place in the gas station in the Czech Republic are with a price of over 1000?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"TransactionID\") FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T2.\"Country\" = 'CZE' AND T1.\"Price\" > 1000",
            "normalized": "SELECT COUNT(T1.\"TransactionID\")\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T2.\"Country\" = 'CZE'\n  AND T1.\"Price\" > 1000"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*)\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'Czech Republic' AND t.Price > 1000;",
            "normalized": "SELECT COUNT(*)\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'Czech Republic'\n  AND t.Price > 1000;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"TransactionID\") FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T2.\"Country\" = 'CZE' AND EXTRACT(YEAR FROM T1.\"Date\") >= '2012'",
            "normalized": "SELECT COUNT(T1.\"TransactionID\")\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T2.\"Country\" = 'CZE'\n  AND EXTRACT(YEAR\n              FROM T1.\"Date\") >= '2012'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'Czech Republic' AND t.Date > '2012-01-01';",
            "normalized": "SELECT COUNT(*)\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'Czech Republic'\n  AND t.Date > '2012-01-01';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T1.\"Price\") FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T2.\"Country\" = 'CZE'",
            "normalized": "SELECT AVG(T1.\"Price\")\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T2.\"Country\" = 'CZE'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(Amount * Price) AS average_total_price\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'Czech Republic';",
            "normalized": "SELECT AVG(Amount * Price) AS average_total_price\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE g.Country = 'Czech Republic';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
        "reference_sql_query": {
            "raw": "SELECT AVG(T1.\"Price\") FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" INNER JOIN customers AS T3 ON T1.\"CustomerID\" = T3.\"CustomerID\" WHERE T3.\"Currency\" = 'EUR'",
            "normalized": "SELECT AVG(T1.\"Price\")\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nINNER JOIN customers AS T3 ON T1.\"CustomerID\" = T3.\"CustomerID\"\nWHERE T3.\"Currency\" = 'EUR'"
        },
        "generated_sql_query": {
            "raw": "SELECT AVG(t.TotalPrice) AS AverageTotalPrice\nFROM (\n    SELECT c.CustomerID, SUM(t.Price) AS TotalPrice\n    FROM public.customers c\n    JOIN public.transactions_1k t ON c.CustomerID = t.CustomerID\n    WHERE c.Currency = 'euro'\n    GROUP BY c.CustomerID\n) AS t;",
            "normalized": "SELECT AVG(t.TotalPrice) AS AverageTotalPrice\nFROM\n  (SELECT c.CustomerID,\n          SUM(t.Price) AS TotalPrice\n   FROM public.customers c\n   JOIN public.transactions_1k t ON c.CustomerID = t.CustomerID\n   WHERE c.Currency = 'euro'\n   GROUP BY c.CustomerID) AS t;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which customer paid the most in 2012/8/25?",
        "reference_sql_query": {
            "raw": "SELECT \"CustomerID\" FROM transactions_1k WHERE \"Date\" = '2012-08-25' GROUP BY \"CustomerID\" ORDER BY SUM(\"Price\") DESC LIMIT 1",
            "normalized": "SELECT \"CustomerID\"\nFROM transactions_1k\nWHERE \"Date\" = '2012-08-25'\nGROUP BY \"CustomerID\"\nORDER BY SUM(\"Price\") DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT t.CustomerID, SUM(t.Amount * t.Price) AS TotalSpent\nFROM public.transactions_1k t\nWHERE t.Date = '2012-08-25'\nGROUP BY t.CustomerID\nORDER BY TotalSpent DESC\nLIMIT 1;",
            "normalized": "SELECT t.CustomerID,\n       SUM(t.Amount * t.Price) AS TotalSpent\nFROM public.transactions_1k t\nWHERE t.Date = '2012-08-25'\nGROUP BY t.CustomerID\nORDER BY TotalSpent DESC\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Country\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T1.\"Date\" = '2012-08-25' ORDER BY T1.\"Time\" DESC LIMIT 1",
            "normalized": "SELECT T2.\"Country\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T1.\"Date\" = '2012-08-25'\nORDER BY T1.\"Time\" DESC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.name AS CountryName\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN \"Country\" c ON g.Country = c.id\nWHERE t.Date = '2012-08-25'\nORDER BY t.Time\nLIMIT 1;",
            "normalized": "SELECT c.name AS CountryName\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nJOIN \"Country\" c ON g.Country = c.id\nWHERE t.Date = '2012-08-25'\nORDER BY t.Time\nLIMIT 1;"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "reference_sql_query": {
            "raw": "SELECT DISTINCT T3.\"Currency\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" INNER JOIN customers AS T3 ON T1.\"CustomerID\" = T3.\"CustomerID\" WHERE T1.\"Date\" = '2012-08-24' AND T1.\"Time\" = '16:25:00'",
            "normalized": "SELECT DISTINCT T3.\"Currency\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nINNER JOIN customers AS T3 ON T1.\"CustomerID\" = T3.\"CustomerID\"\nWHERE T1.\"Date\" = '2012-08-24'\n  AND T1.\"Time\" = '16:25:00'"
        },
        "generated_sql_query": {
            "raw": "SELECT c.Currency \nFROM public.transactions_1k t\nJOIN public.customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-24' AND t.Time = '16:25:00';",
            "normalized": "SELECT c.Currency\nFROM public.transactions_1k t\nJOIN public.customers c ON t.CustomerID = c.CustomerID\nWHERE t.Date = '2012-08-24'\n  AND t.Time = '16:25:00';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What segment did the customer have at 2012/8/23 21:20:00?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Segment\" FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Date\" = '2012-08-23' AND T1.\"Time\" = '21:20:00'",
            "normalized": "SELECT T2.\"Segment\"\nFROM transactions_1k AS T1\nINNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Date\" = '2012-08-23'\n  AND T1.\"Time\" = '21:20:00'"
        },
        "generated_sql_query": {
            "raw": "The provided context is insufficient to generate the SQL query because there is no direct relationship or timestamp information linking the \"customers\" table with the \"transactions_1k\" table, which contains date and time information.",
            "normalized": "The provided context IS insufficient TO generate the SQL query because there IS NO direct relationship\nOR timestamp information linking the \"customers\" TABLE WITH the \"transactions_1k\" TABLE,\n                                                                                  which CONTAINS date\nAND TIME information."
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "How many transactions were paid in CZK in the morning of 2012/8/26?",
        "reference_sql_query": {
            "raw": "SELECT COUNT(T1.\"TransactionID\") FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" WHERE T1.\"Date\" = '2012-08-26' AND T1.\"Time\" < '13:00:00' AND T2.\"Currency\" = 'CZK'",
            "normalized": "SELECT COUNT(T1.\"TransactionID\")\nFROM transactions_1k AS T1\nINNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nWHERE T1.\"Date\" = '2012-08-26'\n  AND T1.\"Time\" < '13:00:00'\n  AND T2.\"Currency\" = 'CZK'"
        },
        "generated_sql_query": {
            "raw": "SELECT COUNT(*) \nFROM public.transactions_1k t\nJOIN public.customers c ON t.\"CustomerID\" = c.\"CustomerID\"\nWHERE t.\"Date\" = '2012-08-26' \nAND t.\"Time\" < '12:00:00'\nAND c.\"Currency\" = 'CZK';",
            "normalized": "SELECT COUNT(*)\nFROM public.transactions_1k t\nJOIN public.customers c ON t.\"CustomerID\" = c.\"CustomerID\"\nWHERE t.\"Date\" = '2012-08-26'\n  AND t.\"Time\" < '12:00:00'\n  AND c.\"Currency\" = 'CZK';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "For the earliest customer, what segment did he/she have?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Segment\" FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\" ORDER BY \"Date\" ASC LIMIT 1",
            "normalized": "SELECT T2.\"Segment\"\nFROM transactions_1k AS T1\nINNER JOIN customers AS T2 ON T1.\"CustomerID\" = T2.\"CustomerID\"\nORDER BY \"Date\" ASC\nLIMIT 1"
        },
        "generated_sql_query": {
            "raw": "SELECT c.\"Segment\"\nFROM public.customers c\nJOIN (\n    SELECT \"CustomerID\"\n    FROM public.yearmonth\n    ORDER BY \"Date\" ASC\n    LIMIT 1\n) earliest_customer ON c.\"CustomerID\" = earliest_customer.\"CustomerID\"",
            "normalized": "SELECT c.\"Segment\"\nFROM public.customers c\nJOIN\n  (SELECT \"CustomerID\"\n   FROM public.yearmonth\n   ORDER BY \"Date\" ASC\n   LIMIT 1) earliest_customer ON c.\"CustomerID\" = earliest_customer.\"CustomerID\""
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "For the deal happened at 2012/8/24 12:42:00, which country was it?",
        "reference_sql_query": {
            "raw": "SELECT T2.\"Country\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T1.\"Date\" = '2012-08-24' AND T1.\"Time\" = '12:42:00'",
            "normalized": "SELECT T2.\"Country\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T1.\"Date\" = '2012-08-24'\n  AND T1.\"Time\" = '12:42:00'"
        },
        "generated_sql_query": {
            "raw": "SELECT g.Country\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24' AND t.Time = '12:42:00';",
            "normalized": "SELECT g.Country\nFROM public.transactions_1k t\nJOIN public.gasstations g ON t.GasStationID = g.GasStationID\nWHERE t.Date = '2012-08-24'\n  AND t.Time = '12:42:00';"
        },
        "db_id": "debit_card_specializing"
    },
    {
        "question": "What was the product id of the transaction happened at 2012/8/23 21:20:00?",
        "reference_sql_query": {
            "raw": "SELECT T1.\"ProductID\" FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\" WHERE T1.\"Date\" = '2012-08-23' AND T1.\"Time\" = '21:20:00'",
            "normalized": "SELECT T1.\"ProductID\"\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.\"GasStationID\" = T2.\"GasStationID\"\nWHERE T1.\"Date\" = '2012-08-23'\n  AND T1.\"Time\" = '21:20:00'"
        },
        "generated_sql_query": {
            "raw": "SELECT \"ProductID\" \nFROM public.transactions_1k \nWHERE \"Date\" = '2012-08-23' AND \"Time\" = '21:20:00';",
            "normalized": "SELECT \"ProductID\"\nFROM public.transactions_1k\nWHERE \"Date\" = '2012-08-23'\n  AND \"Time\" = '21:20:00';"
        },
        "db_id": "debit_card_specializing"
    }
]